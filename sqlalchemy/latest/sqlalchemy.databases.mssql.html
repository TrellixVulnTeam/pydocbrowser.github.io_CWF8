<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.databases.mssql</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.databases.html" class="internal-link" title="sqlalchemy.databases">databases</a></code><wbr></wbr>.<code><a href="sqlalchemy.databases.mssql.html" class="internal-link" title="sqlalchemy.databases.mssql">mssql</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><div class="rst-section" id="rst-external-dialects">
<span id="rst-mssql-external-dialects"></span><h2 class="heading">External Dialects</h2>
<p>In addition to the above DBAPI layers with native SQLAlchemy support, there
are third-party dialects for other DBAPI layers that are compatible
with SQL Server. See the "External Dialects" list on the
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`dialect_toplevel`</span></a> page.</p>
</div>
<div class="rst-section" id="rst-auto-increment-behavior-identity-columns">
<span id="rst-mssql-identity"></span><h2 class="heading">Auto Increment Behavior / IDENTITY Columns</h2>
<p>SQL Server provides so-called "auto incrementing" behavior using the
<tt class="rst-docutils literal">IDENTITY</tt> construct, which can be placed on any single integer column in a
table. SQLAlchemy considers <tt class="rst-docutils literal">IDENTITY</tt> within its default "autoincrement"
behavior for an integer primary key column, described at
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`_schema.Column.autoincrement`</span></a>.  This means that by default,
the first integer primary key column in a <code>_schema.Table</code> will be
considered to be the identity column - unless it is associated with a
<code>.Sequence</code> - and will generate DDL as such:</p>
<pre class="rst-literal-block">
from sqlalchemy import Table, MetaData, Column, Integer

m = MetaData()
t = Table('t', m,
        Column('id', Integer, primary_key=True),
        Column('x', Integer))
m.create_all(engine)
</pre>
<p>The above example will generate DDL as:</p>
<pre class="rst-code rst-sql rst-literal-block">
CREATE TABLE t (
    id INTEGER NOT NULL IDENTITY,
    x INTEGER NULL,
    PRIMARY KEY (id)
)
</pre>
<p>For the case where this default generation of <tt class="rst-docutils literal">IDENTITY</tt> is not desired,
specify <tt class="rst-docutils literal">False</tt> for the <a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:paramref:`_schema.Column.autoincrement`</span></a> flag,
on the first integer primary key column:</p>
<pre class="rst-literal-block">
m = MetaData()
t = Table('t', m,
        Column('id', Integer, primary_key=True, autoincrement=False),
        Column('x', Integer))
m.create_all(engine)
</pre>
<p>To add the <tt class="rst-docutils literal">IDENTITY</tt> keyword to a non-primary key column, specify
<tt class="rst-docutils literal">True</tt> for the <a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:paramref:`_schema.Column.autoincrement`</span></a> flag on the desired
<code>_schema.Column</code> object, and ensure that
<a href="#system-message-5"><span class="rst-problematic" id="rst-problematic-5">:paramref:`_schema.Column.autoincrement`</span></a>
is set to <tt class="rst-docutils literal">False</tt> on any integer primary key column:</p>
<pre class="rst-literal-block">
m = MetaData()
t = Table('t', m,
        Column('id', Integer, primary_key=True, autoincrement=False),
        Column('x', Integer, autoincrement=True))
m.create_all(engine)
</pre>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>Added <code>_schema.Identity</code> construct
in a <code>_schema.Column</code> to specify the start and increment
parameters of an IDENTITY. These replace
the use of the <code>.Sequence</code> object in order to specify these values.</span></div>
<div class="rst-deprecated">
<span class="rst-versionmodified rst-deprecated">Deprecated since version 1.4: </span><span>The <tt class="rst-docutils literal">mssql_identity_start</tt> and <tt class="rst-docutils literal">mssql_identity_increment</tt> parameters
to <code>_schema.Column</code> are deprecated and should we replaced by
an <code>_schema.Identity</code> object. Specifying both ways of configuring
an IDENTITY will result in a compile error.
These options are also no longer returned as part of the
<tt class="rst-docutils literal">dialect_options</tt> key in <code>_reflection.Inspector.get_columns</code>.
Use the information in the <tt class="rst-docutils literal">identity</tt> key instead.</span></div>
<div class="rst-deprecated">
<span class="rst-versionmodified rst-deprecated">Deprecated since version 1.3: </span><span>The use of <code>.Sequence</code> to specify IDENTITY characteristics is
deprecated and will be removed in a future release.   Please use
the <code>_schema.Identity</code> object parameters
<a href="#system-message-6"><span class="rst-problematic" id="rst-problematic-6">:paramref:`_schema.Identity.start`</span></a> and
<a href="#system-message-7"><span class="rst-problematic" id="rst-problematic-7">:paramref:`_schema.Identity.increment`</span></a>.</span></div>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>Removed the ability to use a <code>.Sequence</code>
object to modify IDENTITY characteristics. <code>.Sequence</code> objects
now only manipulate true T-SQL SEQUENCE types.</span></div>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p class="rst-last">There can only be one IDENTITY column on the table.  When using
<tt class="rst-docutils literal">autoincrement=True</tt> to enable the IDENTITY keyword, SQLAlchemy does not
guard against multiple columns specifying the option simultaneously.  The
SQL Server database will instead reject the <tt class="rst-docutils literal">CREATE TABLE</tt> statement.</p>
</div>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p class="rst-last">An INSERT statement which attempts to provide a value for a column that is
marked with IDENTITY will be rejected by SQL Server.   In order for the
value to be accepted, a session-level option "SET IDENTITY_INSERT" must be
enabled.   The SQLAlchemy SQL Server dialect will perform this operation
automatically when using a core <code>_expression.Insert</code>
construct; if the
execution specifies a value for the IDENTITY column, the "IDENTITY_INSERT"
option will be enabled for the span of that statement's invocation.However,
this scenario is not high performing and should not be relied upon for
normal use.   If a table doesn't actually require IDENTITY behavior in its
integer primary key column, the keyword should be disabled when creating
the table by ensuring that <tt class="rst-docutils literal">autoincrement=False</tt> is set.</p>
</div>
<div class="rst-section" id="rst-controlling-start-and-increment">
<h3 class="heading">Controlling "Start" and "Increment"</h3>
<p>Specific control over the "start" and "increment" values for
the <tt class="rst-docutils literal">IDENTITY</tt> generator are provided using the
<a href="#system-message-8"><span class="rst-problematic" id="rst-problematic-8">:paramref:`_schema.Identity.start`</span></a> and <a href="#system-message-9"><span class="rst-problematic" id="rst-problematic-9">:paramref:`_schema.Identity.increment`</span></a>
parameters passed to the <code>_schema.Identity</code> object:</p>
<pre class="rst-literal-block">
from sqlalchemy import Table, Integer, Column, Identity

test = Table(
    'test', metadata,
    Column(
        'id',
        Integer,
        primary_key=True,
        Identity(start=100, increment=10)
    ),
    Column('name', String(20))
)
</pre>
<p>The CREATE TABLE for the above <code>_schema.Table</code> object would be:</p>
<pre class="rst-code rst-sql rst-literal-block">
CREATE TABLE test (
  id INTEGER NOT NULL IDENTITY(100,10) PRIMARY KEY,
  name VARCHAR(20) NULL,
  )
</pre>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p class="rst-last">The <code>_schema.Identity</code> object supports many other parameter in
addition to <tt class="rst-docutils literal">start</tt> and <tt class="rst-docutils literal">increment</tt>. These are not supported by
SQL Server and will be ignored when generating the CREATE TABLE ddl.</p>
</div>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.3.19: </span><span>The <code>_schema.Identity</code> object is
now used to affect the
<tt class="rst-docutils literal">IDENTITY</tt> generator for a <code>_schema.Column</code> under  SQL Server.
Previously, the <code>.Sequence</code> object was used.  As SQL Server now
supports real sequences as a separate construct, <code>.Sequence</code> will be
functional in the normal way starting from SQLAlchemy version 1.4.</span></div>
</div>
<div class="rst-section" id="rst-using-identity-with-non-integer-numeric-types">
<h3 class="heading">Using IDENTITY with Non-Integer numeric types</h3>
<p>SQL Server also allows <tt class="rst-docutils literal">IDENTITY</tt> to be used with <tt class="rst-docutils literal">NUMERIC</tt> columns.  To
implement this pattern smoothly in SQLAlchemy, the primary datatype of the
column should remain as <tt class="rst-docutils literal">Integer</tt>, however the underlying implementation
type deployed to the SQL Server database can be specified as <tt class="rst-docutils literal">Numeric</tt> using
<code>.TypeEngine.with_variant</code>:</p>
<pre class="rst-literal-block">
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import Numeric
from sqlalchemy import String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class TestTable(Base):
    __tablename__ = "test"
    id = Column(
        Integer().with_variant(Numeric(10, 0), "mssql"),
        primary_key=True,
        autoincrement=True,
    )
    name = Column(String)
</pre>
<p>In the above example, <tt class="rst-docutils literal"><span class="pre">Integer().with_variant()</span></tt> provides clear usage
information that accurately describes the intent of the code. The general
restriction that <tt class="rst-docutils literal">autoincrement</tt> only applies to <tt class="rst-docutils literal">Integer</tt> is established
at the metadata level and not at the per-dialect level.</p>
<p>When using the above pattern, the primary key identifier that comes back from
the insertion of a row, which is also the value that would be assigned to an
ORM object such as <tt class="rst-docutils literal">TestTable</tt> above, will be an instance of <tt class="rst-docutils literal">Decimal()</tt>
and not <tt class="rst-docutils literal">int</tt> when using SQL Server. The numeric return type of the
<code>_types.Numeric</code> type can be changed to return floats by passing False
to <a href="#system-message-10"><span class="rst-problematic" id="rst-problematic-10">:paramref:`_types.Numeric.asdecimal`</span></a>. To normalize the return type of the
above <tt class="rst-docutils literal">Numeric(10, 0)</tt> to return Python ints (which also support "long"
integer values in Python 3), use <code>_types.TypeDecorator</code> as follows:</p>
<pre class="rst-literal-block">
from sqlalchemy import TypeDecorator

class NumericAsInteger(TypeDecorator):
    '''normalize floating point return values into ints'''

    impl = Numeric(10, 0, asdecimal=False)
    cache_ok = True

    def process_result_value(self, value, dialect):
        if value is not None:
            value = int(value)
        return value

class TestTable(Base):
    __tablename__ = "test"
    id = Column(
        Integer().with_variant(NumericAsInteger, "mssql"),
        primary_key=True,
        autoincrement=True,
    )
    name = Column(String)
</pre>
</div>
<div class="rst-section" id="rst-insert-behavior">
<h3 class="heading">INSERT behavior</h3>
<p>Handling of the <tt class="rst-docutils literal">IDENTITY</tt> column at INSERT time involves two key
techniques. The most common is being able to fetch the "last inserted value"
for a given <tt class="rst-docutils literal">IDENTITY</tt> column, a process which SQLAlchemy performs
implicitly in many cases, most importantly within the ORM.</p>
<p>The process for fetching this value has several variants:</p>
<ul>
<li><p class="rst-first">In the vast majority of cases, RETURNING is used in conjunction with INSERT
statements on SQL Server in order to get newly generated primary key values:</p>
<pre class="rst-code rst-sql rst-literal-block">
INSERT INTO t (x) OUTPUT inserted.id VALUES (?)
</pre>
</li>
<li><p class="rst-first">When RETURNING is not available or has been disabled via
<tt class="rst-docutils literal">implicit_returning=False</tt>, either the <tt class="rst-docutils literal">scope_identity()</tt> function or
the <tt class="rst-docutils literal">@@identity</tt> variable is used; behavior varies by backend:</p>
<ul>
<li><p class="rst-first">when using PyODBC, the phrase <tt class="rst-docutils literal">; select scope_identity()</tt> will be
appended to the end of the INSERT statement; a second result set will be
fetched in order to receive the value.  Given a table as:</p>
<pre class="rst-literal-block">
t = Table('t', m, Column('id', Integer, primary_key=True),
        Column('x', Integer),
        implicit_returning=False)
</pre>
<p>an INSERT will look like:</p>
<pre class="rst-code rst-sql rst-literal-block">
INSERT INTO t (x) VALUES (?); select scope_identity()
</pre>
</li>
<li><p class="rst-first">Other dialects such as pymssql will call upon
<tt class="rst-docutils literal">SELECT scope_identity() AS lastrowid</tt> subsequent to an INSERT
statement. If the flag <tt class="rst-docutils literal">use_scope_identity=False</tt> is passed to
<code>_sa.create_engine</code>,
the statement <tt class="rst-docutils literal">SELECT @@identity AS lastrowid</tt>
is used instead.</p>
</li>
</ul>
</li>
</ul>
<p>A table that contains an <tt class="rst-docutils literal">IDENTITY</tt> column will prohibit an INSERT statement
that refers to the identity column explicitly.  The SQLAlchemy dialect will
detect when an INSERT construct, created using a core
<code>_expression.insert</code>
construct (not a plain string SQL), refers to the identity column, and
in this case will emit <tt class="rst-docutils literal">SET IDENTITY_INSERT ON</tt> prior to the insert
statement proceeding, and <tt class="rst-docutils literal">SET IDENTITY_INSERT OFF</tt> subsequent to the
execution.  Given this example:</p>
<pre class="rst-literal-block">
m = MetaData()
t = Table('t', m, Column('id', Integer, primary_key=True),
                Column('x', Integer))
m.create_all(engine)

with engine.begin() as conn:
    conn.execute(t.insert(), {'id': 1, 'x':1}, {'id':2, 'x':2})
</pre>
<p>The above column will be created with IDENTITY, however the INSERT statement
we emit is specifying explicit values.  In the echo output we can see
how SQLAlchemy handles this:</p>
<pre class="rst-code rst-sql rst-literal-block">
CREATE TABLE t (
    id INTEGER NOT NULL IDENTITY(1,1),
    x INTEGER NULL,
    PRIMARY KEY (id)
)

COMMIT
SET IDENTITY_INSERT t ON
INSERT INTO t (id, x) VALUES (?, ?)
((1, 1), (2, 2))
SET IDENTITY_INSERT t OFF
COMMIT
</pre>
<p>This is an auxiliary use case suitable for testing and bulk insert scenarios.</p>
</div>
</div>
<div class="rst-section" id="rst-sequence-support">
<h2 class="heading">SEQUENCE support</h2>
<p>The <code>.Sequence</code> object now creates "real" sequences, i.e.,
<tt class="rst-docutils literal">CREATE SEQUENCE</tt>. To provide compatibility with other dialects,
<code>.Sequence</code> defaults to a start value of 1, even though the
T-SQL defaults is -9223372036854775808.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.0.</span></div>
</div>
<div class="rst-section" id="rst-max-on-varchar-nvarchar">
<h2 class="heading">MAX on VARCHAR / NVARCHAR</h2>
<p>SQL Server supports the special string "MAX" within the
<code>_types.VARCHAR</code> and <code>_types.NVARCHAR</code> datatypes,
to indicate "maximum length possible".   The dialect currently handles this as
a length of "None" in the base type, rather than supplying a
dialect-specific version of these types, so that a base type
specified such as <tt class="rst-docutils literal">VARCHAR(None)</tt> can assume "unlengthed" behavior on
more than one backend without using dialect-specific types.</p>
<p>To build a SQL Server VARCHAR or NVARCHAR with MAX length, use None:</p>
<pre class="rst-literal-block">
my_table = Table(
    'my_table', metadata,
    Column('my_data', VARCHAR(None)),
    Column('my_n_data', NVARCHAR(None))
)
</pre>
</div>
<div class="rst-section" id="rst-collation-support">
<h2 class="heading">Collation Support</h2>
<p>Character collations are supported by the base string types,
specified by the string argument "collation":</p>
<pre class="rst-literal-block">
from sqlalchemy import VARCHAR
Column('login', VARCHAR(32, collation='Latin1_General_CI_AS'))
</pre>
<p>When such a column is associated with a <code>_schema.Table</code>, the
CREATE TABLE statement for this column will yield:</p>
<pre class="rst-literal-block">
login VARCHAR(32) COLLATE Latin1_General_CI_AS NULL
</pre>
</div>
<div class="rst-section" id="rst-limit-offset-support">
<h2 class="heading">LIMIT/OFFSET Support</h2>
<p>MSSQL has added support for LIMIT / OFFSET as of SQL Server 2012, via the
"OFFSET n ROWS" and "FETCH NEXT n ROWS" clauses.  SQLAlchemy supports these
syntaxes automatically if SQL Server 2012 or greater is detected.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>support added for SQL Server "OFFSET n ROWS" and
"FETCH NEXT n ROWS" syntax.</span></div>
<p>For statements that specify only LIMIT and no OFFSET, all versions of SQL
Server support the TOP keyword.   This syntax is used for all SQL Server
versions when no OFFSET clause is present.  A statement such as:</p>
<pre class="rst-literal-block">
select(some_table).limit(5)
</pre>
<p>will render similarly to:</p>
<pre class="rst-literal-block">
SELECT TOP 5 col1, col2.. FROM table
</pre>
<p>For versions of SQL Server prior to SQL Server 2012, a statement that uses
LIMIT and OFFSET, or just OFFSET alone, will be rendered using the
<tt class="rst-docutils literal">ROW_NUMBER()</tt> window function.   A statement such as:</p>
<pre class="rst-literal-block">
select(some_table).order_by(some_table.c.col3).limit(5).offset(10)
</pre>
<p>will render similarly to:</p>
<pre class="rst-literal-block">
SELECT anon_1.col1, anon_1.col2 FROM (SELECT col1, col2,
ROW_NUMBER() OVER (ORDER BY col3) AS
mssql_rn FROM table WHERE t.x = :x_1) AS
anon_1 WHERE mssql_rn &gt; :param_1 AND mssql_rn &lt;= :param_2 + :param_1
</pre>
<p>Note that when using LIMIT and/or OFFSET, whether using the older
or newer SQL Server syntaxes, the statement must have an ORDER BY as well,
else a <code>.CompileError</code> is raised.</p>
</div>
<div class="rst-section" id="rst-transaction-isolation-level">
<span id="rst-mssql-isolation-level"></span><h2 class="heading">Transaction Isolation Level</h2>
<p>All SQL Server dialects support setting of transaction isolation level
both via a dialect-specific parameter
<a href="#system-message-11"><span class="rst-problematic" id="rst-problematic-11">:paramref:`_sa.create_engine.isolation_level`</span></a>
accepted by <code>_sa.create_engine</code>,
as well as the <a href="#system-message-12"><span class="rst-problematic" id="rst-problematic-12">:paramref:`.Connection.execution_options.isolation_level`</span></a>
argument as passed to
<code>_engine.Connection.execution_options</code>.
This feature works by issuing the
command <tt class="rst-docutils literal">SET TRANSACTION ISOLATION LEVEL &lt;level&gt;</tt> for
each new connection.</p>
<p>To set isolation level using <code>_sa.create_engine</code>:</p>
<pre class="rst-literal-block">
engine = create_engine(
    "mssql+pyodbc://scott:tiger@ms_2008",
    isolation_level="REPEATABLE READ"
)
</pre>
<p>To set using per-connection execution options:</p>
<pre class="rst-literal-block">
connection = engine.connect()
connection = connection.execution_options(
    isolation_level="READ COMMITTED"
)
</pre>
<p>Valid values for <tt class="rst-docutils literal">isolation_level</tt> include:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">AUTOCOMMIT</tt> - pyodbc / pymssql-specific</li>
<li><tt class="rst-docutils literal">READ COMMITTED</tt></li>
<li><tt class="rst-docutils literal">READ UNCOMMITTED</tt></li>
<li><tt class="rst-docutils literal">REPEATABLE READ</tt></li>
<li><tt class="rst-docutils literal">SERIALIZABLE</tt></li>
<li><tt class="rst-docutils literal">SNAPSHOT</tt> - specific to SQL Server</li>
</ul>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.2: </span><span>added AUTOCOMMIT isolation level setting</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-13"><span class="rst-problematic" id="rst-problematic-13">:ref:`dbapi_autocommit`</span></a></p>
</div>
</div>
<div class="rst-section" id="rst-nullability">
<h2 class="heading">Nullability</h2>
<p>MSSQL has support for three levels of column nullability. The default
nullability allows nulls and is explicit in the CREATE TABLE
construct:</p>
<pre class="rst-literal-block">
name VARCHAR(20) NULL
</pre>
<p>If <tt class="rst-docutils literal">nullable=None</tt> is specified then no specification is made. In
other words the database's configured default is used. This will
render:</p>
<pre class="rst-literal-block">
name VARCHAR(20)
</pre>
<p>If <tt class="rst-docutils literal">nullable</tt> is <tt class="rst-docutils literal">True</tt> or <tt class="rst-docutils literal">False</tt> then the column will be
<tt class="rst-docutils literal">NULL</tt> or <tt class="rst-docutils literal">NOT NULL</tt> respectively.</p>
</div>
<div class="rst-section" id="rst-date-time-handling">
<h2 class="heading">Date / Time Handling</h2>
<p>DATE and TIME are supported.   Bind parameters are converted
to datetime.datetime() objects as required by most MSSQL drivers,
and results are processed from strings if needed.
The DATE and TIME types are not available for MSSQL 2005 and
previous - if a server version below 2008 is detected, DDL
for these types will be issued as DATETIME.</p>
</div>
<div class="rst-section" id="rst-large-text-binary-type-deprecation">
<span id="rst-mssql-large-type-deprecation"></span><h2 class="heading">Large Text/Binary Type Deprecation</h2>
<p>Per
<a class="rst-reference external" href="https://technet.microsoft.com/en-us/library/ms187993.aspx" target="_top">SQL Server 2012/2014 Documentation</a>,
the <tt class="rst-docutils literal">NTEXT</tt>, <tt class="rst-docutils literal">TEXT</tt> and <tt class="rst-docutils literal">IMAGE</tt> datatypes are to be removed from SQL
Server in a future release.   SQLAlchemy normally relates these types to the
<code>.UnicodeText</code>, <code>_expression.TextClause</code> and
<code>.LargeBinary</code> datatypes.</p>
<p>In order to accommodate this change, a new flag <tt class="rst-docutils literal">deprecate_large_types</tt>
is added to the dialect, which will be automatically set based on detection
of the server version in use, if not otherwise set by the user.  The
behavior of this flag is as follows:</p>
<ul>
<li><p class="rst-first">When this flag is <tt class="rst-docutils literal">True</tt>, the <code>.UnicodeText</code>,
<code>_expression.TextClause</code> and
<code>.LargeBinary</code> datatypes, when used to render DDL, will render the
types <tt class="rst-docutils literal">NVARCHAR(max)</tt>, <tt class="rst-docutils literal">VARCHAR(max)</tt>, and <tt class="rst-docutils literal">VARBINARY(max)</tt>,
respectively.  This is a new behavior as of the addition of this flag.</p>
</li>
<li><p class="rst-first">When this flag is <tt class="rst-docutils literal">False</tt>, the <code>.UnicodeText</code>,
<code>_expression.TextClause</code> and
<code>.LargeBinary</code> datatypes, when used to render DDL, will render the
types <tt class="rst-docutils literal">NTEXT</tt>, <tt class="rst-docutils literal">TEXT</tt>, and <tt class="rst-docutils literal">IMAGE</tt>,
respectively.  This is the long-standing behavior of these types.</p>
</li>
<li><p class="rst-first">The flag begins with the value <tt class="rst-docutils literal">None</tt>, before a database connection is
established.   If the dialect is used to render DDL without the flag being
set, it is interpreted the same as <tt class="rst-docutils literal">False</tt>.</p>
</li>
<li><p class="rst-first">On first connection, the dialect detects if SQL Server version 2012 or
greater is in use; if the flag is still at <tt class="rst-docutils literal">None</tt>, it sets it to <tt class="rst-docutils literal">True</tt>
or <tt class="rst-docutils literal">False</tt> based on whether 2012 or greater is detected.</p>
</li>
<li><p class="rst-first">The flag can be set to either <tt class="rst-docutils literal">True</tt> or <tt class="rst-docutils literal">False</tt> when the dialect
is created, typically via <code>_sa.create_engine</code>:</p>
<pre class="rst-literal-block">
eng = create_engine("mssql+pymssql://user:pass@host/db",
                deprecate_large_types=True)
</pre>
</li>
<li><p class="rst-first">Complete control over whether the "old" or "new" types are rendered is
available in all SQLAlchemy versions by using the UPPERCASE type objects
instead: <code>_types.NVARCHAR</code>, <code>_types.VARCHAR</code>,
<code>_types.VARBINARY</code>, <code>_types.TEXT</code>, <code>_mssql.NTEXT</code>,
<code>_mssql.IMAGE</code>
will always remain fixed and always output exactly that
type.</p>
</li>
</ul>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.0.0.</span></div>
</div>
<div class="rst-section" id="rst-multipart-schema-names-1">
<span id="rst-multipart-schema-names"></span><h2 class="heading">Multipart Schema Names</h2>
<p>SQL Server schemas sometimes require multiple parts to their "schema"
qualifier, that is, including the database name and owner name as separate
tokens, such as <tt class="rst-docutils literal">mydatabase.dbo.some_table</tt>. These multipart names can be set
at once using the <a href="#system-message-14"><span class="rst-problematic" id="rst-problematic-14">:paramref:`_schema.Table.schema`</span></a> argument of
<code>_schema.Table</code>:</p>
<pre class="rst-literal-block">
Table(
    "some_table", metadata,
    Column("q", String(50)),
    schema="mydatabase.dbo"
)
</pre>
<p>When performing operations such as table or component reflection, a schema
argument that contains a dot will be split into separate
"database" and "owner"  components in order to correctly query the SQL
Server information schema tables, as these two values are stored separately.
Additionally, when rendering the schema name for DDL or SQL, the two
components will be quoted separately for case sensitive names and other
special characters.   Given an argument as below:</p>
<pre class="rst-literal-block">
Table(
    "some_table", metadata,
    Column("q", String(50)),
    schema="MyDataBase.dbo"
)
</pre>
<p>The above schema would be rendered as <tt class="rst-docutils literal"><span class="pre">[MyDataBase].dbo</span></tt>, and also in
reflection, would be reflected using "dbo" as the owner and "MyDataBase"
as the database name.</p>
<p>To control how the schema name is broken into database / owner,
specify brackets (which in SQL Server are quoting characters) in the name.
Below, the "owner" will be considered as <tt class="rst-docutils literal">MyDataBase.dbo</tt> and the
"database" will be None:</p>
<pre class="rst-literal-block">
Table(
    "some_table", metadata,
    Column("q", String(50)),
    schema="[MyDataBase.dbo]"
)
</pre>
<p>To individually specify both database and owner name with special characters
or embedded dots, use two sets of brackets:</p>
<pre class="rst-literal-block">
Table(
    "some_table", metadata,
    Column("q", String(50)),
    schema="[MyDataBase.Period].[MyOwner.Dot]"
)
</pre>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.2: </span><span>the SQL Server dialect now treats brackets as
identifier delimiters splitting the schema into separate database
and owner tokens, to allow dots within either name itself.</span></div>
</div>
<div class="rst-section" id="rst-legacy-schema-mode">
<span id="rst-legacy-schema-rendering"></span><h2 class="heading">Legacy Schema Mode</h2>
<p>Very old versions of the MSSQL dialect introduced the behavior such that a
schema-qualified table would be auto-aliased when used in a
SELECT statement; given a table:</p>
<pre class="rst-literal-block">
account_table = Table(
    'account', metadata,
    Column('id', Integer, primary_key=True),
    Column('info', String(100)),
    schema="customer_schema"
)
</pre>
<p>this legacy mode of rendering would assume that "customer_schema.account"
would not be accepted by all parts of the SQL statement, as illustrated
below:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; eng = create_engine("mssql+pymssql://mydsn", legacy_schema_aliasing=True)
&gt;&gt;&gt; print(account_table.select().compile(eng))
SELECT account_1.id, account_1.info
FROM customer_schema.account AS account_1
</pre>
<p>This mode of behavior is now off by default, as it appears to have served
no purpose; however in the case that legacy applications rely upon it,
it is available using the <tt class="rst-docutils literal">legacy_schema_aliasing</tt> argument to
<code>_sa.create_engine</code> as illustrated above.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.1: </span><span>the <tt class="rst-docutils literal">legacy_schema_aliasing</tt> flag introduced
in version 1.0.5 to allow disabling of legacy mode for schemas now
defaults to False.</span></div>
<div class="rst-deprecated">
<span class="rst-versionmodified rst-deprecated">Deprecated since version 1.4: </span><span>The <tt class="rst-docutils literal">legacy_schema_aliasing</tt> flag is now
deprecated and will be removed in a future release.</span></div>
</div>
<div class="rst-section" id="rst-clustered-index-support">
<span id="rst-mssql-indexes"></span><h2 class="heading">Clustered Index Support</h2>
<p>The MSSQL dialect supports clustered indexes (and primary keys) via the
<tt class="rst-docutils literal">mssql_clustered</tt> option.  This option is available to <code>.Index</code>,
<code>.UniqueConstraint</code>. and <code>.PrimaryKeyConstraint</code>.</p>
<p>To generate a clustered index:</p>
<pre class="rst-literal-block">
Index("my_index", table.c.x, mssql_clustered=True)
</pre>
<p>which renders the index as <tt class="rst-docutils literal">CREATE CLUSTERED INDEX my_index ON table (x)</tt>.</p>
<p>To generate a clustered primary key use:</p>
<pre class="rst-literal-block">
Table('my_table', metadata,
      Column('x', ...),
      Column('y', ...),
      PrimaryKeyConstraint("x", "y", mssql_clustered=True))
</pre>
<p>which will render the table, for example, as:</p>
<pre class="rst-literal-block">
CREATE TABLE my_table (x INTEGER NOT NULL, y INTEGER NOT NULL,
                       PRIMARY KEY CLUSTERED (x, y))
</pre>
<p>Similarly, we can generate a clustered unique constraint using:</p>
<pre class="rst-literal-block">
Table('my_table', metadata,
      Column('x', ...),
      Column('y', ...),
      PrimaryKeyConstraint("x"),
      UniqueConstraint("y", mssql_clustered=True),
      )
</pre>
<p>To explicitly request a non-clustered primary key (for example, when
a separate clustered index is desired), use:</p>
<pre class="rst-literal-block">
Table('my_table', metadata,
      Column('x', ...),
      Column('y', ...),
      PrimaryKeyConstraint("x", "y", mssql_clustered=False))
</pre>
<p>which will render the table, for example, as:</p>
<pre class="rst-literal-block">
CREATE TABLE my_table (x INTEGER NOT NULL, y INTEGER NOT NULL,
                       PRIMARY KEY NONCLUSTERED (x, y))
</pre>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.1: </span><span>the <tt class="rst-docutils literal">mssql_clustered</tt> option now defaults
to None, rather than False.  <tt class="rst-docutils literal">mssql_clustered=False</tt> now explicitly
renders the NONCLUSTERED clause, whereas None omits the CLUSTERED
clause entirely, allowing SQL Server defaults to take effect.</span></div>
</div>
<div class="rst-section" id="rst-mssql-specific-index-options">
<h2 class="heading">MSSQL-Specific Index Options</h2>
<p>In addition to clustering, the MSSQL dialect supports other special options
for <code>.Index</code>.</p>
<div class="rst-section" id="rst-include">
<h3 class="heading">INCLUDE</h3>
<p>The <tt class="rst-docutils literal">mssql_include</tt> option renders INCLUDE(colname) for the given string
names:</p>
<pre class="rst-literal-block">
Index("my_index", table.c.x, mssql_include=['y'])
</pre>
<p>would render the index as <tt class="rst-docutils literal">CREATE INDEX my_index ON table (x) INCLUDE (y)</tt></p>
</div>
<div class="rst-section" id="rst-filtered-indexes">
<span id="rst-mssql-index-where"></span><h3 class="heading">Filtered Indexes</h3>
<p>The <tt class="rst-docutils literal">mssql_where</tt> option renders WHERE(condition) for the given string
names:</p>
<pre class="rst-literal-block">
Index("my_index", table.c.x, mssql_where=table.c.x &gt; 10)
</pre>
<p>would render the index as <tt class="rst-docutils literal">CREATE INDEX my_index ON table (x) WHERE x &gt; 10</tt>.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.3.4.</span></div>
</div>
<div class="rst-section" id="rst-index-ordering">
<h3 class="heading">Index ordering</h3>
<p>Index ordering is available via functional expressions, such as:</p>
<pre class="rst-literal-block">
Index("my_index", table.c.x.desc())
</pre>
<p>would render the index as <tt class="rst-docutils literal">CREATE INDEX my_index ON table (x DESC)</tt></p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-15"><span class="rst-problematic" id="rst-problematic-15">:ref:`schema_indexes_functional`</span></a></p>
</div>
</div>
</div>
<div class="rst-section" id="rst-compatibility-levels">
<h2 class="heading">Compatibility Levels</h2>
<p>MSSQL supports the notion of setting compatibility levels at the
database level. This allows, for instance, to run a database that
is compatible with SQL2000 while running on a SQL2005 database
server. <tt class="rst-docutils literal">server_version_info</tt> will always return the database
server version information (in this case SQL2005) and not the
compatibility level information. Because of this, if running under
a backwards compatibility mode SQLAlchemy may attempt to use T-SQL
statements that are unable to be parsed by the database server.</p>
</div>
<div class="rst-section" id="rst-triggers">
<h2 class="heading">Triggers</h2>
<p>SQLAlchemy by default uses OUTPUT INSERTED to get at newly
generated primary key values via IDENTITY columns or other
server side defaults.   MS-SQL does not
allow the usage of OUTPUT INSERTED on tables that have triggers.
To disable the usage of OUTPUT INSERTED on a per-table basis,
specify <tt class="rst-docutils literal">implicit_returning=False</tt> for each <code>_schema.Table</code>
which has triggers:</p>
<pre class="rst-literal-block">
Table('mytable', metadata,
    Column('id', Integer, primary_key=True),
    # ...,
    implicit_returning=False
)
</pre>
<p>Declarative form:</p>
<pre class="rst-literal-block">
class MyClass(Base):
    # ...
    __table_args__ = {'implicit_returning':False}
</pre>
<p>This option can also be specified engine-wide using the
<tt class="rst-docutils literal">implicit_returning=False</tt> argument on <code>_sa.create_engine</code>.</p>
</div>
<div class="rst-section" id="rst-rowcount-support-orm-versioning">
<span id="rst-mssql-rowcount-versioning"></span><h2 class="heading">Rowcount Support / ORM Versioning</h2>
<p>The SQL Server drivers may have limited ability to return the number
of rows updated from an UPDATE or DELETE statement.</p>
<p>As of this writing, the PyODBC driver is not able to return a rowcount when
OUTPUT INSERTED is used.  This impacts the SQLAlchemy ORM's versioning feature
in many cases where server-side value generators are in use in that while the
versioning operations can succeed, the ORM cannot always check that an UPDATE
or DELETE statement matched the number of rows expected, which is how it
verifies that the version identifier matched.   When this condition occurs, a
warning will be emitted but the operation will proceed.</p>
<p>The use of OUTPUT INSERTED can be disabled by setting the
<a href="#system-message-16"><span class="rst-problematic" id="rst-problematic-16">:paramref:`_schema.Table.implicit_returning`</span></a> flag to <tt class="rst-docutils literal">False</tt> on a particular
<code>_schema.Table</code>, which in declarative looks like:</p>
<pre class="rst-literal-block">
class MyTable(Base):
    __tablename__ = 'mytable'
    id = Column(Integer, primary_key=True)
    stuff = Column(String(10))
    timestamp = Column(TIMESTAMP(), default=text('DEFAULT'))
    __mapper_args__ = {
        'version_id_col': timestamp,
        'version_id_generator': False,
    }
    __table_args__ = {
        'implicit_returning': False
    }
</pre>
</div>
<div class="rst-section" id="rst-enabling-snapshot-isolation">
<h2 class="heading">Enabling Snapshot Isolation</h2>
<p>SQL Server has a default transaction
isolation mode that locks entire tables, and causes even mildly concurrent
applications to have long held locks and frequent deadlocks.
Enabling snapshot isolation for the database as a whole is recommended
for modern levels of concurrency support.  This is accomplished via the
following ALTER DATABASE commands executed at the SQL prompt:</p>
<pre class="rst-literal-block">
ALTER DATABASE MyDatabase SET ALLOW_SNAPSHOT_ISOLATION ON

ALTER DATABASE MyDatabase SET READ_COMMITTED_SNAPSHOT ON
</pre>
<p>Background on SQL Server snapshot isolation is available at
<a class="rst-reference external" href="https://msdn.microsoft.com/en-us/library/ms175095.aspx" target="_top">https://msdn.microsoft.com/en-us/library/ms175095.aspx</a>.</p>
</div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id14155">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql.MSDDLCompiler.html" class="internal-link" title="sqlalchemy.databases.mssql.MSDDLCompiler">​MSDDLCompiler</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql.MSDialect.html" class="internal-link" title="sqlalchemy.databases.mssql.MSDialect">​MSDialect</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql.MSExecutionContext.html" class="internal-link" title="sqlalchemy.databases.mssql.MSExecutionContext">​MSExecution​Context</a></code></td>
    <td><span class="undocumented">No class docstring; 0/1 property, 0/4 instance variable, 0/1 class variable, 2/8 methods documented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql.MSIdentifierPreparer.html" class="internal-link" title="sqlalchemy.databases.mssql.MSIdentifierPreparer">​MSIdentifier​Preparer</a></code></td>
    <td><span class="undocumented">No class docstring; 1/4 method documented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql.MSSQLCompiler.html" class="internal-link" title="sqlalchemy.databases.mssql.MSSQLCompiler">​MSSQLCompiler</a></code></td>
    <td><span class="undocumented">No class docstring; 0/1 instance variable, 0/2 class variable, 7/44 methods documented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql.MSSQLStrictCompiler.html" class="internal-link" title="sqlalchemy.databases.mssql.MSSQLStrictCompiler">​MSSQLStrict​Compiler</a></code></td>
    <td>A subclass of MSSQLCompiler which disables the usage of bind parameters where not allowed natively by MS-SQL.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql.MSTypeCompiler.html" class="internal-link" title="sqlalchemy.databases.mssql.MSTypeCompiler">​MSType​Compiler</a></code></td>
    <td><span class="undocumented">No class docstring; 1/33 method documented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql.TryCast.html" class="internal-link" title="sqlalchemy.databases.mssql.TryCast">​Try​Cast</a></code></td>
    <td>Represent a SQL Server TRY_CAST expression.</td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#MS_2000_VERSION" class="internal-link" title="sqlalchemy.databases.mssql.MS_2000_VERSION">MS​_2000​_VERSION</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#MS_2005_VERSION" class="internal-link" title="sqlalchemy.databases.mssql.MS_2005_VERSION">MS​_2005​_VERSION</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#MS_2008_VERSION" class="internal-link" title="sqlalchemy.databases.mssql.MS_2008_VERSION">MS​_2008​_VERSION</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#MS_2012_VERSION" class="internal-link" title="sqlalchemy.databases.mssql.MS_2012_VERSION">MS​_2012​_VERSION</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#MS_2014_VERSION" class="internal-link" title="sqlalchemy.databases.mssql.MS_2014_VERSION">MS​_2014​_VERSION</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#MS_2016_VERSION" class="internal-link" title="sqlalchemy.databases.mssql.MS_2016_VERSION">MS​_2016​_VERSION</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#MS_2017_VERSION" class="internal-link" title="sqlalchemy.databases.mssql.MS_2017_VERSION">MS​_2017​_VERSION</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#RESERVED_WORDS" class="internal-link" title="sqlalchemy.databases.mssql.RESERVED_WORDS">RESERVED​_WORDS</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><code><a href="#ischema_names" class="internal-link" title="sqlalchemy.databases.mssql.ischema_names">ischema​_names</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql._BASETIMEIMPL.html" class="internal-link" title="sqlalchemy.databases.mssql._BASETIMEIMPL">​_BASETIMEIMPL</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql._DateTimeBase.html" class="internal-link" title="sqlalchemy.databases.mssql._DateTimeBase">_​Date​Time​Base</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql._MSDate.html" class="internal-link" title="sqlalchemy.databases.mssql._MSDate">_​MSDate</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql._MSDateTime.html" class="internal-link" title="sqlalchemy.databases.mssql._MSDateTime">_​MSDate​Time</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql._MSUnicode.html" class="internal-link" title="sqlalchemy.databases.mssql._MSUnicode">_​MSUnicode</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql._MSUnicodeText.html" class="internal-link" title="sqlalchemy.databases.mssql._MSUnicodeText">_​MSUnicode​Text</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.mssql._UnicodeLiteral.html" class="internal-link" title="sqlalchemy.databases.mssql._UnicodeLiteral">_​Unicode​Literal</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_db_plus_owner" class="internal-link" title="sqlalchemy.databases.mssql._db_plus_owner">​_db​_plus​_owner</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_db_plus_owner_listing" class="internal-link" title="sqlalchemy.databases.mssql._db_plus_owner_listing">​_db​_plus​_owner​_listing</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_owner_plus_db" class="internal-link" title="sqlalchemy.databases.mssql._owner_plus_db">​_owner​_plus​_db</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_schema_elements" class="internal-link" title="sqlalchemy.databases.mssql._schema_elements">​_schema​_elements</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_switch_db" class="internal-link" title="sqlalchemy.databases.mssql._switch_db">​_switch​_db</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#_memoized_schema" class="internal-link" title="sqlalchemy.databases.mssql._memoized_schema">​_memoized​_schema</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.mssql.MS_2000_VERSION">
    
  </a>
  <a name="MS_2000_VERSION">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">MS_2000_VERSION</span>: <code>tuple[<wbr></wbr>int, <wbr></wbr><span class="rst-variable-ellipsis">...</span>]</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>(<wbr></wbr>8)</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.mssql.MS_2005_VERSION">
    
  </a>
  <a name="MS_2005_VERSION">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">MS_2005_VERSION</span>: <code>tuple[<wbr></wbr>int, <wbr></wbr><span class="rst-variable-ellipsis">...</span>]</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>(<wbr></wbr>9)</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.mssql.MS_2008_VERSION">
    
  </a>
  <a name="MS_2008_VERSION">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">MS_2008_VERSION</span>: <code>tuple[<wbr></wbr>int, <wbr></wbr><span class="rst-variable-ellipsis">...</span>]</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>(<wbr></wbr>10)</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.mssql.MS_2012_VERSION">
    
  </a>
  <a name="MS_2012_VERSION">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">MS_2012_VERSION</span>: <code>tuple[<wbr></wbr>int, <wbr></wbr><span class="rst-variable-ellipsis">...</span>]</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>(<wbr></wbr>11)</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.mssql.MS_2014_VERSION">
    
  </a>
  <a name="MS_2014_VERSION">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">MS_2014_VERSION</span>: <code>tuple[<wbr></wbr>int, <wbr></wbr><span class="rst-variable-ellipsis">...</span>]</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>(<wbr></wbr>12)</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.mssql.MS_2016_VERSION">
    
  </a>
  <a name="MS_2016_VERSION">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">MS_2016_VERSION</span>: <code>tuple[<wbr></wbr>int, <wbr></wbr><span class="rst-variable-ellipsis">...</span>]</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>(<wbr></wbr>13)</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.mssql.MS_2017_VERSION">
    
  </a>
  <a name="MS_2017_VERSION">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">MS_2017_VERSION</span>: <code>tuple[<wbr></wbr>int, <wbr></wbr><span class="rst-variable-ellipsis">...</span>]</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>(<wbr></wbr>14)</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.mssql.RESERVED_WORDS">
    
  </a>
  <a name="RESERVED_WORDS">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">RESERVED_WORDS</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>set(<wbr></wbr>[<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">add</span><span class="rst-variable-quote">'</span>,
     <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">all</span><span class="rst-variable-quote">'</span>,
     <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">alter</span><span class="rst-variable-quote">'</span>,
     <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">and</span><span class="rst-variable-quote">'</span>,
     <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">any</span><span class="rst-variable-quote">'</span>,
     <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">as</span><span class="rst-variable-quote">'</span>,
     <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">asc</span><span class="rst-variable-quote">'</span>,
<span class="rst-variable-ellipsis">...</span></code></pre></td></tr></table>
  </div>
</div><div class="basevariable">
  
  
  <a name="sqlalchemy.databases.mssql.ischema_names">
    
  </a>
  <a name="ischema_names">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">ischema_names</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.databases.mssql._db_plus_owner">
    
  </a>
  <a name="_db_plus_owner">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_db_plus_owner</span>(fn):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.databases.mssql._db_plus_owner_listing">
    
  </a>
  <a name="_db_plus_owner_listing">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_db_plus_owner_listing</span>(fn):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.databases.mssql._owner_plus_db">
    
  </a>
  <a name="_owner_plus_db">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_owner_plus_db</span>(dialect, schema):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.databases.mssql._schema_elements">
    
  </a>
  <a name="_schema_elements">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_schema_elements</span>(schema):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.databases.mssql._switch_db">
    
  </a>
  <a name="_switch_db">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_switch_db</span>(dbname, connection, fn, *arg, **kw):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basevariable private">
  
  
  <a name="sqlalchemy.databases.mssql._memoized_schema">
    
  </a>
  <a name="_memoized_schema">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_memoized_schema</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 04:41:59.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>