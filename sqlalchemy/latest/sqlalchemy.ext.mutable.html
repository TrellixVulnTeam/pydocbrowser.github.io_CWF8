<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.ext.mutable</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.ext.html" class="internal-link" title="sqlalchemy.ext">ext</a></code><wbr></wbr>.<code><a href="sqlalchemy.ext.mutable.html" class="internal-link" title="sqlalchemy.ext.mutable">mutable</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p>Provide support for tracking of in-place changes to scalar values,
which are propagated into ORM change events on owning parent objects.</p>
<div class="rst-section" id="rst-establishing-mutability-on-scalar-column-values">
<span id="rst-mutable-scalars"></span><h2 class="heading">Establishing Mutability on Scalar Column Values</h2>
<p>A typical example of a "mutable" structure is a Python dictionary.
Following the example introduced in <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`types_toplevel`</span></a>, we
begin with a custom type that marshals Python dictionaries into
JSON strings before being persisted:</p>
<pre class="rst-literal-block">
from sqlalchemy.types import TypeDecorator, VARCHAR
import json

class JSONEncodedDict(TypeDecorator):
    "Represents an immutable structure as a json-encoded string."

    impl = VARCHAR

    def process_bind_param(self, value, dialect):
        if value is not None:
            value = json.dumps(value)
        return value

    def process_result_value(self, value, dialect):
        if value is not None:
            value = json.loads(value)
        return value
</pre>
<p>The usage of <tt class="rst-docutils literal">json</tt> is only for the purposes of example. The
<code><a href="sqlalchemy.ext.mutable.html" class="internal-link">sqlalchemy.ext.mutable</a></code> extension can be used
with any type whose target Python type may be mutable, including
<code>.PickleType</code>, <code>_postgresql.ARRAY</code>, etc.</p>
<p>When using the <code><a href="sqlalchemy.ext.mutable.html" class="internal-link">sqlalchemy.ext.mutable</a></code> extension, the value itself
tracks all parents which reference it.  Below, we illustrate a simple
version of the <code>.MutableDict</code> dictionary object, which applies
the <code>.Mutable</code> mixin to a plain Python dictionary:</p>
<pre class="rst-literal-block">
from sqlalchemy.ext.mutable import Mutable

class MutableDict(Mutable, dict):
    @classmethod
    def coerce(cls, key, value):
        "Convert plain dictionaries to MutableDict."

        if not isinstance(value, MutableDict):
            if isinstance(value, dict):
                return MutableDict(value)

            # this call will raise ValueError
            return Mutable.coerce(key, value)
        else:
            return value

    def __setitem__(self, key, value):
        "Detect dictionary set events and emit change events."

        dict.__setitem__(self, key, value)
        self.changed()

    def __delitem__(self, key):
        "Detect dictionary del events and emit change events."

        dict.__delitem__(self, key)
        self.changed()
</pre>
<p>The above dictionary class takes the approach of subclassing the Python
built-in <tt class="rst-docutils literal">dict</tt> to produce a dict
subclass which routes all mutation events through <tt class="rst-docutils literal">__setitem__</tt>.  There are
variants on this approach, such as subclassing <tt class="rst-docutils literal">UserDict.UserDict</tt> or
<tt class="rst-docutils literal">collections.MutableMapping</tt>; the part that's important to this example is
that the <code>.Mutable.changed</code> method is called whenever an in-place
change to the datastructure takes place.</p>
<p>We also redefine the <code>.Mutable.coerce</code> method which will be used to
convert any values that are not instances of <tt class="rst-docutils literal">MutableDict</tt>, such
as the plain dictionaries returned by the <tt class="rst-docutils literal">json</tt> module, into the
appropriate type.  Defining this method is optional; we could just as well
created our <tt class="rst-docutils literal">JSONEncodedDict</tt> such that it always returns an instance
of <tt class="rst-docutils literal">MutableDict</tt>, and additionally ensured that all calling code
uses <tt class="rst-docutils literal">MutableDict</tt> explicitly.  When <code>.Mutable.coerce</code> is not
overridden, any values applied to a parent object which are not instances
of the mutable type will raise a <tt class="rst-docutils literal">ValueError</tt>.</p>
<p>Our new <tt class="rst-docutils literal">MutableDict</tt> type offers a class method
<code>~.Mutable.as_mutable</code> which we can use within column metadata
to associate with types. This method grabs the given type object or
class and associates a listener that will detect all future mappings
of this type, applying event listening instrumentation to the mapped
attribute. Such as, with classical table metadata:</p>
<pre class="rst-literal-block">
from sqlalchemy import Table, Column, Integer

my_data = Table('my_data', metadata,
    Column('id', Integer, primary_key=True),
    Column('data', MutableDict.as_mutable(JSONEncodedDict))
)
</pre>
<p>Above, <code>~.Mutable.as_mutable</code> returns an instance of <tt class="rst-docutils literal">JSONEncodedDict</tt>
(if the type object was not an instance already), which will intercept any
attributes which are mapped against this type.  Below we establish a simple
mapping against the <tt class="rst-docutils literal">my_data</tt> table:</p>
<pre class="rst-literal-block">
from sqlalchemy import mapper

class MyDataClass(object):
    pass

# associates mutation listeners with MyDataClass.data
mapper(MyDataClass, my_data)
</pre>
<p>The <tt class="rst-docutils literal">MyDataClass.data</tt> member will now be notified of in place changes
to its value.</p>
<p>There's no difference in usage when using declarative:</p>
<pre class="rst-literal-block">
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class MyDataClass(Base):
    __tablename__ = 'my_data'
    id = Column(Integer, primary_key=True)
    data = Column(MutableDict.as_mutable(JSONEncodedDict))
</pre>
<p>Any in-place changes to the <tt class="rst-docutils literal">MyDataClass.data</tt> member
will flag the attribute as "dirty" on the parent object:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy.orm import Session

&gt;&gt;&gt; sess = Session()
&gt;&gt;&gt; m1 = MyDataClass(data={'value1':'foo'})
&gt;&gt;&gt; sess.add(m1)
&gt;&gt;&gt; sess.commit()

&gt;&gt;&gt; m1.data['value1'] = 'bar'
&gt;&gt;&gt; assert m1 in sess.dirty
True
</pre>
<p>The <tt class="rst-docutils literal">MutableDict</tt> can be associated with all future instances
of <tt class="rst-docutils literal">JSONEncodedDict</tt> in one step, using
<code>~.Mutable.associate_with</code>.  This is similar to
<code>~.Mutable.as_mutable</code> except it will intercept all occurrences
of <tt class="rst-docutils literal">MutableDict</tt> in all mappings unconditionally, without
the need to declare it individually:</p>
<pre class="rst-literal-block">
MutableDict.associate_with(JSONEncodedDict)

class MyDataClass(Base):
    __tablename__ = 'my_data'
    id = Column(Integer, primary_key=True)
    data = Column(JSONEncodedDict)
</pre>
<div class="rst-section" id="rst-supporting-pickling">
<h3 class="heading">Supporting Pickling</h3>
<p>The key to the <code><a href="sqlalchemy.ext.mutable.html" class="internal-link">sqlalchemy.ext.mutable</a></code> extension relies upon the
placement of a <tt class="rst-docutils literal">weakref.WeakKeyDictionary</tt> upon the value object, which
stores a mapping of parent mapped objects keyed to the attribute name under
which they are associated with this value. <tt class="rst-docutils literal">WeakKeyDictionary</tt> objects are
not picklable, due to the fact that they contain weakrefs and function
callbacks. In our case, this is a good thing, since if this dictionary were
picklable, it could lead to an excessively large pickle size for our value
objects that are pickled by themselves outside of the context of the parent.
The developer responsibility here is only to provide a <tt class="rst-docutils literal">__getstate__</tt> method
that excludes the <code>~MutableBase._parents</code> collection from the pickle
stream:</p>
<pre class="rst-literal-block">
class MyMutableType(Mutable):
    def __getstate__(self):
        d = self.__dict__.copy()
        d.pop('_parents', None)
        return d
</pre>
<p>With our dictionary example, we need to return the contents of the dict itself
(and also restore them on __setstate__):</p>
<pre class="rst-literal-block">
class MutableDict(Mutable, dict):
    # ....

    def __getstate__(self):
        return dict(self)

    def __setstate__(self, state):
        self.update(state)
</pre>
<p>In the case that our mutable value object is pickled as it is attached to one
or more parent objects that are also part of the pickle, the <code>.Mutable</code>
mixin will re-establish the <code>.Mutable._parents</code> collection on each value
object as the owning parents themselves are unpickled.</p>
</div>
<div class="rst-section" id="rst-receiving-events">
<h3 class="heading">Receiving Events</h3>
<p>The <code>.AttributeEvents.modified</code> event handler may be used to receive
an event when a mutable scalar emits a change event.  This event handler
is called when the <code>.attributes.flag_modified</code> function is called
from within the mutable extension:</p>
<pre class="rst-literal-block">
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import event

Base = declarative_base()

class MyDataClass(Base):
    __tablename__ = 'my_data'
    id = Column(Integer, primary_key=True)
    data = Column(MutableDict.as_mutable(JSONEncodedDict))

@event.listens_for(MyDataClass.data, "modified")
def modified_json(instance):
    print("json value modified:", instance.data)
</pre>
</div>
</div>
<div class="rst-section" id="rst-establishing-mutability-on-composites">
<span id="rst-mutable-composites"></span><h2 class="heading">Establishing Mutability on Composites</h2>
<p>Composites are a special ORM feature which allow a single scalar attribute to
be assigned an object value which represents information "composed" from one
or more columns from the underlying mapped table. The usual example is that of
a geometric "point", and is introduced in <a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`mapper_composite`</span></a>.</p>
<p>As is the case with <code>.Mutable</code>, the user-defined composite class
subclasses <code>.MutableComposite</code> as a mixin, and detects and delivers
change events to its parents via the <code>.MutableComposite.changed</code> method.
In the case of a composite class, the detection is usually via the usage of
Python descriptors (i.e. <tt class="rst-docutils literal">@property</tt>), or alternatively via the special
Python method <tt class="rst-docutils literal">__setattr__()</tt>. Below we expand upon the <tt class="rst-docutils literal">Point</tt> class
introduced in <a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:ref:`mapper_composite`</span></a> to subclass <code>.MutableComposite</code>
and to also route attribute set events via <tt class="rst-docutils literal">__setattr__</tt> to the
<code>.MutableComposite.changed</code> method:</p>
<pre class="rst-literal-block">
from sqlalchemy.ext.mutable import MutableComposite

class Point(MutableComposite):
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __setattr__(self, key, value):
        "Intercept set events"

        # set the attribute
        object.__setattr__(self, key, value)

        # alert all parents to the change
        self.changed()

    def __composite_values__(self):
        return self.x, self.y

    def __eq__(self, other):
        return isinstance(other, Point) and \
            other.x == self.x and \
            other.y == self.y

    def __ne__(self, other):
        return not self.__eq__(other)
</pre>
<p>The <code>.MutableComposite</code> class uses a Python metaclass to automatically
establish listeners for any usage of <code>_orm.composite</code> that specifies our
<tt class="rst-docutils literal">Point</tt> type. Below, when <tt class="rst-docutils literal">Point</tt> is mapped to the <tt class="rst-docutils literal">Vertex</tt> class,
listeners are established which will route change events from <tt class="rst-docutils literal">Point</tt>
objects to each of the <tt class="rst-docutils literal">Vertex.start</tt> and <tt class="rst-docutils literal">Vertex.end</tt> attributes:</p>
<pre class="rst-literal-block">
from sqlalchemy.orm import composite, mapper
from sqlalchemy import Table, Column

vertices = Table('vertices', metadata,
    Column('id', Integer, primary_key=True),
    Column('x1', Integer),
    Column('y1', Integer),
    Column('x2', Integer),
    Column('y2', Integer),
    )

class Vertex(object):
    pass

mapper(Vertex, vertices, properties={
    'start': composite(Point, vertices.c.x1, vertices.c.y1),
    'end': composite(Point, vertices.c.x2, vertices.c.y2)
})
</pre>
<p>Any in-place changes to the <tt class="rst-docutils literal">Vertex.start</tt> or <tt class="rst-docutils literal">Vertex.end</tt> members
will flag the attribute as "dirty" on the parent object:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy.orm import Session

&gt;&gt;&gt; sess = Session()
&gt;&gt;&gt; v1 = Vertex(start=Point(3, 4), end=Point(12, 15))
&gt;&gt;&gt; sess.add(v1)
&gt;&gt;&gt; sess.commit()

&gt;&gt;&gt; v1.end.x = 8
&gt;&gt;&gt; assert v1 in sess.dirty
True
</pre>
<div class="rst-section" id="rst-coercing-mutable-composites">
<h3 class="heading">Coercing Mutable Composites</h3>
<p>The <code>.MutableBase.coerce</code> method is also supported on composite types.
In the case of <code>.MutableComposite</code>, the <code>.MutableBase.coerce</code>
method is only called for attribute set operations, not load operations.
Overriding the <code>.MutableBase.coerce</code> method is essentially equivalent
to using a <code>.validates</code> validation routine for all attributes which
make use of the custom composite type:</p>
<pre class="rst-literal-block">
class Point(MutableComposite):
    # other Point methods
    # ...

    def coerce(cls, key, value):
        if isinstance(value, tuple):
            value = Point(*value)
        elif not isinstance(value, Point):
            raise ValueError("tuple or Point expected")
        return value
</pre>
</div>
<div class="rst-section" id="rst-supporting-pickling-1">
<h3 class="heading">Supporting Pickling</h3>
<p>As is the case with <code>.Mutable</code>, the <code>.MutableComposite</code> helper
class uses a <tt class="rst-docutils literal">weakref.WeakKeyDictionary</tt> available via the
<code><a href="sqlalchemy.ext.mutable.MutableBase.html#_parents" class="internal-link" title="sqlalchemy.ext.mutable.MutableBase._parents">MutableBase._parents</a></code> attribute which isn't picklable. If we need to
pickle instances of <tt class="rst-docutils literal">Point</tt> or its owning class <tt class="rst-docutils literal">Vertex</tt>, we at least need
to define a <tt class="rst-docutils literal">__getstate__</tt> that doesn't include the <tt class="rst-docutils literal">_parents</tt> dictionary.
Below we define both a <tt class="rst-docutils literal">__getstate__</tt> and a <tt class="rst-docutils literal">__setstate__</tt> that package up
the minimal form of our <tt class="rst-docutils literal">Point</tt> class:</p>
<pre class="rst-literal-block">
class Point(MutableComposite):
    # ...

    def __getstate__(self):
        return self.x, self.y

    def __setstate__(self, state):
        self.x, self.y = state
</pre>
<p>As with <code>.Mutable</code>, the <code>.MutableComposite</code> augments the
pickling process of the parent's object-relational state so that the
<code><a href="sqlalchemy.ext.mutable.MutableBase.html#_parents" class="internal-link" title="sqlalchemy.ext.mutable.MutableBase._parents">MutableBase._parents</a></code> collection is restored to all <tt class="rst-docutils literal">Point</tt> objects.</p>
</div>
</div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id16621">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.mutable.Mutable.html" class="internal-link" title="sqlalchemy.ext.mutable.Mutable">​Mutable</a></code></td>
    <td>Mixin that defines transparent propagation of change events to a parent object.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.mutable.MutableBase.html" class="internal-link" title="sqlalchemy.ext.mutable.MutableBase">​Mutable​Base</a></code></td>
    <td>Common base class to <code>.Mutable</code> and <code>.MutableComposite</code>.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.mutable.MutableComposite.html" class="internal-link" title="sqlalchemy.ext.mutable.MutableComposite">​Mutable​Composite</a></code></td>
    <td>Mixin that defines transparent propagation of change events on a SQLAlchemy "composite" object to its owning parent or parents.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.mutable.MutableDict.html" class="internal-link" title="sqlalchemy.ext.mutable.MutableDict">​Mutable​Dict</a></code></td>
    <td>A dictionary type that implements <code>.Mutable</code>.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.mutable.MutableList.html" class="internal-link" title="sqlalchemy.ext.mutable.MutableList">​Mutable​List</a></code></td>
    <td>A list type that implements <code>.Mutable</code>.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.mutable.MutableSet.html" class="internal-link" title="sqlalchemy.ext.mutable.MutableSet">​Mutable​Set</a></code></td>
    <td>A set type that implements <code>.Mutable</code>.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_setup_composite_listener" class="internal-link" title="sqlalchemy.ext.mutable._setup_composite_listener">​_setup​_composite​_listener</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basefunction private">
  
  
  <a name="sqlalchemy.ext.mutable._setup_composite_listener">
    
  </a>
  <a name="_setup_composite_listener">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_setup_composite_listener</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 04:41:59.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>