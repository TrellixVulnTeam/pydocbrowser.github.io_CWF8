<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.sql.operators.ColumnOperators</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.sql.html" class="internal-link" title="sqlalchemy.sql">sql</a></code><wbr></wbr>.<code><a href="sqlalchemy.sql.operators.html" class="internal-link" title="sqlalchemy.sql.operators">operators</a></code><wbr></wbr>.<code><a href="sqlalchemy.sql.operators.ColumnOperators.html" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators">ColumnOperators</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> <span class="py-defname">ColumnOperators</span>(<a href="sqlalchemy.sql.operators.Operators.html" class="internal-link" title="sqlalchemy.sql.operators.Operators">Operators</a>):</code></p><p>Known subclasses: <code><a href="sqlalchemy.ext.associationproxy.ColumnAssociationProxyInstance.html" class="internal-link">sqlalchemy.ext.associationproxy.ColumnAssociationProxyInstance</a></code>, <code><a href="sqlalchemy.orm.interfaces.PropComparator.html" class="internal-link">sqlalchemy.orm.interfaces.PropComparator</a></code>, <code><a href="sqlalchemy.sql.expression.ColumnElement.html" class="internal-link">sqlalchemy.sql.expression.ColumnElement</a></code>, <code><a href="sqlalchemy.sql.lambdas.PyWrapper.html" class="internal-link">sqlalchemy.sql.lambdas.PyWrapper</a></code>, <code><a href="sqlalchemy.types.TypeEngine.Comparator.html" class="internal-link">sqlalchemy.types.TypeEngine.Comparator</a></code>, <code><a href="sqlalchemy.orm.evaluator._NoObject.html" class="internal-link">sqlalchemy.orm.evaluator._NoObject</a></code></p>
        <p><a href="classIndex.html#sqlalchemy.sql.operators.ColumnOperators">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p>Defines boolean, comparison, and other operators for
<code>_expression.ColumnElement</code> expressions.</p>
<p>By default, all methods call down to
<code>.operate</code> or <code>.reverse_operate</code>,
passing in the appropriate operator function from the
Python builtin <tt class="rst-docutils literal">operator</tt> module or
a SQLAlchemy-specific operator function from
<code>sqlalchemy.expression.operators</code>.   For example
the <tt class="rst-docutils literal">__eq__</tt> function:</p>
<pre class="rst-literal-block">
def __eq__(self, other):
    return self.operate(operators.eq, other)
</pre>
<p>Where <tt class="rst-docutils literal">operators.eq</tt> is essentially:</p>
<pre class="rst-literal-block">
def eq(a, b):
    return a == b
</pre>
<p>The core column expression unit <code>_expression.ColumnElement</code>
overrides <code>.Operators.operate</code> and others
to return further <code>_expression.ColumnElement</code> constructs,
so that the <tt class="rst-docutils literal">==</tt> operation above is replaced by a clause
construct.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`types_operators`</span></a></p>
<p><code>.TypeEngine.comparator_factory</code></p>
<p><code>.ColumnOperators</code></p>
<p class="rst-last"><code>.PropComparator</code></p>
</div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id20005">
  
  
  <tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__add__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__add__">__add__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">+</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__contains__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__contains__">__contains__</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__div__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__div__">__div__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">/</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__eq__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__eq__">__eq__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">==</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__ge__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__ge__">__ge__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">&gt;=</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__getitem__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__getitem__">__getitem__</a></code></td>
    <td>Implement the [] operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__gt__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__gt__">__gt__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">&gt;</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__le__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__le__">__le__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">&lt;=</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__lshift__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__lshift__">__lshift__</a></code></td>
    <td>implement the &lt;&lt; operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__lt__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__lt__">__lt__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">&lt;</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__mod__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__mod__">__mod__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">%</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__mul__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__mul__">__mul__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">*</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__ne__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__ne__">__ne__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">!=</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__neg__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__neg__">__neg__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">-</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__radd__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__radd__">__radd__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">+</tt> operator in reverse.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__rdiv__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__rdiv__">__rdiv__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">/</tt> operator in reverse.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__rmod__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__rmod__">__rmod__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">%</tt> operator in reverse.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__rmul__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__rmul__">__rmul__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">*</tt> operator in reverse.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__rshift__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__rshift__">__rshift__</a></code></td>
    <td>implement the &gt;&gt; operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__rsub__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__rsub__">__rsub__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">-</tt> operator in reverse.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__rtruediv__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__rtruediv__">__rtruediv__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">//</tt> operator in reverse.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__sub__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__sub__">__sub__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">-</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__truediv__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__truediv__">__truediv__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">//</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#all_" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.all_">all​_</a></code></td>
    <td>Produce an <code>_expression.all_</code> clause against the parent object.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#any_" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.any_">any​_</a></code></td>
    <td>Produce an <code>_expression.any_</code> clause against the parent object.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#asc" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.asc">asc</a></code></td>
    <td>Produce a <code>_expression.asc</code> clause against the parent object.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#between" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.between">between</a></code></td>
    <td>Produce a <code>_expression.between</code> clause against the parent object, given the lower and upper range.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#collate" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.collate">collate</a></code></td>
    <td>Produce a <code>_expression.collate</code> clause against the parent object, given the collation string.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#concat" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.concat">concat</a></code></td>
    <td>Implement the 'concat' operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#contains" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.contains">contains</a></code></td>
    <td>Implement the 'contains' operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#desc" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.desc">desc</a></code></td>
    <td>Produce a <code>_expression.desc</code> clause against the parent object.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#distinct" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.distinct">distinct</a></code></td>
    <td>Produce a <code>_expression.distinct</code> clause against the parent object.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#endswith" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.endswith">endswith</a></code></td>
    <td>Implement the 'endswith' operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#ilike" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.ilike">ilike</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">ilike</tt> operator, e.g. case insensitive LIKE.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#in_" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.in_">in​_</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">in</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.is_">is​_</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">IS</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_distinct_from" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.is_distinct_from">is​_distinct​_from</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">IS DISTINCT FROM</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_not" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.is_not">is​_not</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">IS NOT</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_not_distinct_from" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.is_not_distinct_from">is​_not​_distinct​_from</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">IS NOT DISTINCT FROM</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#like" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.like">like</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">like</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#match" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.match">match</a></code></td>
    <td>Implements a database-specific 'match' operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#not_ilike" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.not_ilike">not​_ilike</a></code></td>
    <td>implement the <tt class="rst-docutils literal">NOT ILIKE</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#not_in" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.not_in">not​_in</a></code></td>
    <td>implement the <tt class="rst-docutils literal">NOT IN</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#not_like" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.not_like">not​_like</a></code></td>
    <td>implement the <tt class="rst-docutils literal">NOT LIKE</tt> operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#nulls_first" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.nulls_first">nulls​_first</a></code></td>
    <td>Produce a <code>_expression.nulls_first</code> clause against the parent object.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#nulls_last" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.nulls_last">nulls​_last</a></code></td>
    <td>Produce a <code>_expression.nulls_last</code> clause against the parent object.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#regexp_match" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.regexp_match">regexp​_match</a></code></td>
    <td>Implements a database-specific 'regexp match' operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#regexp_replace" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.regexp_replace">regexp​_replace</a></code></td>
    <td>Implements a database-specific 'regexp replace' operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#startswith" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.startswith">startswith</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">startswith</tt> operator.</td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><code><a href="#__slots__" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.__slots__">__slots__</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><code><a href="#timetuple" class="internal-link" title="sqlalchemy.sql.operators.ColumnOperators.timetuple">timetuple</a></code></td>
    <td>Hack, allows datetime objects to be compared on the LHS.</td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <code><a href="sqlalchemy.sql.operators.Operators.html" class="internal-link" title="sqlalchemy.sql.operators.Operators">Operators</a></code>:
          </p>
          <table class="children sortable" id="id20006">
  
  
  <tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="sqlalchemy.sql.operators.Operators.html#__and__" class="internal-link" title="sqlalchemy.sql.operators.Operators.__and__">__and__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">&amp;</tt> operator.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="sqlalchemy.sql.operators.Operators.html#__invert__" class="internal-link" title="sqlalchemy.sql.operators.Operators.__invert__">__invert__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">~</tt> operator.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="sqlalchemy.sql.operators.Operators.html#__or__" class="internal-link" title="sqlalchemy.sql.operators.Operators.__or__">__or__</a></code></td>
    <td>Implement the <tt class="rst-docutils literal">|</tt> operator.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="sqlalchemy.sql.operators.Operators.html#bool_op" class="internal-link" title="sqlalchemy.sql.operators.Operators.bool_op">bool​_op</a></code></td>
    <td>Return a custom boolean operator.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="sqlalchemy.sql.operators.Operators.html#op" class="internal-link" title="sqlalchemy.sql.operators.Operators.op">op</a></code></td>
    <td>Produce a generic operator function.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="sqlalchemy.sql.operators.Operators.html#operate" class="internal-link" title="sqlalchemy.sql.operators.Operators.operate">operate</a></code></td>
    <td>Operate on an argument.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="sqlalchemy.sql.operators.Operators.html#reverse_operate" class="internal-link" title="sqlalchemy.sql.operators.Operators.reverse_operate">reverse​_operate</a></code></td>
    <td>Reverse operate on an argument.</td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__add__">
    
  </a>
  <a name="__add__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__add__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="sqlalchemy.dialects.postgresql.ranges.RangeOperators.comparator_factory.html" class="internal-link">sqlalchemy.dialects.postgresql.ranges.RangeOperators.comparator_factory</a></code></div>
    
    <div><p>Implement the <tt class="rst-docutils literal">+</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a + b</tt>
if the parent object has non-string affinity.
If the parent object has a string affinity,
produces the concatenation operator, <tt class="rst-docutils literal">a || b</tt> -
see <code>.ColumnOperators.concat</code>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__contains__">
    
  </a>
  <a name="__contains__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__contains__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__div__">
    
  </a>
  <a name="__div__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__div__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">/</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a / b</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__eq__">
    
  </a>
  <a name="__eq__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__eq__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="sqlalchemy.ext.associationproxy.ColumnAssociationProxyInstance.html" class="internal-link">sqlalchemy.ext.associationproxy.ColumnAssociationProxyInstance</a></code>, <code><a href="sqlalchemy.orm.properties.CompositeProperty.Comparator.html" class="internal-link">sqlalchemy.orm.properties.CompositeProperty.Comparator</a></code>, <code><a href="sqlalchemy.orm.properties.RelationshipProperty.Comparator.html" class="internal-link">sqlalchemy.orm.properties.RelationshipProperty.Comparator</a></code>, <code><a href="sqlalchemy.sql.crud._multiparam_column.html" class="internal-link">sqlalchemy.sql.crud._multiparam_column</a></code></div>
    
    <div><p>Implement the <tt class="rst-docutils literal">==</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a = b</tt>.
If the target is <tt class="rst-docutils literal">None</tt>, produces <tt class="rst-docutils literal">a IS NULL</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__ge__">
    
  </a>
  <a name="__ge__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__ge__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">&gt;=</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a &gt;= b</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__getitem__">
    
  </a>
  <a name="__getitem__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__getitem__</span>(self, index):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="sqlalchemy.sql.lambdas.PyWrapper.html" class="internal-link">sqlalchemy.sql.lambdas.PyWrapper</a></code>, <code><a href="sqlalchemy.types.Indexable.Comparator.html" class="internal-link">sqlalchemy.types.Indexable.Comparator</a></code></div>
    
    <div><p>Implement the [] operator.</p>
<p>This can be used by some database-specific types
such as PostgreSQL ARRAY and HSTORE.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__gt__">
    
  </a>
  <a name="__gt__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__gt__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">&gt;</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a &gt; b</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__le__">
    
  </a>
  <a name="__le__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__le__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">&lt;=</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a &lt;= b</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__lshift__">
    
  </a>
  <a name="__lshift__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__lshift__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>implement the &lt;&lt; operator.</p>
<p>Not used by SQLAlchemy core, this is provided
for custom operator systems which want to use
&lt;&lt; as an extension point.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__lt__">
    
  </a>
  <a name="__lt__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__lt__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">&lt;</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a &lt; b</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__mod__">
    
  </a>
  <a name="__mod__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__mod__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">%</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a % b</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__mul__">
    
  </a>
  <a name="__mul__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__mul__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">*</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a * b</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__ne__">
    
  </a>
  <a name="__ne__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__ne__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="sqlalchemy.dialects.postgresql.ranges.RangeOperators.comparator_factory.html" class="internal-link">sqlalchemy.dialects.postgresql.ranges.RangeOperators.comparator_factory</a></code>, <code><a href="sqlalchemy.orm.properties.CompositeProperty.Comparator.html" class="internal-link">sqlalchemy.orm.properties.CompositeProperty.Comparator</a></code>, <code><a href="sqlalchemy.orm.properties.RelationshipProperty.Comparator.html" class="internal-link">sqlalchemy.orm.properties.RelationshipProperty.Comparator</a></code></div>
    
    <div><p>Implement the <tt class="rst-docutils literal">!=</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a != b</tt>.
If the target is <tt class="rst-docutils literal">None</tt>, produces <tt class="rst-docutils literal">a IS NOT NULL</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__neg__">
    
  </a>
  <a name="__neg__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__neg__</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">-</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal"><span class="pre">-a</span></tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__radd__">
    
  </a>
  <a name="__radd__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__radd__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">+</tt> operator in reverse.</p>
<p>See <code>.ColumnOperators.__add__</code>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__rdiv__">
    
  </a>
  <a name="__rdiv__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__rdiv__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">/</tt> operator in reverse.</p>
<p>See <code>.ColumnOperators.__div__</code>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__rmod__">
    
  </a>
  <a name="__rmod__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__rmod__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">%</tt> operator in reverse.</p>
<p>See <code>.ColumnOperators.__mod__</code>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__rmul__">
    
  </a>
  <a name="__rmul__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__rmul__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">*</tt> operator in reverse.</p>
<p>See <code>.ColumnOperators.__mul__</code>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__rshift__">
    
  </a>
  <a name="__rshift__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__rshift__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>implement the &gt;&gt; operator.</p>
<p>Not used by SQLAlchemy core, this is provided
for custom operator systems which want to use
&gt;&gt; as an extension point.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__rsub__">
    
  </a>
  <a name="__rsub__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__rsub__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">-</tt> operator in reverse.</p>
<p>See <code>.ColumnOperators.__sub__</code>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__rtruediv__">
    
  </a>
  <a name="__rtruediv__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__rtruediv__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">//</tt> operator in reverse.</p>
<p>See <code>.ColumnOperators.__truediv__</code>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__sub__">
    
  </a>
  <a name="__sub__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__sub__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">-</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a - b</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__truediv__">
    
  </a>
  <a name="__truediv__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__truediv__</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">//</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a / b</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.all_">
    
  </a>
  <a name="all_">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">all_</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Produce an <code>_expression.all_</code> clause against the
parent object.</p>
<p>See the documentation for <code>_sql.all_</code> for examples.</p>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p class="rst-last">be sure to not confuse the newer
<code>_sql.ColumnOperators.all_</code> method with its older
<code>_types.ARRAY</code>-specific counterpart, the
<code>_types.ARRAY.Comparator.all</code> method, which a different
calling syntax and usage pattern.</p>
</div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.1.</span></div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.any_">
    
  </a>
  <a name="any_">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">any_</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Produce an <code>_expression.any_</code> clause against the
parent object.</p>
<p>See the documentation for <code>_sql.any_</code> for examples.</p>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p class="rst-last">be sure to not confuse the newer
<code>_sql.ColumnOperators.any_</code> method with its older
<code>_types.ARRAY</code>-specific counterpart, the
<code>_types.ARRAY.Comparator.any</code> method, which a different
calling syntax and usage pattern.</p>
</div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.1.</span></div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.asc">
    
  </a>
  <a name="asc">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">asc</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Produce a <code>_expression.asc</code> clause against the
parent object.</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.between">
    
  </a>
  <a name="between">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">between</span>(self, cleft, cright, symmetric=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Produce a <code>_expression.between</code> clause against
the parent object, given the lower and upper range.</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.collate">
    
  </a>
  <a name="collate">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">collate</span>(self, collation):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Produce a <code>_expression.collate</code> clause against
the parent object, given the collation string.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_expression.collate</code></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.concat">
    
  </a>
  <a name="concat">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">concat</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the 'concat' operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">a || b</tt>,
or uses the <tt class="rst-docutils literal">concat()</tt> operator on MySQL.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.contains">
    
  </a>
  <a name="contains">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">contains</span>(self, other, **kwargs):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="sqlalchemy.dialects.postgresql.hstore.HSTORE.Comparator.html" class="internal-link">sqlalchemy.dialects.postgresql.hstore.HSTORE.Comparator</a></code>, <code><a href="sqlalchemy.dialects.postgresql.hstore.HSTORE.Comparator.html" class="internal-link">sqlalchemy.dialects.postgresql.hstore.HSTORE.Comparator</a></code>, <code><a href="sqlalchemy.dialects.postgresql.json.JSONB.Comparator.html" class="internal-link">sqlalchemy.dialects.postgresql.json.JSONB.Comparator</a></code>, <code><a href="sqlalchemy.dialects.postgresql.json.JSONB.Comparator.html" class="internal-link">sqlalchemy.dialects.postgresql.json.JSONB.Comparator</a></code>, <code><a href="sqlalchemy.dialects.postgresql.ranges.RangeOperators.comparator_factory.html" class="internal-link">sqlalchemy.dialects.postgresql.ranges.RangeOperators.comparator_factory</a></code>, <code><a href="sqlalchemy.orm.properties.RelationshipProperty.Comparator.html" class="internal-link">sqlalchemy.orm.properties.RelationshipProperty.Comparator</a></code>, <code><a href="sqlalchemy.types.ARRAY.Comparator.html" class="internal-link">sqlalchemy.types.ARRAY.Comparator</a></code>, <code><a href="sqlalchemy.types.ARRAY.Comparator.html" class="internal-link">sqlalchemy.types.ARRAY.Comparator</a></code></div>
    
    <div><p>Implement the 'contains' operator.</p>
<p>Produces a LIKE expression that tests against a match for the middle
of a string value:</p>
<pre class="rst-literal-block">
column LIKE '%' || &lt;other&gt; || '%'
</pre>
<p>E.g.:</p>
<pre class="rst-literal-block">
stmt = select(sometable).\
    where(sometable.c.column.contains("foobar"))
</pre>
<p>Since the operator uses <tt class="rst-docutils literal">LIKE</tt>, wildcard characters
<tt class="rst-docutils literal">"%"</tt> and <tt class="rst-docutils literal">"_"</tt> that are present inside the &lt;other&gt; expression
will behave like wildcards as well.   For literal string
values, the <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`.ColumnOperators.contains.autoescape`</span></a> flag
may be set to <tt class="rst-docutils literal">True</tt> to apply escaping to occurrences of these
characters within the string value so that they match as themselves
and not as wildcard characters.  Alternatively, the
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`.ColumnOperators.contains.escape`</span></a> parameter will establish
a given character as an escape character which can be of use when
the target expression is not a literal string.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><code>.ColumnOperators.startswith</code></p>
<p><code>.ColumnOperators.endswith</code></p>
<p class="rst-last"><code>.ColumnOperators.like</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">expression to be compared.   This is usually a plain
string value, but can also be an arbitrary SQL expression.  LIKE
wildcard characters <tt class="rst-docutils literal">%</tt> and <tt class="rst-docutils literal">_</tt> are not escaped by default unless
the <a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:paramref:`.ColumnOperators.contains.autoescape`</span></a> flag is
set to True.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwargs</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">autoescape</span></td><td class="fieldArgDesc"><p>boolean; when True, establishes an escape character
within the LIKE expression, then applies it to all occurrences of
<tt class="rst-docutils literal">"%"</tt>, <tt class="rst-docutils literal">"_"</tt> and the escape character itself within the
comparison value, which is assumed to be a literal string and not a
SQL expression.</p>
<p>An expression such as:</p>
<pre class="rst-literal-block">
somecolumn.contains("foo%bar", autoescape=True)
</pre>
<p>Will render as:</p>
<pre class="rst-literal-block">
somecolumn LIKE '%' || :param || '%' ESCAPE '/'
</pre>
<p>With the value of <tt class="rst-docutils literal">:param</tt> as <tt class="rst-docutils literal"><span class="pre">"foo/%bar"</span></tt>.</p>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">escape</span></td><td class="fieldArgDesc"><p>a character which when given will render with the
<tt class="rst-docutils literal">ESCAPE</tt> keyword to establish that character as the escape
character.  This character can then be placed preceding occurrences
of <tt class="rst-docutils literal">%</tt> and <tt class="rst-docutils literal">_</tt> to allow them to act as themselves and not
wildcard characters.</p>
<p>An expression such as:</p>
<pre class="rst-literal-block">
somecolumn.contains("foo/%bar", escape="^")
</pre>
<p>Will render as:</p>
<pre class="rst-literal-block">
somecolumn LIKE '%' || :param || '%' ESCAPE '^'
</pre>
<p>The parameter may also be combined with
<a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:paramref:`.ColumnOperators.contains.autoescape`</span></a>:</p>
<pre class="rst-literal-block">
somecolumn.contains("foo%bar^bat", escape="^", autoescape=True)
</pre>
<p>Where above, the given literal parameter will be converted to
<tt class="rst-docutils literal"><span class="pre">"foo^%bar^^bat"</span></tt> before being passed to the database.</p>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.desc">
    
  </a>
  <a name="desc">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">desc</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Produce a <code>_expression.desc</code> clause against the
parent object.</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.distinct">
    
  </a>
  <a name="distinct">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">distinct</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Produce a <code>_expression.distinct</code> clause against the
parent object.</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.endswith">
    
  </a>
  <a name="endswith">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">endswith</span>(self, other, **kwargs):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the 'endswith' operator.</p>
<p>Produces a LIKE expression that tests against a match for the end
of a string value:</p>
<pre class="rst-literal-block">
column LIKE '%' || &lt;other&gt;
</pre>
<p>E.g.:</p>
<pre class="rst-literal-block">
stmt = select(sometable).\
    where(sometable.c.column.endswith("foobar"))
</pre>
<p>Since the operator uses <tt class="rst-docutils literal">LIKE</tt>, wildcard characters
<tt class="rst-docutils literal">"%"</tt> and <tt class="rst-docutils literal">"_"</tt> that are present inside the &lt;other&gt; expression
will behave like wildcards as well.   For literal string
values, the <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`.ColumnOperators.endswith.autoescape`</span></a> flag
may be set to <tt class="rst-docutils literal">True</tt> to apply escaping to occurrences of these
characters within the string value so that they match as themselves
and not as wildcard characters.  Alternatively, the
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`.ColumnOperators.endswith.escape`</span></a> parameter will establish
a given character as an escape character which can be of use when
the target expression is not a literal string.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><code>.ColumnOperators.startswith</code></p>
<p><code>.ColumnOperators.contains</code></p>
<p class="rst-last"><code>.ColumnOperators.like</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">expression to be compared.   This is usually a plain
string value, but can also be an arbitrary SQL expression.  LIKE
wildcard characters <tt class="rst-docutils literal">%</tt> and <tt class="rst-docutils literal">_</tt> are not escaped by default unless
the <a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:paramref:`.ColumnOperators.endswith.autoescape`</span></a> flag is
set to True.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwargs</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">autoescape</span></td><td class="fieldArgDesc"><p>boolean; when True, establishes an escape character
within the LIKE expression, then applies it to all occurrences of
<tt class="rst-docutils literal">"%"</tt>, <tt class="rst-docutils literal">"_"</tt> and the escape character itself within the
comparison value, which is assumed to be a literal string and not a
SQL expression.</p>
<p>An expression such as:</p>
<pre class="rst-literal-block">
somecolumn.endswith("foo%bar", autoescape=True)
</pre>
<p>Will render as:</p>
<pre class="rst-literal-block">
somecolumn LIKE '%' || :param ESCAPE '/'
</pre>
<p>With the value of <tt class="rst-docutils literal">:param</tt> as <tt class="rst-docutils literal"><span class="pre">"foo/%bar"</span></tt>.</p>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">escape</span></td><td class="fieldArgDesc"><p>a character which when given will render with the
<tt class="rst-docutils literal">ESCAPE</tt> keyword to establish that character as the escape
character.  This character can then be placed preceding occurrences
of <tt class="rst-docutils literal">%</tt> and <tt class="rst-docutils literal">_</tt> to allow them to act as themselves and not
wildcard characters.</p>
<p>An expression such as:</p>
<pre class="rst-literal-block">
somecolumn.endswith("foo/%bar", escape="^")
</pre>
<p>Will render as:</p>
<pre class="rst-literal-block">
somecolumn LIKE '%' || :param ESCAPE '^'
</pre>
<p>The parameter may also be combined with
<a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:paramref:`.ColumnOperators.endswith.autoescape`</span></a>:</p>
<pre class="rst-literal-block">
somecolumn.endswith("foo%bar^bat", escape="^", autoescape=True)
</pre>
<p>Where above, the given literal parameter will be converted to
<tt class="rst-docutils literal"><span class="pre">"foo^%bar^^bat"</span></tt> before being passed to the database.</p>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.ilike">
    
  </a>
  <a name="ilike">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">ilike</span>(self, other, escape=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">ilike</tt> operator, e.g. case insensitive LIKE.</p>
<p>In a column context, produces an expression either of the form:</p>
<pre class="rst-literal-block">
lower(a) LIKE lower(other)
</pre>
<p>Or on backends that support the ILIKE operator:</p>
<pre class="rst-literal-block">
a ILIKE other
</pre>
<p>E.g.:</p>
<pre class="rst-literal-block">
stmt = select(sometable).\
    where(sometable.c.column.ilike("%foobar%"))
</pre>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>.ColumnOperators.like</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">expression to be compared</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">escape</span></td><td class="fieldArgDesc"><p>optional escape character, renders the <tt class="rst-docutils literal">ESCAPE</tt>
keyword, e.g.:</p>
<pre class="rst-literal-block">
somecolumn.ilike("foo/%bar", escape="/")
</pre>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.in_">
    
  </a>
  <a name="in_">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">in_</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="sqlalchemy.orm.properties.RelationshipProperty.Comparator.html" class="internal-link">sqlalchemy.orm.properties.RelationshipProperty.Comparator</a></code></div>
    
    <div><p>Implement the <tt class="rst-docutils literal">in</tt> operator.</p>
<p>In a column context, produces the clause <tt class="rst-docutils literal">column IN &lt;other&gt;</tt>.</p>
<p>The given parameter <tt class="rst-docutils literal">other</tt> may be:</p>
<ul>
<li><p class="rst-first">A list of literal values, e.g.:</p>
<pre class="rst-literal-block">
stmt.where(column.in_([1, 2, 3]))
</pre>
<p>In this calling form, the list of items is converted to a set of
bound parameters the same length as the list given:</p>
<pre class="rst-literal-block">
WHERE COL IN (?, ?, ?)
</pre>
</li>
<li><p class="rst-first">A list of tuples may be provided if the comparison is against a
<code>.tuple_</code> containing multiple expressions:</p>
<pre class="rst-literal-block">
from sqlalchemy import tuple_
stmt.where(tuple_(col1, col2).in_([(1, 10), (2, 20), (3, 30)]))
</pre>
</li>
<li><p class="rst-first">An empty list, e.g.:</p>
<pre class="rst-literal-block">
stmt.where(column.in_([]))
</pre>
<p>In this calling form, the expression renders an "empty set"
expression.  These expressions are tailored to individual backends
and are generally trying to get an empty SELECT statement as a
subquery.  Such as on SQLite, the expression is:</p>
<pre class="rst-literal-block">
WHERE col IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)
</pre>
<div class="rst-versionchanged">
<p><span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>empty IN expressions now use an
execution-time generated SELECT subquery in all cases.</span></p>
</div>
</li>
<li><p class="rst-first">A bound parameter, e.g. <code>.bindparam</code>, may be used if it
includes the <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`.bindparam.expanding`</span></a> flag:</p>
<pre class="rst-literal-block">
stmt.where(column.in_(bindparam('value', expanding=True)))
</pre>
<p>In this calling form, the expression renders a special non-SQL
placeholder expression that looks like:</p>
<pre class="rst-literal-block">
WHERE COL IN ([EXPANDING_value])
</pre>
<p>This placeholder expression is intercepted at statement execution
time to be converted into the variable number of bound parameter
form illustrated earlier.   If the statement were executed as:</p>
<pre class="rst-literal-block">
connection.execute(stmt, {"value": [1, 2, 3]})
</pre>
<p>The database would be passed a bound parameter for each value:</p>
<pre class="rst-literal-block">
WHERE COL IN (?, ?, ?)
</pre>
<div class="rst-versionadded">
<p><span class="rst-versionmodified rst-added">New in version 1.2: </span><span>added "expanding" bound parameters</span></p>
</div>
<p>If an empty list is passed, a special "empty list" expression,
which is specific to the database in use, is rendered.  On
SQLite this would be:</p>
<pre class="rst-literal-block">
WHERE COL IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)
</pre>
<div class="rst-versionadded">
<p><span class="rst-versionmodified rst-added">New in version 1.3: </span><span>"expanding" bound parameters now support
empty lists</span></p>
</div>
</li>
<li><p class="rst-first">a <code>_expression.select</code> construct, which is usually a
correlated scalar select:</p>
<pre class="rst-literal-block">
stmt.where(
    column.in_(
        select(othertable.c.y).
        where(table.c.x == othertable.c.x)
    )
)
</pre>
<p>In this calling form, <code>.ColumnOperators.in_</code> renders as given:</p>
<pre class="rst-literal-block">
WHERE COL IN (SELECT othertable.y
FROM othertable WHERE othertable.x = table.x)
</pre>
</li>
</ul>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">a list of literals, a <code>_expression.select</code>
construct, or a <code>.bindparam</code> construct that includes the
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`.bindparam.expanding`</span></a> flag set to True.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.is_">
    
  </a>
  <a name="is_">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">IS</tt> operator.</p>
<p>Normally, <tt class="rst-docutils literal">IS</tt> is generated automatically when comparing to a
value of <tt class="rst-docutils literal">None</tt>, which resolves to <tt class="rst-docutils literal">NULL</tt>.  However, explicit
usage of <tt class="rst-docutils literal">IS</tt> may be desirable if comparing to boolean values
on certain platforms.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>.ColumnOperators.is_not</code></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.is_distinct_from">
    
  </a>
  <a name="is_distinct_from">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_distinct_from</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">IS DISTINCT FROM</tt> operator.</p>
<p>Renders "a IS DISTINCT FROM b" on most platforms;
on some such as SQLite may render "a IS NOT b".</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.1.</span></div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.is_not">
    
  </a>
  <a name="is_not">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_not</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">IS NOT</tt> operator.</p>
<p>Normally, <tt class="rst-docutils literal">IS NOT</tt> is generated automatically when comparing to a
value of <tt class="rst-docutils literal">None</tt>, which resolves to <tt class="rst-docutils literal">NULL</tt>.  However, explicit
usage of <tt class="rst-docutils literal">IS NOT</tt> may be desirable if comparing to boolean values
on certain platforms.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>The <tt class="rst-docutils literal">is_not()</tt> operator is renamed from
<tt class="rst-docutils literal">isnot()</tt> in previous releases.  The previous name remains
available for backwards compatibility.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>.ColumnOperators.is_</code></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.is_not_distinct_from">
    
  </a>
  <a name="is_not_distinct_from">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_not_distinct_from</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">IS NOT DISTINCT FROM</tt> operator.</p>
<p>Renders "a IS NOT DISTINCT FROM b" on most platforms;
on some such as SQLite may render "a IS b".</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>The <tt class="rst-docutils literal">is_not_distinct_from()</tt> operator is
renamed from <tt class="rst-docutils literal">isnot_distinct_from()</tt> in previous releases.
The previous name remains available for backwards compatibility.</span></div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.1.</span></div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.like">
    
  </a>
  <a name="like">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">like</span>(self, other, escape=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">like</tt> operator.</p>
<p>In a column context, produces the expression:</p>
<pre class="rst-literal-block">
a LIKE other
</pre>
<p>E.g.:</p>
<pre class="rst-literal-block">
stmt = select(sometable).\
    where(sometable.c.column.like("%foobar%"))
</pre>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>.ColumnOperators.ilike</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">expression to be compared</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">escape</span></td><td class="fieldArgDesc"><p>optional escape character, renders the <tt class="rst-docutils literal">ESCAPE</tt>
keyword, e.g.:</p>
<pre class="rst-literal-block">
somecolumn.like("foo/%bar", escape="/")
</pre>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.match">
    
  </a>
  <a name="match">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">match</span>(self, other, **kwargs):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implements a database-specific 'match' operator.</p>
<p><code>_sql.ColumnOperators.match</code> attempts to resolve to
a MATCH-like function or operator provided by the backend.
Examples include:</p>
<ul>
<li><p class="rst-first">PostgreSQL - renders <tt class="rst-docutils literal">x @@ to_tsquery(y)</tt></p>
</li>
<li><p class="rst-first">MySQL - renders <tt class="rst-docutils literal">MATCH (x) AGAINST (y IN BOOLEAN MODE)</tt></p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_mysql.match</code> - MySQL specific construct with
additional features.</p>
</div>
</li>
<li><p class="rst-first">Oracle - renders <tt class="rst-docutils literal">CONTAINS(x, y)</tt></p>
</li>
<li><p class="rst-first">other backends may provide special implementations.</p>
</li>
<li><p class="rst-first">Backends without any special implementation will emit
the operator as "MATCH".  This is compatible with SQLite, for
example.</p>
</li>
</ul>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.not_ilike">
    
  </a>
  <a name="not_ilike">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">not_ilike</span>(self, other, escape=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>implement the <tt class="rst-docutils literal">NOT ILIKE</tt> operator.</p>
<p>This is equivalent to using negation with
<code>.ColumnOperators.ilike</code>, i.e. <tt class="rst-docutils literal">~x.ilike(y)</tt>.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>The <tt class="rst-docutils literal">not_ilike()</tt> operator is renamed from
<tt class="rst-docutils literal">notilike()</tt> in previous releases.  The previous name remains
available for backwards compatibility.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>.ColumnOperators.ilike</code></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.not_in">
    
  </a>
  <a name="not_in">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">not_in</span>(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>implement the <tt class="rst-docutils literal">NOT IN</tt> operator.</p>
<p>This is equivalent to using negation with
<code>.ColumnOperators.in_</code>, i.e. <tt class="rst-docutils literal">~x.in_(y)</tt>.</p>
<p>In the case that <tt class="rst-docutils literal">other</tt> is an empty sequence, the compiler
produces an "empty not in" expression.   This defaults to the
expression "1 = 1" to produce true in all cases.  The
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`_sa.create_engine.empty_in_strategy`</span></a> may be used to
alter this behavior.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>The <tt class="rst-docutils literal">not_in()</tt> operator is renamed from
<tt class="rst-docutils literal">notin_()</tt> in previous releases.  The previous name remains
available for backwards compatibility.</span></div>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.2: </span><span>The <code>.ColumnOperators.in_</code> and
<code>.ColumnOperators.not_in</code> operators
now produce a "static" expression for an empty IN sequence
by default.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>.ColumnOperators.in_</code></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.not_like">
    
  </a>
  <a name="not_like">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">not_like</span>(self, other, escape=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>implement the <tt class="rst-docutils literal">NOT LIKE</tt> operator.</p>
<p>This is equivalent to using negation with
<code>.ColumnOperators.like</code>, i.e. <tt class="rst-docutils literal">~x.like(y)</tt>.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>The <tt class="rst-docutils literal">not_like()</tt> operator is renamed from
<tt class="rst-docutils literal">notlike()</tt> in previous releases.  The previous name remains
available for backwards compatibility.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>.ColumnOperators.like</code></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.nulls_first">
    
  </a>
  <a name="nulls_first">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">nulls_first</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Produce a <code>_expression.nulls_first</code> clause against the
parent object.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>The <tt class="rst-docutils literal">nulls_first()</tt> operator is
renamed from <tt class="rst-docutils literal">nullsfirst()</tt> in previous releases.
The previous name remains available for backwards compatibility.</span></div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.nulls_last">
    
  </a>
  <a name="nulls_last">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">nulls_last</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Produce a <code>_expression.nulls_last</code> clause against the
parent object.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>The <tt class="rst-docutils literal">nulls_last()</tt> operator is
renamed from <tt class="rst-docutils literal">nullslast()</tt> in previous releases.
The previous name remains available for backwards compatibility.</span></div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.regexp_match">
    
  </a>
  <a name="regexp_match">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">regexp_match</span>(self, pattern, flags=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implements a database-specific 'regexp match' operator.</p>
<p>E.g.:</p>
<pre class="rst-literal-block">
stmt = select(table.c.some_column).where(
    table.c.some_column.regexp_match('^(b|c)')
)
</pre>
<p><code>_sql.ColumnOperators.regexp_match</code> attempts to resolve to
a REGEXP-like function or operator provided by the backend, however
the specific regular expression syntax and flags available are
<strong>not backend agnostic</strong>.</p>
<p>Examples include:</p>
<ul class="rst-simple">
<li>PostgreSQL - renders <tt class="rst-docutils literal">x ~ y</tt> or <tt class="rst-docutils literal">x !~ y</tt> when negated.</li>
<li>Oracle - renders <tt class="rst-docutils literal">REGEXP_LIKE(x, y)</tt></li>
<li>SQLite - uses SQLite's <tt class="rst-docutils literal">REGEXP</tt> placeholder operator and calls into
the Python <tt class="rst-docutils literal">re.match()</tt> builtin.</li>
<li>other backends may provide special implementations.</li>
<li>Backends without any special implementation will emit
the operator as "REGEXP" or "NOT REGEXP".  This is compatible with
SQLite and MySQL, for example.</li>
</ul>
<p>Regular expression support is currently implemented for Oracle,
PostgreSQL, MySQL and MariaDB.  Partial support is available for
SQLite.  Support among third-party dialects may vary.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_sql.ColumnOperators.regexp_replace</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">pattern</span></td><td class="fieldArgDesc">The regular expression pattern string or column
clause.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">flags</span></td><td class="fieldArgDesc">Any regular expression string flags to apply. Flags
tend to be backend specific. It can be a string or a column clause.
Some backends, like PostgreSQL and MariaDB, may alternatively
specify the flags as part of the pattern.
When using the ignore case flag 'i' in PostgreSQL, the ignore case
regexp match operator <tt class="rst-docutils literal">~*</tt> or <tt class="rst-docutils literal">!~*</tt> will be used.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.regexp_replace">
    
  </a>
  <a name="regexp_replace">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">regexp_replace</span>(self, pattern, replacement, flags=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implements a database-specific 'regexp replace' operator.</p>
<p>E.g.:</p>
<pre class="rst-literal-block">
stmt = select(
    table.c.some_column.regexp_replace(
        'b(..)',
        'X\x01Y',
        flags='g'
    )
)
</pre>
<p><code>_sql.ColumnOperators.regexp_replace</code> attempts to resolve to
a REGEXP_REPLACE-like function provided by the backend, that
usually emit the function <tt class="rst-docutils literal">REGEXP_REPLACE()</tt>.  However,
the specific regular expression syntax and flags available are
<strong>not backend agnostic</strong>.</p>
<p>Regular expression replacement support is currently implemented for
Oracle, PostgreSQL, MySQL 8 or greater and MariaDB.  Support among
third-party dialects may vary.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_sql.ColumnOperators.regexp_match</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">pattern</span></td><td class="fieldArgDesc">The replacement string or column clause.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">replacement</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">flags</span></td><td class="fieldArgDesc">Any regular expression string flags to apply. Flags
tend to be backend specific. It can be a string or a column clause.
Some backends, like PostgreSQL and MariaDB, may alternatively
specify the flags as part of the pattern.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.startswith">
    
  </a>
  <a name="startswith">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">startswith</span>(self, other, **kwargs):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Implement the <tt class="rst-docutils literal">startswith</tt> operator.</p>
<p>Produces a LIKE expression that tests against a match for the start
of a string value:</p>
<pre class="rst-literal-block">
column LIKE &lt;other&gt; || '%'
</pre>
<p>E.g.:</p>
<pre class="rst-literal-block">
stmt = select(sometable).\
    where(sometable.c.column.startswith("foobar"))
</pre>
<p>Since the operator uses <tt class="rst-docutils literal">LIKE</tt>, wildcard characters
<tt class="rst-docutils literal">"%"</tt> and <tt class="rst-docutils literal">"_"</tt> that are present inside the &lt;other&gt; expression
will behave like wildcards as well.   For literal string
values, the <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`.ColumnOperators.startswith.autoescape`</span></a> flag
may be set to <tt class="rst-docutils literal">True</tt> to apply escaping to occurrences of these
characters within the string value so that they match as themselves
and not as wildcard characters.  Alternatively, the
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`.ColumnOperators.startswith.escape`</span></a> parameter will establish
a given character as an escape character which can be of use when
the target expression is not a literal string.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><code>.ColumnOperators.endswith</code></p>
<p><code>.ColumnOperators.contains</code></p>
<p class="rst-last"><code>.ColumnOperators.like</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">expression to be compared.   This is usually a plain
string value, but can also be an arbitrary SQL expression.  LIKE
wildcard characters <tt class="rst-docutils literal">%</tt> and <tt class="rst-docutils literal">_</tt> are not escaped by default unless
the <a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:paramref:`.ColumnOperators.startswith.autoescape`</span></a> flag is
set to True.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwargs</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">autoescape</span></td><td class="fieldArgDesc"><p>boolean; when True, establishes an escape character
within the LIKE expression, then applies it to all occurrences of
<tt class="rst-docutils literal">"%"</tt>, <tt class="rst-docutils literal">"_"</tt> and the escape character itself within the
comparison value, which is assumed to be a literal string and not a
SQL expression.</p>
<p>An expression such as:</p>
<pre class="rst-literal-block">
somecolumn.startswith("foo%bar", autoescape=True)
</pre>
<p>Will render as:</p>
<pre class="rst-literal-block">
somecolumn LIKE :param || '%' ESCAPE '/'
</pre>
<p>With the value of <tt class="rst-docutils literal">:param</tt> as <tt class="rst-docutils literal"><span class="pre">"foo/%bar"</span></tt>.</p>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">escape</span></td><td class="fieldArgDesc"><p>a character which when given will render with the
<tt class="rst-docutils literal">ESCAPE</tt> keyword to establish that character as the escape
character.  This character can then be placed preceding occurrences
of <tt class="rst-docutils literal">%</tt> and <tt class="rst-docutils literal">_</tt> to allow them to act as themselves and not
wildcard characters.</p>
<p>An expression such as:</p>
<pre class="rst-literal-block">
somecolumn.startswith("foo/%bar", escape="^")
</pre>
<p>Will render as:</p>
<pre class="rst-literal-block">
somecolumn LIKE :param || '%' ESCAPE '^'
</pre>
<p>The parameter may also be combined with
<a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:paramref:`.ColumnOperators.startswith.autoescape`</span></a>:</p>
<pre class="rst-literal-block">
somecolumn.startswith("foo%bar^bat", escape="^", autoescape=True)
</pre>
<p>Where above, the given literal parameter will be converted to
<tt class="rst-docutils literal"><span class="pre">"foo^%bar^^bat"</span></tt> before being passed to the database.</p>
</td></tr></table></div>
  </div>
</div><div class="baseclassvariable">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.__slots__">
    
  </a>
  <a name="__slots__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">__slots__</span>: <code>tuple</code> =
    
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overrides <code><a href="sqlalchemy.sql.operators.Operators.html#__slots__" class="internal-link">sqlalchemy.sql.operators.Operators.__slots__</a></code></div><div class="interfaceinfo">overridden in <code><a href="sqlalchemy.orm.interfaces.PropComparator.html" class="internal-link">sqlalchemy.orm.interfaces.PropComparator</a></code>, <code><a href="sqlalchemy.types.TypeEngine.Comparator.html" class="internal-link">sqlalchemy.types.TypeEngine.Comparator</a></code>, <code><a href="sqlalchemy.sql.compiler._CompileLabel.html" class="internal-link">sqlalchemy.sql.compiler._CompileLabel</a></code></div>
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseclassvariable">
  
  
  <a name="sqlalchemy.sql.operators.ColumnOperators.timetuple">
    
  </a>
  <a name="timetuple">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">timetuple</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>Hack, allows datetime objects to be compared on the LHS.</div>
    
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 04:41:59.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>