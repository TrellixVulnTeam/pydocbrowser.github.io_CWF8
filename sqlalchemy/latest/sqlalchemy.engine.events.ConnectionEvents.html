<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.engine.events.ConnectionEvents</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    <div id="banner" class="container">    
    <div>
        <a href="https://pydocbrowser.github.io/">Home</a>
        &gt; sqlalchemy-1.4.31 
        <!-- This is an important placeholder and will be 
            replaced by project name and version on building docs -->
        
        <!-- (<a href=""&gt;show all versions</a&gt;) -->
    </div>
</div>

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.engine.html" class="internal-link" title="sqlalchemy.engine">engine</a></code><wbr></wbr>.<code><a href="sqlalchemy.engine.events.html" class="internal-link" title="sqlalchemy.engine.events">events</a></code><wbr></wbr>.<code><a href="sqlalchemy.engine.events.ConnectionEvents.html" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents">ConnectionEvents</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> <span class="py-defname">ConnectionEvents</span>(<a href="sqlalchemy.event.base.Events.html" class="internal-link" title="sqlalchemy.event.base.Events">event.Events</a>): <a href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L16" class="sourceLink">(source)</a></code></p><p>Known subclasses: <code><a href="sqlalchemy.ext.asyncio.events.AsyncConnectionEvents.html" class="internal-link">sqlalchemy.ext.asyncio.events.AsyncConnectionEvents</a></code></p>
        <p><a href="classIndex.html#sqlalchemy.engine.events.ConnectionEvents">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p>Available events for <code>.Connectable</code>, which includes
<code>_engine.Connection</code> and <code>_engine.Engine</code>.</p>
<p>The methods here define the name of an event as well as the names of
members that are passed to listener functions.</p>
<p>An event listener can be associated with any <code>.Connectable</code>
class or instance, such as an <code>_engine.Engine</code>, e.g.:</p>
<pre class="rst-literal-block">
from sqlalchemy import event, create_engine

def before_cursor_execute(conn, cursor, statement, parameters, context,
                                                executemany):
    log.info("Received statement: %s", statement)

engine = create_engine('postgresql://scott:tiger@localhost/test')
event.listen(engine, "before_cursor_execute", before_cursor_execute)
</pre>
<p>or with a specific <code>_engine.Connection</code>:</p>
<pre class="rst-literal-block">
with engine.begin() as conn:
    @event.listens_for(conn, 'before_cursor_execute')
    def before_cursor_execute(conn, cursor, statement, parameters,
                                    context, executemany):
        log.info("Received statement: %s", statement)
</pre>
<p>When the methods are called with a <code>statement</code> parameter, such as in
<code>.after_cursor_execute</code> or <code>.before_cursor_execute</code>,
the statement is the exact SQL string that was prepared for transmission
to the DBAPI <tt class="rst-docutils literal">cursor</tt> in the connection's <code>.Dialect</code>.</p>
<p>The <code>.before_execute</code> and <code>.before_cursor_execute</code>
events can also be established with the <tt class="rst-docutils literal">retval=True</tt> flag, which
allows modification of the statement and parameters to be sent
to the database.  The <code>.before_cursor_execute</code> event is
particularly useful here to add ad-hoc string transformations, such
as comments, to all executions:</p>
<pre class="rst-literal-block">
from sqlalchemy.engine import Engine
from sqlalchemy import event

@event.listens_for(Engine, "before_cursor_execute", retval=True)
def comment_sql_calls(conn, cursor, statement, parameters,
                                    context, executemany):
    statement = statement + " -- some comment"
    return statement, parameters
</pre>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p class="rst-last"><code>_events.ConnectionEvents</code> can be established on any
combination of <code>_engine.Engine</code>, <code>_engine.Connection</code>,
as well
as instances of each of those classes.  Events across all
four scopes will fire off for a given instance of
<code>_engine.Connection</code>.  However, for performance reasons, the
<code>_engine.Connection</code> object determines at instantiation time
whether or not its parent <code>_engine.Engine</code> has event listeners
established.   Event listeners added to the <code>_engine.Engine</code>
class or to an instance of <code>_engine.Engine</code>
<em>after</em> the instantiation
of a dependent <code>_engine.Connection</code> instance will usually
<em>not</em> be available on that <code>_engine.Connection</code> instance.
The newly
added listeners will instead take effect for
<code>_engine.Connection</code>
instances created subsequent to those event listeners being
established on the parent <code>_engine.Engine</code> class or instance.</p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">retval=​False</span></td><td class="fieldArgDesc">Applies to the <code>.before_execute</code> and
<code>.before_cursor_execute</code> events only.  When True, the
user-defined event function must have a return value, which
is a tuple of parameters that replace the given statement
and parameters.  See those methods for a description of
specific return arguments.</td></tr></table></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id20235">
  
  
  <tr class="method">
    
    <td>Method</td>
    <td><code><a href="#after_cursor_execute" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.after_cursor_execute">after​_cursor​_execute</a></code></td>
    <td>Intercept low-level cursor execute() events after execution.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#after_execute" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.after_execute">after​_execute</a></code></td>
    <td>Intercept high level execute() events after execute.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#before_cursor_execute" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.before_cursor_execute">before​_cursor​_execute</a></code></td>
    <td>Intercept low-level cursor execute() events before execution, receiving the string SQL statement and DBAPI-specific parameter list to be invoked against a cursor.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#before_execute" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.before_execute">before​_execute</a></code></td>
    <td>Intercept high level execute() events, receiving uncompiled SQL constructs and other objects prior to rendering into SQL.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#begin" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.begin">begin</a></code></td>
    <td>Intercept begin() events.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#begin_twophase" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.begin_twophase">begin​_twophase</a></code></td>
    <td>Intercept begin_twophase() events.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#commit" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.commit">commit</a></code></td>
    <td>Intercept commit() events, as initiated by a <code>.Transaction</code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#commit_twophase" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.commit_twophase">commit​_twophase</a></code></td>
    <td>Intercept commit_twophase() events.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#engine_connect" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.engine_connect">engine​_connect</a></code></td>
    <td>Intercept the creation of a new <code>_engine.Connection</code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#engine_disposed" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.engine_disposed">engine​_disposed</a></code></td>
    <td>Intercept when the <code>_engine.Engine.dispose</code> method is called.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#handle_error" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.handle_error">handle​_error</a></code></td>
    <td>Intercept all exceptions processed by the <code>_engine.Connection</code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#prepare_twophase" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.prepare_twophase">prepare​_twophase</a></code></td>
    <td>Intercept prepare_twophase() events.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#release_savepoint" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.release_savepoint">release​_savepoint</a></code></td>
    <td>Intercept release_savepoint() events.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#rollback" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.rollback">rollback</a></code></td>
    <td>Intercept rollback() events, as initiated by a <code>.Transaction</code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#rollback_savepoint" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.rollback_savepoint">rollback​_savepoint</a></code></td>
    <td>Intercept rollback_savepoint() events.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#rollback_twophase" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.rollback_twophase">rollback​_twophase</a></code></td>
    <td>Intercept rollback_twophase() events.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#savepoint" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.savepoint">savepoint</a></code></td>
    <td>Intercept savepoint() events.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#set_connection_execution_options" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.set_connection_execution_options">set​_connection​_execution​_options</a></code></td>
    <td>Intercept when the <code>_engine.Connection.execution_options</code> method is called.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#set_engine_execution_options" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents.set_engine_execution_options">set​_engine​_execution​_options</a></code></td>
    <td>Intercept when the <code>_engine.Engine.execution_options</code> method is called.</td>
  </tr><tr class="classmethod private">
    
    <td>Class Method</td>
    <td><code><a href="#_listen" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents._listen">​_listen</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable private">
    
    <td>Class Variable</td>
    <td><code><a href="#_target_class_doc" class="internal-link" title="sqlalchemy.engine.events.ConnectionEvents._target_class_doc">​_target​_class​_doc</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <code><a href="sqlalchemy.event.base.Events.html" class="internal-link" title="sqlalchemy.event.base.Events">Events</a></code>:
          </p>
          <table class="children sortable" id="id20236">
  
  
  <tr class="baseclassmethod private">
    
    <td>Class Method</td>
    <td><code><a href="sqlalchemy.event.base.Events.html#_accept_with" class="internal-link" title="sqlalchemy.event.base.Events._accept_with">​_accept​_with</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="baseclassmethod private">
    
    <td>Class Method</td>
    <td><code><a href="sqlalchemy.event.base.Events.html#_clear" class="internal-link" title="sqlalchemy.event.base.Events._clear">​_clear</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="baseclassmethod private">
    
    <td>Class Method</td>
    <td><code><a href="sqlalchemy.event.base.Events.html#_remove" class="internal-link" title="sqlalchemy.event.base.Events._remove">​_remove</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basestaticmethod private">
    
    <td>Static Method</td>
    <td><code><a href="sqlalchemy.event.base.Events.html#_set_dispatch" class="internal-link" title="sqlalchemy.event.base.Events._set_dispatch">​_set​_dispatch</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.after_cursor_execute">
    
  </a>
  <a name="after_cursor_execute">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">after_cursor_execute</span>(self, conn, cursor, statement, parameters, context, executemany):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L285">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Intercept low-level cursor execute() events after execution.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cursor</span></td><td class="fieldArgDesc">DBAPI cursor object.  Will have results pending
if the statement was a SELECT, but these should not be consumed
as they will be needed by the <code>_engine.CursorResult</code>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">statement</span></td><td class="fieldArgDesc">string SQL statement, as passed to the DBAPI</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">parameters</span></td><td class="fieldArgDesc">Dictionary, tuple, or list of parameters being
passed to the <tt class="rst-docutils literal">execute()</tt> or <tt class="rst-docutils literal">executemany()</tt> method of the
DBAPI <tt class="rst-docutils literal">cursor</tt>.  In some cases may be <tt class="rst-docutils literal">None</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">context</span></td><td class="fieldArgDesc"><code>.ExecutionContext</code> object in use.  May
be <tt class="rst-docutils literal">None</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">executemany</span></td><td class="fieldArgDesc">boolean, if <tt class="rst-docutils literal">True</tt>, this is an <tt class="rst-docutils literal">executemany()</tt>
call, if <tt class="rst-docutils literal">False</tt>, this is an <tt class="rst-docutils literal">execute()</tt> call.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.after_execute">
    
  </a>
  <a name="after_execute">
    
  </a>
  <div class="functionHeader">
    @<a href="sqlalchemy.event.legacy.html#_legacy_signature" class="internal-link" title="sqlalchemy.event.legacy._legacy_signature">event._legacy_signature</a>(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">1.4</span><span class="rst-variable-quote">'</span>, <wbr></wbr>[<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">conn</span><span class="rst-variable-quote">'</span>, <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">clauseelement</span><span class="rst-variable-quote">'</span>, <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">multiparams</span><span class="rst-variable-quote">'</span>, <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">params</span><span class="rst-variable-quote">'</span>, <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">result</span><span class="rst-variable-quote">'</span>], <wbr></wbr>(lambda conn, clauseelement, multiparams, params, execution_options, resu<span class="rst-variable-ellipsis">...</span><br />
    <span class="py-keyword">def</span> <span class="py-defname">after_execute</span>(self, conn, clauseelement, multiparams, params, execution_options, result):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L201">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Intercept high level execute() events after execute.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">clauseelement</span></td><td class="fieldArgDesc">SQL expression construct, <code>.Compiled</code>
instance, or string statement passed to
<code>_engine.Connection.execute</code>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">multiparams</span></td><td class="fieldArgDesc">Multiple parameter sets, a list of dictionaries.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">params</span></td><td class="fieldArgDesc">Single parameter set, a single dictionary.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">execution​_options</span></td><td class="fieldArgDesc"><p>dictionary of execution
options passed along with the statement, if any.  This is a merge
of all options that will be used, including those of the statement,
the connection, and those passed in to the method itself for
the 2.0 style of execution.</p>
<!-- versionadded: 1.4 -->
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">result</span></td><td class="fieldArgDesc"><code>_engine.CursorResult</code> generated by the
execution.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.before_cursor_execute">
    
  </a>
  <a name="before_cursor_execute">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">before_cursor_execute</span>(self, conn, cursor, statement, parameters, context, executemany):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L243">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Intercept low-level cursor execute() events before execution,
receiving the string SQL statement and DBAPI-specific parameter list to
be invoked against a cursor.</p>
<p>This event is a good choice for logging as well as late modifications
to the SQL string.  It's less ideal for parameter modifications except
for those which are specific to a target backend.</p>
<p>This event can be optionally established with the <tt class="rst-docutils literal">retval=True</tt>
flag.  The <tt class="rst-docutils literal">statement</tt> and <tt class="rst-docutils literal">parameters</tt> arguments should be
returned as a two-tuple in this case:</p>
<pre class="rst-literal-block">
@event.listens_for(Engine, "before_cursor_execute", retval=True)
def before_cursor_execute(conn, cursor, statement,
                parameters, context, executemany):
    # do something with statement, parameters
    return statement, parameters
</pre>
<p>See the example at <code>_events.ConnectionEvents</code>.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><code>.before_execute</code></p>
<p class="rst-last"><code>.after_cursor_execute</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cursor</span></td><td class="fieldArgDesc">DBAPI cursor object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">statement</span></td><td class="fieldArgDesc">string SQL statement, as to be passed to the DBAPI</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">parameters</span></td><td class="fieldArgDesc">Dictionary, tuple, or list of parameters being
passed to the <tt class="rst-docutils literal">execute()</tt> or <tt class="rst-docutils literal">executemany()</tt> method of the
DBAPI <tt class="rst-docutils literal">cursor</tt>.  In some cases may be <tt class="rst-docutils literal">None</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">context</span></td><td class="fieldArgDesc"><code>.ExecutionContext</code> object in use.  May
be <tt class="rst-docutils literal">None</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">executemany</span></td><td class="fieldArgDesc">boolean, if <tt class="rst-docutils literal">True</tt>, this is an <tt class="rst-docutils literal">executemany()</tt>
call, if <tt class="rst-docutils literal">False</tt>, this is an <tt class="rst-docutils literal">execute()</tt> call.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.before_execute">
    
  </a>
  <a name="before_execute">
    
  </a>
  <div class="functionHeader">
    @<a href="sqlalchemy.event.legacy.html#_legacy_signature" class="internal-link" title="sqlalchemy.event.legacy._legacy_signature">event._legacy_signature</a>(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">1.4</span><span class="rst-variable-quote">'</span>, <wbr></wbr>[<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">conn</span><span class="rst-variable-quote">'</span>, <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">clauseelement</span><span class="rst-variable-quote">'</span>, <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">multiparams</span><span class="rst-variable-quote">'</span>, <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">params</span><span class="rst-variable-quote">'</span>], <wbr></wbr>(lambda conn, clauseelement, multiparams, params, execution_options: (co<span class="rst-variable-ellipsis">...</span><br />
    <span class="py-keyword">def</span> <span class="py-defname">before_execute</span>(self, conn, clauseelement, multiparams, params, execution_options):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L152">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Intercept high level execute() events, receiving uncompiled
SQL constructs and other objects prior to rendering into SQL.</p>
<p>This event is good for debugging SQL compilation issues as well
as early manipulation of the parameters being sent to the database,
as the parameter lists will be in a consistent format here.</p>
<p>This event can be optionally established with the <tt class="rst-docutils literal">retval=True</tt>
flag.  The <tt class="rst-docutils literal">clauseelement</tt>, <tt class="rst-docutils literal">multiparams</tt>, and <tt class="rst-docutils literal">params</tt>
arguments should be returned as a three-tuple in this case:</p>
<pre class="rst-literal-block">
@event.listens_for(Engine, "before_execute", retval=True)
def before_execute(conn, clauseelement, multiparams, params):
    # do something with clauseelement, multiparams, params
    return clauseelement, multiparams, params
</pre>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>.before_cursor_execute</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">clauseelement</span></td><td class="fieldArgDesc">SQL expression construct, <code>.Compiled</code>
instance, or string statement passed to
<code>_engine.Connection.execute</code>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">multiparams</span></td><td class="fieldArgDesc">Multiple parameter sets, a list of dictionaries.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">params</span></td><td class="fieldArgDesc">Single parameter set, a single dictionary.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">execution​_options</span></td><td class="fieldArgDesc"><p>dictionary of execution
options passed along with the statement, if any.  This is a merge
of all options that will be used, including those of the statement,
the connection, and those passed in to the method itself for
the 2.0 style of execution.</p>
<!-- versionadded: 1.4 -->
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.begin">
    
  </a>
  <a name="begin">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">begin</span>(self, conn):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L569">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Intercept begin() events.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.begin_twophase">
    
  </a>
  <a name="begin_twophase">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">begin_twophase</span>(self, conn, xid):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L634">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Intercept begin_twophase() events.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">xid</span></td><td class="fieldArgDesc">two-phase XID identifier</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.commit">
    
  </a>
  <a name="commit">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">commit</span>(self, conn):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L594">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Intercept commit() events, as initiated by a
<code>.Transaction</code>.</p>
<p>Note that the <code>_pool.Pool</code> may also "auto-commit"
a DBAPI connection upon checkin, if the <tt class="rst-docutils literal">reset_on_return</tt>
flag is set to the value <tt class="rst-docutils literal">'commit'</tt>.  To intercept this
commit, use the <code>_events.PoolEvents.reset</code> hook.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.commit_twophase">
    
  </a>
  <a name="commit_twophase">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">commit_twophase</span>(self, conn, xid, is_prepared):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L659">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Intercept commit_twophase() events.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">xid</span></td><td class="fieldArgDesc">two-phase XID identifier</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">is​_prepared</span></td><td class="fieldArgDesc">boolean, indicates if
<code>.TwoPhaseTransaction.prepare</code> was called.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.engine_connect">
    
  </a>
  <a name="engine_connect">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">engine_connect</span>(self, conn, branch):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L439">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Intercept the creation of a new <code>_engine.Connection</code>.</p>
<p>This event is called typically as the direct result of calling
the <code>_engine.Engine.connect</code> method.</p>
<p>It differs from the <code>_events.PoolEvents.connect</code> method, which
refers to the actual connection to a database at the DBAPI level;
a DBAPI connection may be pooled and reused for many operations.
In contrast, this event refers only to the production of a higher level
<code>_engine.Connection</code> wrapper around such a DBAPI connection.</p>
<p>It also differs from the <code>_events.PoolEvents.checkout</code> event
in that it is specific to the <code>_engine.Connection</code> object,
not the
DBAPI connection that <code>_events.PoolEvents.checkout</code> deals with,
although
this DBAPI connection is available here via the
<code>_engine.Connection.connection</code> attribute.
But note there can in fact
be multiple <code>_events.PoolEvents.checkout</code>
events within the lifespan
of a single <code>_engine.Connection</code> object, if that
<code>_engine.Connection</code>
is invalidated and re-established.  There can also be multiple
<code>_engine.Connection</code>
objects generated for the same already-checked-out
DBAPI connection, in the case that a "branch" of a
<code>_engine.Connection</code>
is produced.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_events.PoolEvents.checkout</code>
the lower-level pool checkout event
for an individual DBAPI connection</p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">branch</span></td><td class="fieldArgDesc">if True, this is a "branch" of an existing
<code>_engine.Connection</code>.  A branch is generated within the course
of a statement execution to invoke supplemental statements, most
typically to pre-execute a SELECT of a default value for the purposes
of an INSERT statement.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.engine_disposed">
    
  </a>
  <a name="engine_disposed">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">engine_disposed</span>(self, engine):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L549">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Intercept when the <code>_engine.Engine.dispose</code> method is called.</p>
<p>The <code>_engine.Engine.dispose</code> method instructs the engine to
"dispose" of it's connection pool (e.g. <code>_pool.Pool</code>), and
replaces it with a new one.  Disposing of the old pool has the
effect that existing checked-in connections are closed.  The new
pool does not establish any new connections until it is first used.</p>
<p>This event can be used to indicate that resources related to the
<code>_engine.Engine</code> should also be cleaned up,
keeping in mind that the
<code>_engine.Engine</code>
can still be used for new requests in which case
it re-acquires connection resources.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.0.5.</span></div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.handle_error">
    
  </a>
  <a name="handle_error">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">handle_error</span>(self, exception_context):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L305">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Intercept all exceptions processed by the
<code>_engine.Connection</code>.</p>
<p>This includes all exceptions emitted by the DBAPI as well as
within SQLAlchemy's statement invocation process, including
encoding errors and other statement validation errors.  Other areas
in which the event is invoked include transaction begin and end,
result row fetching, cursor creation.</p>
<p>Note that <code>.handle_error</code> may support new kinds of exceptions
and new calling scenarios at <em>any time</em>.  Code which uses this
event must expect new calling patterns to be present in minor
releases.</p>
<p>To support the wide variety of members that correspond to an exception,
as well as to allow extensibility of the event without backwards
incompatibility, the sole argument received is an instance of
<code>.ExceptionContext</code>.   This object contains data members
representing detail about the exception.</p>
<p>Use cases supported by this hook include:</p>
<ul class="rst-simple">
<li>read-only, low-level exception handling for logging and
debugging purposes</li>
<li>exception re-writing</li>
<li>Establishing or disabling whether a connection or the owning
connection pool is invalidated or expired in response to a
specific exception <a class="rst-footnote-reference" href="#rst-footnote-1" id="rst-footnote-reference-1">[1]</a>.</li>
</ul>
<p>The hook is called while the cursor from the failed operation
(if any) is still open and accessible.   Special cleanup operations
can be called on this cursor; SQLAlchemy will attempt to close
this cursor subsequent to this hook being invoked.  If the connection
is in "autocommit" mode, the transaction also remains open within
the scope of this hook; the rollback of the per-statement transaction
also occurs after the hook is called.</p>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<table class="rst-last rst-docutils footnote" frame="void" id="rst-footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="rst-label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>The pool "pre_ping" handler enabled using the
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`_sa.create_engine.pool_pre_ping`</span></a> parameter does
<strong>not</strong> consult this event before deciding if the "ping"
returned false, as opposed to receiving an unhandled error.
For this use case, the <a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`legacy recipe based on
engine_connect() may be used
&lt;pool_disconnects_pessimistic_custom&gt;`</span></a>.  A future API allow
more comprehensive customization of the "disconnect"
detection mechanism across all functions.</td></tr>
</tbody>
</table>
</div>
<p>A handler function has two options for replacing
the SQLAlchemy-constructed exception into one that is user
defined.   It can either raise this new exception directly, in
which case all further event listeners are bypassed and the
exception will be raised, after appropriate cleanup as taken
place:</p>
<pre class="rst-literal-block">
@event.listens_for(Engine, "handle_error")
def handle_exception(context):
    if isinstance(context.original_exception,
        psycopg2.OperationalError) and \
        "failed" in str(context.original_exception):
        raise MySpecialException("failed operation")
</pre>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p class="rst-last">Because the
<code>_events.ConnectionEvents.handle_error</code>
event specifically provides for exceptions to be re-thrown as
the ultimate exception raised by the failed statement,
<strong>stack traces will be misleading</strong> if the user-defined event
handler itself fails and throws an unexpected exception;
the stack trace may not illustrate the actual code line that
failed!  It is advised to code carefully here and use
logging and/or inline debugging if unexpected exceptions are
occurring.</p>
</div>
<p>Alternatively, a "chained" style of event handling can be
used, by configuring the handler with the <tt class="rst-docutils literal">retval=True</tt>
modifier and returning the new exception instance from the
function.  In this case, event handling will continue onto the
next handler.   The "chained" exception is available using
<code>.ExceptionContext.chained_exception</code>:</p>
<pre class="rst-literal-block">
@event.listens_for(Engine, "handle_error", retval=True)
def handle_exception(context):
    if context.chained_exception is not None and \
        "special" in context.chained_exception.message:
        return MySpecialException("failed",
            cause=context.chained_exception)
</pre>
<p>Handlers that return <tt class="rst-docutils literal">None</tt> may be used within the chain; when
a handler returns <tt class="rst-docutils literal">None</tt>, the previous exception instance,
if any, is maintained as the current exception that is passed onto the
next handler.</p>
<p>When a custom exception is raised or returned, SQLAlchemy raises
this new exception as-is, it is not wrapped by any SQLAlchemy
object.  If the exception is not a subclass of
<code><a href="sqlalchemy.exc.StatementError.html" class="internal-link">sqlalchemy.exc.StatementError</a></code>,
certain features may not be available; currently this includes
the ORM's feature of adding a detail hint about "autoflush" to
exceptions raised within the autoflush process.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.9.7: </span><span>Added the
<code>_events.ConnectionEvents.handle_error</code> hook.</span></div>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.1: </span><span>The <code>.handle_error</code> event will now
receive all exceptions that inherit from <tt class="rst-docutils literal">BaseException</tt>,
including <tt class="rst-docutils literal">SystemExit</tt> and <tt class="rst-docutils literal">KeyboardInterrupt</tt>.  The setting for
<code>.ExceptionContext.is_disconnect</code> is <tt class="rst-docutils literal">True</tt> in this case and
the default for
<code>.ExceptionContext.invalidate_pool_on_disconnect</code> is
<tt class="rst-docutils literal">False</tt>.</span></div>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.0.0: </span><span>The <code>.handle_error</code> event is now
invoked when an <code>_engine.Engine</code> fails during the initial
call to <code>_engine.Engine.connect</code>, as well as when a
<code>_engine.Connection</code> object encounters an error during a
reconnect operation.</span></div>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.0.0: </span><span>The <code>.handle_error</code> event is
not fired off when a dialect makes use of the
<tt class="rst-docutils literal">skip_user_error_events</tt> execution option.   This is used
by dialects which intend to catch SQLAlchemy-specific exceptions
within specific operations, such as when the MySQL dialect detects
a table not present within the <tt class="rst-docutils literal">has_table()</tt> dialect method.
Prior to 1.0.0, code which implements <code>.handle_error</code> needs
to ensure that exceptions thrown in these scenarios are re-raised
without modification.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">exception​_context</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">context</span></td><td class="fieldArgDesc">an <code>.ExceptionContext</code> object.  See this
class for details on all available members.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.prepare_twophase">
    
  </a>
  <a name="prepare_twophase">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">prepare_twophase</span>(self, conn, xid):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L642">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Intercept prepare_twophase() events.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">xid</span></td><td class="fieldArgDesc">two-phase XID identifier</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.release_savepoint">
    
  </a>
  <a name="release_savepoint">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">release_savepoint</span>(self, conn, name, context):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L624">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Intercept release_savepoint() events.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">name</span></td><td class="fieldArgDesc">specified name used for the savepoint.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">context</span></td><td class="fieldArgDesc">not used</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.rollback">
    
  </a>
  <a name="rollback">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rollback</span>(self, conn):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L576">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Intercept rollback() events, as initiated by a
<code>.Transaction</code>.</p>
<p>Note that the <code>_pool.Pool</code> also "auto-rolls back"
a DBAPI connection upon checkin, if the <tt class="rst-docutils literal">reset_on_return</tt>
flag is set to its default value of <tt class="rst-docutils literal">'rollback'</tt>.
To intercept this
rollback, use the <code>_events.PoolEvents.reset</code> hook.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_events.PoolEvents.reset</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.rollback_savepoint">
    
  </a>
  <a name="rollback_savepoint">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rollback_savepoint</span>(self, conn, name, context):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L614">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Intercept rollback_savepoint() events.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">name</span></td><td class="fieldArgDesc">specified name used for the savepoint.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">context</span></td><td class="fieldArgDesc">not used</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.rollback_twophase">
    
  </a>
  <a name="rollback_twophase">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rollback_twophase</span>(self, conn, xid, is_prepared):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L649">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Intercept rollback_twophase() events.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">xid</span></td><td class="fieldArgDesc">two-phase XID identifier</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">is​_prepared</span></td><td class="fieldArgDesc">boolean, indicates if
<code>.TwoPhaseTransaction.prepare</code> was called.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.savepoint">
    
  </a>
  <a name="savepoint">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">savepoint</span>(self, conn, name):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L606">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Intercept savepoint() events.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc"><code>_engine.Connection</code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">name</span></td><td class="fieldArgDesc">specified name used for the savepoint.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.set_connection_execution_options">
    
  </a>
  <a name="set_connection_execution_options">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">set_connection_execution_options</span>(self, conn, opts):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L485">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Intercept when the <code>_engine.Connection.execution_options</code>
method is called.</p>
<p>This method is called after the new <code>_engine.Connection</code>
has been
produced, with the newly updated execution options collection, but
before the <code>.Dialect</code> has acted upon any of those new options.</p>
<p>Note that this method is not called when a new
<code>_engine.Connection</code>
is produced which is inheriting execution options from its parent
<code>_engine.Engine</code>; to intercept this condition, use the
<code>_events.ConnectionEvents.engine_connect</code> event.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.9.0.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_events.ConnectionEvents.set_engine_execution_options</code>
- event
which is called when <code>_engine.Engine.execution_options</code>
is called.</p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc">The newly copied <code>_engine.Connection</code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">opts</span></td><td class="fieldArgDesc">dictionary of options that were passed to the
<code>_engine.Connection.execution_options</code> method.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents.set_engine_execution_options">
    
  </a>
  <a name="set_engine_execution_options">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">set_engine_execution_options</span>(self, engine, opts):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L517">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Intercept when the <code>_engine.Engine.execution_options</code>
method is called.</p>
<p>The <code>_engine.Engine.execution_options</code> method produces a shallow
copy of the <code>_engine.Engine</code> which stores the new options.
That new
<code>_engine.Engine</code> is passed here.
A particular application of this
method is to add a <code>_events.ConnectionEvents.engine_connect</code>
event
handler to the given <code>_engine.Engine</code>
which will perform some per-
<code>_engine.Connection</code> task specific to these execution options.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.9.0.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_events.ConnectionEvents.set_connection_execution_options</code>
- event
which is called when <code>_engine.Connection.execution_options</code>
is
called.</p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">engine</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">opts</span></td><td class="fieldArgDesc">dictionary of options that were passed to the
<code>_engine.Connection.execution_options</code> method.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">conn</span></td><td class="fieldArgDesc">The newly copied <code>_engine.Engine</code> object</td></tr></table></div>
  </div>
</div><div class="baseclassmethod private">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents._listen">
    
  </a>
  <a name="_listen">
    
  </a>
  <div class="functionHeader">
    @<a href="https://docs.python.org/3/library/functions.html#classmethod" class="intersphinx-link">classmethod</a><br />
    <span class="py-keyword">def</span> <span class="py-defname">_listen</span>(cls, event_key, retval=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L95">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="sqlalchemy.event.base.Events.html#_listen" class="internal-link">sqlalchemy.event.base.Events._listen</a></code></div><div class="interfaceinfo">overridden in <code><a href="sqlalchemy.ext.asyncio.events.AsyncConnectionEvents.html" class="internal-link">sqlalchemy.ext.asyncio.events.AsyncConnectionEvents</a></code></div>
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="baseclassvariable private">
  
  
  <a name="sqlalchemy.engine.events.ConnectionEvents._target_class_doc">
    
  </a>
  <a name="_target_class_doc">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_target_class_doc</span>: <code><a href="https://docs.python.org/3/library/stdtypes.html#str" class="intersphinx-link">str</a></code> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/engine/events.py#L92">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overridden in <code><a href="sqlalchemy.ext.asyncio.events.AsyncConnectionEvents.html" class="internal-link">sqlalchemy.ext.asyncio.events.AsyncConnectionEvents</a></code></div>
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 08:22:50.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>