<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.sql.selectable.HasCTE</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.sql.html" class="internal-link" title="sqlalchemy.sql">sql</a></code><wbr></wbr>.<code><a href="sqlalchemy.sql.selectable.html" class="internal-link" title="sqlalchemy.sql.selectable">selectable</a></code><wbr></wbr>.<code><a href="sqlalchemy.sql.selectable.HasCTE.html" class="internal-link" title="sqlalchemy.sql.selectable.HasCTE">HasCTE</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> <span class="py-defname">HasCTE</span>(<a href="sqlalchemy.sql.roles.HasCTERole.html" class="internal-link" title="sqlalchemy.sql.roles.HasCTERole">roles.HasCTERole</a>):</code></p><p>Known subclasses: <code><a href="sqlalchemy.sql.dml.UpdateBase.html" class="internal-link">sqlalchemy.sql.dml.UpdateBase</a></code>, <code><a href="sqlalchemy.sql.selectable.SelectBase.html" class="internal-link">sqlalchemy.sql.selectable.SelectBase</a></code></p>
        <p><a href="classIndex.html#sqlalchemy.sql.selectable.HasCTE">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p>Mixin that declares a class to include CTE support.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.1.</span></div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id20420">
  
  
  <tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add_cte" class="internal-link" title="sqlalchemy.sql.selectable.HasCTE.add_cte">add​_cte</a></code></td>
    <td>Add a <code>_sql.CTE</code> to this statement object that will be independently rendered even if not referenced in the statement otherwise.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#cte" class="internal-link" title="sqlalchemy.sql.selectable.HasCTE.cte">cte</a></code></td>
    <td>Return a new <code>_expression.CTE</code>, or Common Table Expression instance.</td>
  </tr><tr class="classvariable private">
    
    <td>Class Variable</td>
    <td><code><a href="#_has_ctes_traverse_internals" class="internal-link" title="sqlalchemy.sql.selectable.HasCTE._has_ctes_traverse_internals">​_has​_ctes​_traverse​_internals</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable private">
    
    <td>Class Variable</td>
    <td><code><a href="#_independent_ctes" class="internal-link" title="sqlalchemy.sql.selectable.HasCTE._independent_ctes">​_independent​_ctes</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <code><a href="sqlalchemy.sql.roles.ReturnsRowsRole.html" class="internal-link" title="sqlalchemy.sql.roles.ReturnsRowsRole">ReturnsRowsRole</a></code> (via <code><a href="sqlalchemy.sql.roles.HasCTERole.html" class="internal-link" title="sqlalchemy.sql.roles.HasCTERole">HasCTERole</a></code>):
          </p>
          <table class="children sortable" id="id20421">
  
  
  <tr class="baseclassvariable private">
    
    <td>Class Variable</td>
    <td><code><a href="sqlalchemy.sql.roles.ReturnsRowsRole.html#_role_name" class="internal-link" title="sqlalchemy.sql.roles.ReturnsRowsRole._role_name">​_role​_name</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
          
          <p class="inheritedFrom">
            Inherited from <code><a href="sqlalchemy.sql.roles.SQLRole.html" class="internal-link" title="sqlalchemy.sql.roles.SQLRole">SQLRole</a></code> (via <code><a href="sqlalchemy.sql.roles.HasCTERole.html" class="internal-link" title="sqlalchemy.sql.roles.HasCTERole">HasCTERole</a></code>, <code><a href="sqlalchemy.sql.roles.ReturnsRowsRole.html" class="internal-link" title="sqlalchemy.sql.roles.ReturnsRowsRole">ReturnsRowsRole</a></code>):
          </p>
          <table class="children sortable" id="id20422">
  
  
  <tr class="baseclassvariable">
    
    <td>Class Variable</td>
    <td><code><a href="sqlalchemy.sql.roles.SQLRole.html#allows_lambda" class="internal-link" title="sqlalchemy.sql.roles.SQLRole.allows_lambda">allows​_lambda</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="baseclassvariable">
    
    <td>Class Variable</td>
    <td><code><a href="sqlalchemy.sql.roles.SQLRole.html#uses_inspection" class="internal-link" title="sqlalchemy.sql.roles.SQLRole.uses_inspection">uses​_inspection</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  
  <a name="sqlalchemy.sql.selectable.HasCTE.add_cte">
    
  </a>
  <a name="add_cte">
    
  </a>
  <div class="functionHeader">
    @<a href="sqlalchemy.sql.base.html#_generative" class="internal-link" title="sqlalchemy.sql.base._generative">_generative</a><br />
    <span class="py-keyword">def</span> <span class="py-defname">add_cte</span>(self, cte):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Add a <code>_sql.CTE</code> to this statement object that will be
independently rendered even if not referenced in the statement
otherwise.</p>
<p>This feature is useful for the use case of embedding a DML statement
such as an INSERT or UPDATE as a CTE inline with a primary statement
that may draw from its results indirectly; while PostgreSQL is known
to support this usage, it may not be supported by other backends.</p>
<p>E.g.:</p>
<pre class="rst-literal-block">
from sqlalchemy import table, column, select
t = table('t', column('c1'), column('c2'))

ins = t.insert().values({"c1": "x", "c2": "y"}).cte()

stmt = select(t).add_cte(ins)
</pre>
<p>Would render:</p>
<pre class="rst-literal-block">
WITH anon_1 AS
(INSERT INTO t (c1, c2) VALUES (:param_1, :param_2))
SELECT t.c1, t.c2
FROM t
</pre>
<p>Above, the "anon_1" CTE is not referred towards in the SELECT
statement, however still accomplishes the task of running an INSERT
statement.</p>
<p>Similarly in a DML-related context, using the PostgreSQL
<code>_postgresql.Insert</code> construct to generate an "upsert":</p>
<pre class="rst-literal-block">
from sqlalchemy import table, column
from sqlalchemy.dialects.postgresql import insert

t = table("t", column("c1"), column("c2"))

delete_statement_cte = (
    t.delete().where(t.c.c1 &lt; 1).cte("deletions")
)

insert_stmt = insert(t).values({"c1": 1, "c2": 2})
update_statement = insert_stmt.on_conflict_do_update(
    index_elements=[t.c.c1],
    set_={
        "c1": insert_stmt.excluded.c1,
        "c2": insert_stmt.excluded.c2,
    },
).add_cte(delete_statement_cte)

print(update_statement)
</pre>
<p>The above statement renders as:</p>
<pre class="rst-literal-block">
WITH deletions AS
(DELETE FROM t WHERE t.c1 &lt; %(c1_1)s)
INSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s)
ON CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2
</pre>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.21.</span></div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.sql.selectable.HasCTE.cte">
    
  </a>
  <a name="cte">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">cte</span>(self, name=None, recursive=False, nesting=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a new <code>_expression.CTE</code>,
or Common Table Expression instance.</p>
<p>Common table expressions are a SQL standard whereby SELECT
statements can draw upon secondary statements specified along
with the primary statement, using a clause called "WITH".
Special semantics regarding UNION can also be employed to
allow "recursive" queries, where a SELECT statement can draw
upon the set of rows that have previously been selected.</p>
<p>CTEs can also be applied to DML constructs UPDATE, INSERT
and DELETE on some databases, both as a source of CTE rows
when combined with RETURNING, as well as a consumer of
CTE rows.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.1: </span><span>Added support for UPDATE/INSERT/DELETE as
CTE, CTEs added to UPDATE/INSERT/DELETE.</span></div>
<p>SQLAlchemy detects <code>_expression.CTE</code> objects, which are treated
similarly to <code>_expression.Alias</code> objects, as special elements
to be delivered to the FROM clause of the statement as well
as to a WITH clause at the top of the statement.</p>
<p>For special prefixes such as PostgreSQL "MATERIALIZED" and
"NOT MATERIALIZED", the <code>_expression.CTE.prefix_with</code>
method may be
used to establish these.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.3.13: </span><span>Added support for prefixes.
In particular - MATERIALIZED and NOT MATERIALIZED.</span></div>
<p>The following examples include two from PostgreSQL's documentation at
<a class="rst-reference external" href="https://www.postgresql.org/docs/current/static/queries-with.html" target="_top">https://www.postgresql.org/docs/current/static/queries-with.html</a>,
as well as additional examples.</p>
<p>Example 1, non recursive:</p>
<pre class="rst-literal-block">
from sqlalchemy import (Table, Column, String, Integer,
                        MetaData, select, func)

metadata = MetaData()

orders = Table('orders', metadata,
    Column('region', String),
    Column('amount', Integer),
    Column('product', String),
    Column('quantity', Integer)
)

regional_sales = select(
                    orders.c.region,
                    func.sum(orders.c.amount).label('total_sales')
                ).group_by(orders.c.region).cte("regional_sales")


top_regions = select(regional_sales.c.region).\
        where(
            regional_sales.c.total_sales &gt;
            select(
                func.sum(regional_sales.c.total_sales) / 10
            )
        ).cte("top_regions")

statement = select(
            orders.c.region,
            orders.c.product,
            func.sum(orders.c.quantity).label("product_units"),
            func.sum(orders.c.amount).label("product_sales")
    ).where(orders.c.region.in_(
        select(top_regions.c.region)
    )).group_by(orders.c.region, orders.c.product)

result = conn.execute(statement).fetchall()
</pre>
<p>Example 2, WITH RECURSIVE:</p>
<pre class="rst-literal-block">
from sqlalchemy import (Table, Column, String, Integer,
                        MetaData, select, func)

metadata = MetaData()

parts = Table('parts', metadata,
    Column('part', String),
    Column('sub_part', String),
    Column('quantity', Integer),
)

included_parts = select(\
    parts.c.sub_part, parts.c.part, parts.c.quantity\
    ).\
    where(parts.c.part=='our part').\
    cte(recursive=True)


incl_alias = included_parts.alias()
parts_alias = parts.alias()
included_parts = included_parts.union_all(
    select(
        parts_alias.c.sub_part,
        parts_alias.c.part,
        parts_alias.c.quantity
    ).\
    where(parts_alias.c.part==incl_alias.c.sub_part)
)

statement = select(
            included_parts.c.sub_part,
            func.sum(included_parts.c.quantity).
              label('total_quantity')
        ).\
        group_by(included_parts.c.sub_part)

result = conn.execute(statement).fetchall()
</pre>
<p>Example 3, an upsert using UPDATE and INSERT with CTEs:</p>
<pre class="rst-literal-block">
from datetime import date
from sqlalchemy import (MetaData, Table, Column, Integer,
                        Date, select, literal, and_, exists)

metadata = MetaData()

visitors = Table('visitors', metadata,
    Column('product_id', Integer, primary_key=True),
    Column('date', Date, primary_key=True),
    Column('count', Integer),
)

# add 5 visitors for the product_id == 1
product_id = 1
day = date.today()
count = 5

update_cte = (
    visitors.update()
    .where(and_(visitors.c.product_id == product_id,
                visitors.c.date == day))
    .values(count=visitors.c.count + count)
    .returning(literal(1))
    .cte('update_cte')
)

upsert = visitors.insert().from_select(
    [visitors.c.product_id, visitors.c.date, visitors.c.count],
    select(literal(product_id), literal(day), literal(count))
        .where(~exists(update_cte.select()))
)

connection.execute(upsert)
</pre>
<p>Example 4, Nesting CTE (SQLAlchemy 1.4.24 and above):</p>
<pre class="rst-literal-block">
value_a = select(
    literal("root").label("n")
).cte("value_a")

# A nested CTE with the same name as the root one
value_a_nested = select(
    literal("nesting").label("n")
).cte("value_a", nesting=True)

# Nesting CTEs takes ascendency locally
# over the CTEs at a higher level
value_b = select(value_a_nested.c.n).cte("value_b")

value_ab = select(value_a.c.n.label("a"), value_b.c.n.label("b"))
</pre>
<p>The above query will render the second CTE nested inside the first,
shown with inline parameters below as:</p>
<pre class="rst-literal-block">
WITH
    value_a AS
        (SELECT 'root' AS n),
    value_b AS
        (WITH value_a AS
            (SELECT 'nesting' AS n)
        SELECT value_a.n AS n FROM value_a)
SELECT value_a.n AS a, value_b.n AS b
FROM value_a, value_b
</pre>
<p>Example 5, Non-Linear CTE (SQLAlchemy 1.4.28 and above):</p>
<pre class="rst-literal-block">
edge = Table(
    "edge",
    metadata,
    Column("id", Integer, primary_key=True),
    Column("left", Integer),
    Column("right", Integer),
)

root_node = select(literal(1).label("node")).cte(
    "nodes", recursive=True
)

left_edge = select(edge.c.left).join(
    root_node, edge.c.right == root_node.c.node
)
right_edge = select(edge.c.right).join(
    root_node, edge.c.left == root_node.c.node
)

subgraph_cte = root_node.union(left_edge, right_edge)

subgraph = select(subgraph_cte)
</pre>
<p>The above query will render 2 UNIONs inside the recursive CTE:</p>
<pre class="rst-literal-block">
WITH RECURSIVE nodes(node) AS (
        SELECT 1 AS node
    UNION
        SELECT edge."left" AS "left"
        FROM edge JOIN nodes ON edge."right" = nodes.node
    UNION
        SELECT edge."right" AS "right"
        FROM edge JOIN nodes ON edge."left" = nodes.node
)
SELECT nodes.node FROM nodes
</pre>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_orm.Query.cte</code> - ORM version of
<code>_expression.HasCTE.cte</code>.</p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">name</span></td><td class="fieldArgDesc">name given to the common table expression.  Like
<code>_expression.FromClause.alias</code>, the name can be left as
<tt class="rst-docutils literal">None</tt> in which case an anonymous symbol will be used at query
compile time.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">recursive</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, will render <tt class="rst-docutils literal">WITH RECURSIVE</tt>.
A recursive common table expression is intended to be used in
conjunction with UNION ALL in order to derive rows
from those already selected.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">nesting</span></td><td class="fieldArgDesc"><p>if <tt class="rst-docutils literal">True</tt>, will render the CTE locally to the
actual statement.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.24.</span></div>
</td></tr></table></div>
  </div>
</div><div class="baseclassvariable private">
  
  
  <a name="sqlalchemy.sql.selectable.HasCTE._has_ctes_traverse_internals">
    
  </a>
  <a name="_has_ctes_traverse_internals">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_has_ctes_traverse_internals</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseclassvariable private">
  
  
  <a name="sqlalchemy.sql.selectable.HasCTE._independent_ctes">
    
  </a>
  <a name="_independent_ctes">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_independent_ctes</span>: <code>tuple</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 04:41:59.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>