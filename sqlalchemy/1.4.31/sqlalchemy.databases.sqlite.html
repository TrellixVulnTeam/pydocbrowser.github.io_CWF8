<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.databases.sqlite</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.databases.html" class="internal-link" title="sqlalchemy.databases">databases</a></code><wbr></wbr>.<code><a href="sqlalchemy.databases.sqlite.html" class="internal-link" title="sqlalchemy.databases.sqlite">sqlite</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><div class="rst-section" id="rst-date-and-time-types">
<span id="rst-sqlite-datetime"></span><h2 class="heading">Date and Time Types</h2>
<p>SQLite does not have built-in DATE, TIME, or DATETIME types, and pysqlite does
not provide out of the box functionality for translating values between Python
<code>datetime</code> objects and a SQLite-supported format. SQLAlchemy's own
<code>~sqlalchemy.types.DateTime</code> and related types provide date formatting
and parsing functionality when SQLite is used. The implementation classes are
<code>_sqlite.DATETIME</code>, <code>_sqlite.DATE</code> and <code>_sqlite.TIME</code>.
These types represent dates and times as ISO formatted strings, which also
nicely support ordering. There's no reliance on typical "libc" internals for
these functions so historical dates are fully supported.</p>
<div class="rst-section" id="rst-ensuring-text-affinity">
<h3 class="heading">Ensuring Text affinity</h3>
<p>The DDL rendered for these types is the standard <tt class="rst-docutils literal">DATE</tt>, <tt class="rst-docutils literal">TIME</tt>
and <tt class="rst-docutils literal">DATETIME</tt> indicators.    However, custom storage formats can also be
applied to these types.   When the
storage format is detected as containing no alpha characters, the DDL for
these types is rendered as <tt class="rst-docutils literal">DATE_CHAR</tt>, <tt class="rst-docutils literal">TIME_CHAR</tt>, and <tt class="rst-docutils literal">DATETIME_CHAR</tt>,
so that the column continues to have textual affinity.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a class="rst-reference external" href="https://www.sqlite.org/datatype3.html#affinity" target="_top">Type Affinity</a> -
in the SQLite documentation</p>
</div>
</div>
</div>
<div class="rst-section" id="rst-sqlite-auto-incrementing-behavior">
<span id="rst-sqlite-autoincrement"></span><h2 class="heading">SQLite Auto Incrementing Behavior</h2>
<p>Background on SQLite's autoincrement is at: <a class="rst-reference external" href="https://sqlite.org/autoinc.html" target="_top">https://sqlite.org/autoinc.html</a></p>
<p>Key concepts:</p>
<ul class="rst-simple">
<li>SQLite has an implicit "auto increment" feature that takes place for any
non-composite primary-key column that is specifically created using
"INTEGER PRIMARY KEY" for the type + primary key.</li>
<li>SQLite also has an explicit "AUTOINCREMENT" keyword, that is <strong>not</strong>
equivalent to the implicit autoincrement feature; this keyword is not
recommended for general use.  SQLAlchemy does not render this keyword
unless a special SQLite-specific directive is used (see below).  However,
it still requires that the column's type is named "INTEGER".</li>
</ul>
<div class="rst-section" id="rst-using-the-autoincrement-keyword">
<h3 class="heading">Using the AUTOINCREMENT Keyword</h3>
<p>To specifically render the AUTOINCREMENT keyword on the primary key column
when rendering DDL, add the flag <tt class="rst-docutils literal">sqlite_autoincrement=True</tt> to the Table
construct:</p>
<pre class="rst-literal-block">
Table('sometable', metadata,
        Column('id', Integer, primary_key=True),
        sqlite_autoincrement=True)
</pre>
</div>
<div class="rst-section" id="rst-allowing-autoincrement-behavior-sqlalchemy-types-other-than-integer-integer">
<h3 class="heading">Allowing autoincrement behavior SQLAlchemy types other than Integer/INTEGER</h3>
<p>SQLite's typing model is based on naming conventions.  Among other things, this
means that any type name which contains the substring <tt class="rst-docutils literal">"INT"</tt> will be
determined to be of "integer affinity".  A type named <tt class="rst-docutils literal">"BIGINT"</tt>,
<tt class="rst-docutils literal">"SPECIAL_INT"</tt> or even <tt class="rst-docutils literal">"XYZINTQPR"</tt>, will be considered by SQLite to be
of "integer" affinity.  However, <strong>the SQLite autoincrement feature, whether
implicitly or explicitly enabled, requires that the name of the column's type
is exactly the string "INTEGER"</strong>.  Therefore, if an application uses a type
like <code>.BigInteger</code> for a primary key, on SQLite this type will need to
be rendered as the name <tt class="rst-docutils literal">"INTEGER"</tt> when emitting the initial <tt class="rst-docutils literal">CREATE
TABLE</tt> statement in order for the autoincrement behavior to be available.</p>
<p>One approach to achieve this is to use <code>.Integer</code> on SQLite
only using <code>.TypeEngine.with_variant</code>:</p>
<pre class="rst-literal-block">
table = Table(
    "my_table", metadata,
    Column("id", BigInteger().with_variant(Integer, "sqlite"), primary_key=True)
)
</pre>
<p>Another is to use a subclass of <code>.BigInteger</code> that overrides its DDL
name to be <tt class="rst-docutils literal">INTEGER</tt> when compiled against SQLite:</p>
<pre class="rst-literal-block">
from sqlalchemy import BigInteger
from sqlalchemy.ext.compiler import compiles

class SLBigInteger(BigInteger):
    pass

@compiles(SLBigInteger, 'sqlite')
def bi_c(element, compiler, **kw):
    return "INTEGER"

@compiles(SLBigInteger)
def bi_c(element, compiler, **kw):
    return compiler.visit_BIGINT(element, **kw)


table = Table(
    "my_table", metadata,
    Column("id", SLBigInteger(), primary_key=True)
)
</pre>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><code>.TypeEngine.with_variant</code></p>
<p><a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`sqlalchemy.ext.compiler_toplevel`</span></a></p>
<p class="rst-last"><a class="rst-reference external" href="https://sqlite.org/datatype3.html" target="_top">Datatypes In SQLite Version 3</a></p>
</div>
</div>
</div>
<div class="rst-section" id="rst-database-locking-behavior-concurrency">
<span id="rst-sqlite-concurrency"></span><h2 class="heading">Database Locking Behavior / Concurrency</h2>
<p>SQLite is not designed for a high level of write concurrency. The database
itself, being a file, is locked completely during write operations within
transactions, meaning exactly one "connection" (in reality a file handle)
has exclusive access to the database during this period - all other
"connections" will be blocked during this time.</p>
<p>The Python DBAPI specification also calls for a connection model that is
always in a transaction; there is no <tt class="rst-docutils literal">connection.begin()</tt> method,
only <tt class="rst-docutils literal">connection.commit()</tt> and <tt class="rst-docutils literal">connection.rollback()</tt>, upon which a
new transaction is to be begun immediately.  This may seem to imply
that the SQLite driver would in theory allow only a single filehandle on a
particular database file at any time; however, there are several
factors both within SQLite itself as well as within the pysqlite driver
which loosen this restriction significantly.</p>
<p>However, no matter what locking modes are used, SQLite will still always
lock the database file once a transaction is started and DML (e.g. INSERT,
UPDATE, DELETE) has at least been emitted, and this will block
other transactions at least at the point that they also attempt to emit DML.
By default, the length of time on this block is very short before it times out
with an error.</p>
<p>This behavior becomes more critical when used in conjunction with the
SQLAlchemy ORM.  SQLAlchemy's <code>.Session</code> object by default runs
within a transaction, and with its autoflush model, may emit DML preceding
any SELECT statement.   This may lead to a SQLite database that locks
more quickly than is expected.   The locking mode of SQLite and the pysqlite
driver can be manipulated to some degree, however it should be noted that
achieving a high degree of write-concurrency with SQLite is a losing battle.</p>
<p>For more information on SQLite's lack of write concurrency by design, please
see
<a class="rst-reference external" href="https://www.sqlite.org/whentouse.html" target="_top">Situations Where Another RDBMS May Work Better - High Concurrency</a> near the bottom of the page.</p>
<p>The following subsections introduce areas that are impacted by SQLite's
file-based architecture and additionally will usually require workarounds to
work when using the pysqlite driver.</p>
</div>
<div class="rst-section" id="rst-transaction-isolation-level-autocommit">
<span id="rst-sqlite-isolation-level"></span><h2 class="heading">Transaction Isolation Level / Autocommit</h2>
<p>SQLite supports "transaction isolation" in a non-standard way, along two
axes.  One is that of the
<a class="rst-reference external" href="https://www.sqlite.org/pragma.html#pragma_read_uncommitted" target="_top">PRAGMA read_uncommitted</a>
instruction.   This setting can essentially switch SQLite between its
default mode of <tt class="rst-docutils literal">SERIALIZABLE</tt> isolation, and a "dirty read" isolation
mode normally referred to as <tt class="rst-docutils literal">READ UNCOMMITTED</tt>.</p>
<p>SQLAlchemy ties into this PRAGMA statement using the
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`_sa.create_engine.isolation_level`</span></a> parameter of
<code>_sa.create_engine</code>.
Valid values for this parameter when used with SQLite are <tt class="rst-docutils literal">"SERIALIZABLE"</tt>
and <tt class="rst-docutils literal">"READ UNCOMMITTED"</tt> corresponding to a value of 0 and 1, respectively.
SQLite defaults to <tt class="rst-docutils literal">SERIALIZABLE</tt>, however its behavior is impacted by
the pysqlite driver's default behavior.</p>
<p>When using the pysqlite driver, the <tt class="rst-docutils literal">"AUTOCOMMIT"</tt> isolation level is also
available, which will alter the pysqlite connection using the <tt class="rst-docutils literal">.isolation_level</tt>
attribute on the DBAPI connection and set it to None for the duration
of the setting.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.3.16: </span><span>added support for SQLite AUTOCOMMIT isolation level
when using the pysqlite / sqlite3 SQLite driver.</span></div>
<p>The other axis along which SQLite's transactional locking is impacted is
via the nature of the <tt class="rst-docutils literal">BEGIN</tt> statement used.   The three varieties
are "deferred", "immediate", and "exclusive", as described at
<a class="rst-reference external" href="https://sqlite.org/lang_transaction.html" target="_top">BEGIN TRANSACTION</a>.   A straight
<tt class="rst-docutils literal">BEGIN</tt> statement uses the "deferred" mode, where the database file is
not locked until the first read or write operation, and read access remains
open to other transactions until the first write operation.  But again,
it is critical to note that the pysqlite driver interferes with this behavior
by <em>not even emitting BEGIN</em> until the first write operation.</p>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p class="rst-last">SQLite's transactional scope is impacted by unresolved
issues in the pysqlite driver, which defers BEGIN statements to a greater
degree than is often feasible. See the section <a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:ref:`pysqlite_serializable`</span></a>
for techniques to work around this behavior.</p>
</div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:ref:`dbapi_autocommit`</span></a></p>
</div>
</div>
<div class="rst-section" id="rst-savepoint-support">
<h2 class="heading">SAVEPOINT Support</h2>
<p>SQLite supports SAVEPOINTs, which only function once a transaction is
begun.   SQLAlchemy's SAVEPOINT support is available using the
<code>_engine.Connection.begin_nested</code> method at the Core level, and
<code>.Session.begin_nested</code> at the ORM level.   However, SAVEPOINTs
won't work at all with pysqlite unless workarounds are taken.</p>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p class="rst-last">SQLite's SAVEPOINT feature is impacted by unresolved
issues in the pysqlite driver, which defers BEGIN statements to a greater
degree than is often feasible. See the section <a href="#system-message-5"><span class="rst-problematic" id="rst-problematic-5">:ref:`pysqlite_serializable`</span></a>
for techniques to work around this behavior.</p>
</div>
</div>
<div class="rst-section" id="rst-transactional-ddl">
<h2 class="heading">Transactional DDL</h2>
<p>The SQLite database supports transactional <a href="#system-message-6"><span class="rst-problematic" id="rst-problematic-6">:term:`DDL`</span></a> as well.
In this case, the pysqlite driver is not only failing to start transactions,
it also is ending any existing transaction when DDL is detected, so again,
workarounds are required.</p>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p class="rst-last">SQLite's transactional DDL is impacted by unresolved issues
in the pysqlite driver, which fails to emit BEGIN and additionally
forces a COMMIT to cancel any transaction when DDL is encountered.
See the section <a href="#system-message-7"><span class="rst-problematic" id="rst-problematic-7">:ref:`pysqlite_serializable`</span></a>
for techniques to work around this behavior.</p>
</div>
</div>
<div class="rst-section" id="rst-foreign-key-support">
<span id="rst-sqlite-foreign-keys"></span><h2 class="heading">Foreign Key Support</h2>
<p>SQLite supports FOREIGN KEY syntax when emitting CREATE statements for tables,
however by default these constraints have no effect on the operation of the
table.</p>
<p>Constraint checking on SQLite has three prerequisites:</p>
<ul class="rst-simple">
<li>At least version 3.6.19 of SQLite must be in use</li>
<li>The SQLite library must be compiled <em>without</em> the SQLITE_OMIT_FOREIGN_KEY
or SQLITE_OMIT_TRIGGER symbols enabled.</li>
<li>The <tt class="rst-docutils literal">PRAGMA foreign_keys = ON</tt> statement must be emitted on all
connections before use -- including the initial call to
<code><a href="sqlalchemy.sql.schema.MetaData.html#create_all" class="internal-link" title="sqlalchemy.sql.schema.MetaData.create_all">sqlalchemy.schema.MetaData.create_all</a></code>.</li>
</ul>
<p>SQLAlchemy allows for the <tt class="rst-docutils literal">PRAGMA</tt> statement to be emitted automatically for
new connections through the usage of events:</p>
<pre class="rst-literal-block">
from sqlalchemy.engine import Engine
from sqlalchemy import event

@event.listens_for(Engine, "connect")
def set_sqlite_pragma(dbapi_connection, connection_record):
    cursor = dbapi_connection.cursor()
    cursor.execute("PRAGMA foreign_keys=ON")
    cursor.close()
</pre>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p class="rst-last">When SQLite foreign keys are enabled, it is <strong>not possible</strong>
to emit CREATE or DROP statements for tables that contain
mutually-dependent foreign key constraints;
to emit the DDL for these tables requires that ALTER TABLE be used to
create or drop these constraints separately, for which SQLite has
no support.</p>
</div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a class="rst-reference external" href="https://www.sqlite.org/foreignkeys.html" target="_top">SQLite Foreign Key Support</a>
- on the SQLite web site.</p>
<p><a href="#system-message-8"><span class="rst-problematic" id="rst-problematic-8">:ref:`event_toplevel`</span></a> - SQLAlchemy event API.</p>
<dl class="rst-last rst-docutils">
<dt><a href="#system-message-9"><span class="rst-problematic" id="rst-problematic-9">:ref:`use_alter`</span></a> - more information on SQLAlchemy's facilities for handling</dt>
<dd>mutually-dependent foreign key constraints.</dd>
</dl>
</div>
</div>
<div class="rst-section" id="rst-on-conflict-support-for-constraints">
<span id="rst-sqlite-on-conflict-ddl"></span><h2 class="heading">ON CONFLICT support for constraints</h2>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last">This section describes the <a href="#system-message-10"><span class="rst-problematic" id="rst-problematic-10">:term:`DDL`</span></a> version of "ON CONFLICT" for
SQLite, which occurs within a CREATE TABLE statement.  For "ON CONFLICT" as
applied to an INSERT statement, see <a href="#system-message-11"><span class="rst-problematic" id="rst-problematic-11">:ref:`sqlite_on_conflict_insert`</span></a>.</p>
</div>
<p>SQLite supports a non-standard DDL clause known as ON CONFLICT which can be applied
to primary key, unique, check, and not null constraints.   In DDL, it is
rendered either within the "CONSTRAINT" clause or within the column definition
itself depending on the location of the target constraint.    To render this
clause within DDL, the extension parameter <tt class="rst-docutils literal">sqlite_on_conflict</tt> can be
specified with a string conflict resolution algorithm within the
<code>.PrimaryKeyConstraint</code>, <code>.UniqueConstraint</code>,
<code>.CheckConstraint</code> objects.  Within the <code>_schema.Column</code> object,
there
are individual parameters <tt class="rst-docutils literal">sqlite_on_conflict_not_null</tt>,
<tt class="rst-docutils literal">sqlite_on_conflict_primary_key</tt>, <tt class="rst-docutils literal">sqlite_on_conflict_unique</tt> which each
correspond to the three types of relevant constraint types that can be
indicated from a <code>_schema.Column</code> object.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a class="rst-reference external" href="https://www.sqlite.org/lang_conflict.html" target="_top">ON CONFLICT</a> - in the SQLite
documentation</p>
</div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.3.</span></div>
<p>The <tt class="rst-docutils literal">sqlite_on_conflict</tt> parameters accept a  string argument which is just
the resolution name to be chosen, which on SQLite can be one of ROLLBACK,
ABORT, FAIL, IGNORE, and REPLACE.   For example, to add a UNIQUE constraint
that specifies the IGNORE algorithm:</p>
<pre class="rst-literal-block">
some_table = Table(
    'some_table', metadata,
    Column('id', Integer, primary_key=True),
    Column('data', Integer),
    UniqueConstraint('id', 'data', sqlite_on_conflict='IGNORE')
)
</pre>
<p>The above renders CREATE TABLE DDL as:</p>
<pre class="rst-literal-block">
CREATE TABLE some_table (
    id INTEGER NOT NULL,
    data INTEGER,
    PRIMARY KEY (id),
    UNIQUE (id, data) ON CONFLICT IGNORE
)
</pre>
<p>When using the <a href="#system-message-12"><span class="rst-problematic" id="rst-problematic-12">:paramref:`_schema.Column.unique`</span></a>
flag to add a UNIQUE constraint
to a single column, the <tt class="rst-docutils literal">sqlite_on_conflict_unique</tt> parameter can
be added to the <code>_schema.Column</code> as well, which will be added to the
UNIQUE constraint in the DDL:</p>
<pre class="rst-literal-block">
some_table = Table(
    'some_table', metadata,
    Column('id', Integer, primary_key=True),
    Column('data', Integer, unique=True,
           sqlite_on_conflict_unique='IGNORE')
)
</pre>
<p>rendering:</p>
<pre class="rst-literal-block">
CREATE TABLE some_table (
    id INTEGER NOT NULL,
    data INTEGER,
    PRIMARY KEY (id),
    UNIQUE (data) ON CONFLICT IGNORE
)
</pre>
<p>To apply the FAIL algorithm for a NOT NULL constraint,
<tt class="rst-docutils literal">sqlite_on_conflict_not_null</tt> is used:</p>
<pre class="rst-literal-block">
some_table = Table(
    'some_table', metadata,
    Column('id', Integer, primary_key=True),
    Column('data', Integer, nullable=False,
           sqlite_on_conflict_not_null='FAIL')
)
</pre>
<p>this renders the column inline ON CONFLICT phrase:</p>
<pre class="rst-literal-block">
CREATE TABLE some_table (
    id INTEGER NOT NULL,
    data INTEGER NOT NULL ON CONFLICT FAIL,
    PRIMARY KEY (id)
)
</pre>
<p>Similarly, for an inline primary key, use <tt class="rst-docutils literal">sqlite_on_conflict_primary_key</tt>:</p>
<pre class="rst-literal-block">
some_table = Table(
    'some_table', metadata,
    Column('id', Integer, primary_key=True,
           sqlite_on_conflict_primary_key='FAIL')
)
</pre>
<p>SQLAlchemy renders the PRIMARY KEY constraint separately, so the conflict
resolution algorithm is applied to the constraint itself:</p>
<pre class="rst-literal-block">
CREATE TABLE some_table (
    id INTEGER NOT NULL,
    PRIMARY KEY (id) ON CONFLICT FAIL
)
</pre>
</div>
<div class="rst-section" id="rst-insert-on-conflict-upsert">
<span id="rst-sqlite-on-conflict-insert"></span><h2 class="heading">INSERT...ON CONFLICT (Upsert)</h2>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last">This section describes the <a href="#system-message-13"><span class="rst-problematic" id="rst-problematic-13">:term:`DML`</span></a> version of "ON CONFLICT" for
SQLite, which occurs within an INSERT statement.  For "ON CONFLICT" as
applied to a CREATE TABLE statement, see <a href="#system-message-14"><span class="rst-problematic" id="rst-problematic-14">:ref:`sqlite_on_conflict_ddl`</span></a>.</p>
</div>
<p>From version 3.24.0 onwards, SQLite supports "upserts" (update or insert)
of rows into a table via the <tt class="rst-docutils literal">ON CONFLICT</tt> clause of the <tt class="rst-docutils literal">INSERT</tt>
statement. A candidate row will only be inserted if that row does not violate
any unique or primary key constraints. In the case of a unique constraint violation, a
secondary action can occur which can be either "DO UPDATE", indicating that
the data in the target row should be updated, or "DO NOTHING", which indicates
to silently skip this row.</p>
<p>Conflicts are determined using columns that are part of existing unique
constraints and indexes.  These constraints are identified by stating the
columns and conditions that comprise the indexes.</p>
<p>SQLAlchemy provides <tt class="rst-docutils literal">ON CONFLICT</tt> support via the SQLite-specific
<code>_sqlite.insert()</code> function, which provides
the generative methods <code>_sqlite.Insert.on_conflict_do_update</code>
and <code>_sqlite.Insert.on_conflict_do_nothing</code>:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; from sqlalchemy.dialects.sqlite import insert

&gt;&gt;&gt; insert_stmt = insert(my_table).values(
...     id='some_existing_id',
...     data='inserted value')

&gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update(
...     index_elements=['id'],
...     set_=dict(data='updated value')
... )

&gt;&gt;&gt; print(do_update_stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (?, ?)
ON CONFLICT (id) DO UPDATE SET data = ?{stop}

&gt;&gt;&gt; do_nothing_stmt = insert_stmt.on_conflict_do_nothing(
...     index_elements=['id']
... )

&gt;&gt;&gt; print(do_nothing_stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (?, ?)
ON CONFLICT (id) DO NOTHING
</pre>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a class="rst-reference external" href="https://sqlite.org/lang_UPSERT.html" target="_top">Upsert</a>
- in the SQLite documentation.</p>
</div>
<div class="rst-section" id="rst-specifying-the-target">
<h3 class="heading">Specifying the Target</h3>
<p>Both methods supply the "target" of the conflict using column inference:</p>
<ul>
<li><p class="rst-first">The <a href="#system-message-15"><span class="rst-problematic" id="rst-problematic-15">:paramref:`_sqlite.Insert.on_conflict_do_update.index_elements`</span></a> argument
specifies a sequence containing string column names, <code>_schema.Column</code>
objects, and/or SQL expression elements, which would identify a unique index
or unique constraint.</p>
</li>
<li><p class="rst-first">When using <a href="#system-message-16"><span class="rst-problematic" id="rst-problematic-16">:paramref:`_sqlite.Insert.on_conflict_do_update.index_elements`</span></a>
to infer an index, a partial index can be inferred by also specifying the
<a href="#system-message-17"><span class="rst-problematic" id="rst-problematic-17">:paramref:`_sqlite.Insert.on_conflict_do_update.index_where`</span></a> parameter:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; stmt = insert(my_table).values(user_email='a@b.com', data='inserted data')

&gt;&gt;&gt; do_update_stmt = stmt.on_conflict_do_update(
...     index_elements=[my_table.c.user_email],
...     index_where=my_table.c.user_email.like('%@gmail.com'),
...     set_=dict(data=stmt.excluded.data)
...     )

&gt;&gt;&gt; print(do_update_stmt)
{opensql}INSERT INTO my_table (data, user_email) VALUES (?, ?)
ON CONFLICT (user_email)
WHERE user_email LIKE '%@gmail.com'
DO UPDATE SET data = excluded.data
&gt;&gt;&gt;
</pre>
</li>
</ul>
</div>
<div class="rst-section" id="rst-the-set-clause">
<h3 class="heading">The SET Clause</h3>
<p><tt class="rst-docutils literal">ON <span class="pre">CONFLICT...DO</span> UPDATE</tt> is used to perform an update of the already
existing row, using any combination of new values as well as values
from the proposed insertion. These values are specified using the
<a href="#system-message-18"><span class="rst-problematic" id="rst-problematic-18">:paramref:`_sqlite.Insert.on_conflict_do_update.set_`</span></a> parameter.  This
parameter accepts a dictionary which consists of direct values
for UPDATE:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; stmt = insert(my_table).values(id='some_id', data='inserted value')

&gt;&gt;&gt; do_update_stmt = stmt.on_conflict_do_update(
...     index_elements=['id'],
...     set_=dict(data='updated value')
... )

&gt;&gt;&gt; print(do_update_stmt)

{opensql}INSERT INTO my_table (id, data) VALUES (?, ?)
ON CONFLICT (id) DO UPDATE SET data = ?
</pre>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p class="rst-last">The <code>_sqlite.Insert.on_conflict_do_update</code> method does <strong>not</strong> take
into account Python-side default UPDATE values or generation functions,
e.g. those specified using <a href="#system-message-19"><span class="rst-problematic" id="rst-problematic-19">:paramref:`_schema.Column.onupdate`</span></a>. These
values will not be exercised for an ON CONFLICT style of UPDATE, unless
they are manually specified in the
<a href="#system-message-20"><span class="rst-problematic" id="rst-problematic-20">:paramref:`_sqlite.Insert.on_conflict_do_update.set_`</span></a> dictionary.</p>
</div>
</div>
<div class="rst-section" id="rst-updating-using-the-excluded-insert-values">
<h3 class="heading">Updating using the Excluded INSERT Values</h3>
<p>In order to refer to the proposed insertion row, the special alias
<code>~.sqlite.Insert.excluded</code> is available as an attribute on
the <code>_sqlite.Insert</code> object; this object creates an "excluded." prefix
on a column, that informs the DO UPDATE to update the row with the value that
would have been inserted had the constraint not failed:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; stmt = insert(my_table).values(
...     id='some_id',
...     data='inserted value',
...     author='jlh'
... )

&gt;&gt;&gt; do_update_stmt = stmt.on_conflict_do_update(
...     index_elements=['id'],
...     set_=dict(data='updated value', author=stmt.excluded.author)
... )

&gt;&gt;&gt; print(do_update_stmt)
{opensql}INSERT INTO my_table (id, data, author) VALUES (?, ?, ?)
ON CONFLICT (id) DO UPDATE SET data = ?, author = excluded.author
</pre>
</div>
<div class="rst-section" id="rst-additional-where-criteria">
<h3 class="heading">Additional WHERE Criteria</h3>
<p>The <code>_sqlite.Insert.on_conflict_do_update</code> method also accepts
a WHERE clause using the <a href="#system-message-21"><span class="rst-problematic" id="rst-problematic-21">:paramref:`_sqlite.Insert.on_conflict_do_update.where`</span></a>
parameter, which will limit those rows which receive an UPDATE:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; stmt = insert(my_table).values(
...     id='some_id',
...     data='inserted value',
...     author='jlh'
... )

&gt;&gt;&gt; on_update_stmt = stmt.on_conflict_do_update(
...     index_elements=['id'],
...     set_=dict(data='updated value', author=stmt.excluded.author),
...     where=(my_table.c.status == 2)
... )
&gt;&gt;&gt; print(on_update_stmt)
{opensql}INSERT INTO my_table (id, data, author) VALUES (?, ?, ?)
ON CONFLICT (id) DO UPDATE SET data = ?, author = excluded.author
WHERE my_table.status = ?
</pre>
</div>
<div class="rst-section" id="rst-skipping-rows-with-do-nothing">
<h3 class="heading">Skipping Rows with DO NOTHING</h3>
<p><tt class="rst-docutils literal">ON CONFLICT</tt> may be used to skip inserting a row entirely
if any conflict with a unique constraint occurs; below this is illustrated
using the <code>_sqlite.Insert.on_conflict_do_nothing</code> method:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; stmt = insert(my_table).values(id='some_id', data='inserted value')
&gt;&gt;&gt; stmt = stmt.on_conflict_do_nothing(index_elements=['id'])
&gt;&gt;&gt; print(stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (?, ?) ON CONFLICT (id) DO NOTHING
</pre>
<p>If <tt class="rst-docutils literal">DO NOTHING</tt> is used without specifying any columns or constraint,
it has the effect of skipping the INSERT for any unique violation which
occurs:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; stmt = insert(my_table).values(id='some_id', data='inserted value')
&gt;&gt;&gt; stmt = stmt.on_conflict_do_nothing()
&gt;&gt;&gt; print(stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (?, ?) ON CONFLICT DO NOTHING
</pre>
</div>
</div>
<div class="rst-section" id="rst-type-reflection">
<span id="rst-sqlite-type-reflection"></span><h2 class="heading">Type Reflection</h2>
<p>SQLite types are unlike those of most other database backends, in that
the string name of the type usually does not correspond to a "type" in a
one-to-one fashion.  Instead, SQLite links per-column typing behavior
to one of five so-called "type affinities" based on a string matching
pattern for the type.</p>
<p>SQLAlchemy's reflection process, when inspecting types, uses a simple
lookup table to link the keywords returned to provided SQLAlchemy types.
This lookup table is present within the SQLite dialect as it is for all
other dialects.  However, the SQLite dialect has a different "fallback"
routine for when a particular type name is not located in the lookup map;
it instead implements the SQLite "type affinity" scheme located at
<a class="rst-reference external" href="https://www.sqlite.org/datatype3.html" target="_top">https://www.sqlite.org/datatype3.html</a> section 2.1.</p>
<p>The provided typemap will make direct associations from an exact string
name match for the following types:</p>
<p><code>_types.BIGINT</code>, <code>_types.BLOB</code>,
<code>_types.BOOLEAN</code>, <code>_types.BOOLEAN</code>,
<code>_types.CHAR</code>, <code>_types.DATE</code>,
<code>_types.DATETIME</code>, <code>_types.FLOAT</code>,
<code>_types.DECIMAL</code>, <code>_types.FLOAT</code>,
<code>_types.INTEGER</code>, <code>_types.INTEGER</code>,
<code>_types.NUMERIC</code>, <code>_types.REAL</code>,
<code>_types.SMALLINT</code>, <code>_types.TEXT</code>,
<code>_types.TIME</code>, <code>_types.TIMESTAMP</code>,
<code>_types.VARCHAR</code>, <code>_types.NVARCHAR</code>,
<code>_types.NCHAR</code></p>
<p>When a type name does not match one of the above types, the "type affinity"
lookup is used instead:</p>
<ul class="rst-simple">
<li><code>_types.INTEGER</code> is returned if the type name includes the
string <tt class="rst-docutils literal">INT</tt></li>
<li><code>_types.TEXT</code> is returned if the type name includes the
string <tt class="rst-docutils literal">CHAR</tt>, <tt class="rst-docutils literal">CLOB</tt> or <tt class="rst-docutils literal">TEXT</tt></li>
<li><code>_types.NullType</code> is returned if the type name includes the
string <tt class="rst-docutils literal">BLOB</tt></li>
<li><code>_types.REAL</code> is returned if the type name includes the string
<tt class="rst-docutils literal">REAL</tt>, <tt class="rst-docutils literal">FLOA</tt> or <tt class="rst-docutils literal">DOUB</tt>.</li>
<li>Otherwise, the <code>_types.NUMERIC</code> type is used.</li>
</ul>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.9.3: </span><span>Support for SQLite type affinity rules when reflecting
columns.</span></div>
</div>
<div class="rst-section" id="rst-partial-indexes">
<span id="rst-sqlite-partial-index"></span><h2 class="heading">Partial Indexes</h2>
<p>A partial index, e.g. one which uses a WHERE clause, can be specified
with the DDL system using the argument <tt class="rst-docutils literal">sqlite_where</tt>:</p>
<pre class="rst-literal-block">
tbl = Table('testtbl', m, Column('data', Integer))
idx = Index('test_idx1', tbl.c.data,
            sqlite_where=and_(tbl.c.data &gt; 5, tbl.c.data &lt; 10))
</pre>
<p>The index will be rendered at create time as:</p>
<pre class="rst-literal-block">
CREATE INDEX test_idx1 ON testtbl (data)
WHERE data &gt; 5 AND data &lt; 10
</pre>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.9.9.</span></div>
</div>
<div class="rst-section" id="rst-dotted-column-names">
<span id="rst-sqlite-dotted-column-names"></span><h2 class="heading">Dotted Column Names</h2>
<p>Using table or column names that explicitly have periods in them is
<strong>not recommended</strong>.   While this is generally a bad idea for relational
databases in general, as the dot is a syntactically significant character,
the SQLite driver up until version <strong>3.10.0</strong> of SQLite has a bug which
requires that SQLAlchemy filter out these dots in result sets.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.1: </span><span>The following SQLite issue has been resolved as of version 3.10.0
of SQLite.  SQLAlchemy as of <strong>1.1</strong> automatically disables its internal
workarounds based on detection of this version.</span></div>
<p>The bug, entirely outside of SQLAlchemy, can be illustrated thusly:</p>
<pre class="rst-literal-block">
import sqlite3

assert sqlite3.sqlite_version_info &lt; (3, 10, 0), "bug is fixed in this version"

conn = sqlite3.connect(":memory:")
cursor = conn.cursor()

cursor.execute("create table x (a integer, b integer)")
cursor.execute("insert into x (a, b) values (1, 1)")
cursor.execute("insert into x (a, b) values (2, 2)")

cursor.execute("select x.a, x.b from x")
assert [c[0] for c in cursor.description] == ['a', 'b']

cursor.execute('''
    select x.a, x.b from x where a=1
    union
    select x.a, x.b from x where a=2
''')
assert [c[0] for c in cursor.description] == ['a', 'b'], \
    [c[0] for c in cursor.description]
</pre>
<p>The second assertion fails:</p>
<pre class="rst-literal-block">
Traceback (most recent call last):
  File "test.py", line 19, in &lt;module&gt;
    [c[0] for c in cursor.description]
AssertionError: ['x.a', 'x.b']
</pre>
<p>Where above, the driver incorrectly reports the names of the columns
including the name of the table, which is entirely inconsistent vs.
when the UNION is not present.</p>
<p>SQLAlchemy relies upon column names being predictable in how they match
to the original statement, so the SQLAlchemy dialect has no choice but
to filter these out:</p>
<pre class="rst-literal-block">
from sqlalchemy import create_engine

eng = create_engine("sqlite://")
conn = eng.connect()

conn.exec_driver_sql("create table x (a integer, b integer)")
conn.exec_driver_sql("insert into x (a, b) values (1, 1)")
conn.exec_driver_sql("insert into x (a, b) values (2, 2)")

result = conn.exec_driver_sql("select x.a, x.b from x")
assert result.keys() == ["a", "b"]

result = conn.exec_driver_sql('''
    select x.a, x.b from x where a=1
    union
    select x.a, x.b from x where a=2
''')
assert result.keys() == ["a", "b"]
</pre>
<p>Note that above, even though SQLAlchemy filters out the dots, <em>both
names are still addressable</em>:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; row = result.first()
&gt;&gt;&gt; row["a"]
1
&gt;&gt;&gt; row["x.a"]
1
&gt;&gt;&gt; row["b"]
1
&gt;&gt;&gt; row["x.b"]
1
</pre>
<p>Therefore, the workaround applied by SQLAlchemy only impacts
<code>_engine.CursorResult.keys</code> and <code>.Row.keys()</code> in the public API. In
the very specific case where an application is forced to use column names that
contain dots, and the functionality of <code>_engine.CursorResult.keys</code> and
<code>.Row.keys()</code> is required to return these dotted names unmodified,
the <tt class="rst-docutils literal">sqlite_raw_colnames</tt> execution option may be provided, either on a
per-<code>_engine.Connection</code> basis:</p>
<pre class="rst-literal-block">
result = conn.execution_options(sqlite_raw_colnames=True).exec_driver_sql('''
    select x.a, x.b from x where a=1
    union
    select x.a, x.b from x where a=2
''')
assert result.keys() == ["x.a", "x.b"]
</pre>
<p>or on a per-<code>_engine.Engine</code> basis:</p>
<pre class="rst-literal-block">
engine = create_engine("sqlite://", execution_options={"sqlite_raw_colnames": True})
</pre>
<p>When using the per-<code>_engine.Engine</code> execution option, note that
<strong>Core and ORM queries that use UNION may not function properly</strong>.</p>
</div>
<div class="rst-section" id="rst-sqlite-specific-table-options">
<h2 class="heading">SQLite-specific table options</h2>
<p>One option for CREATE TABLE is supported directly by the SQLite
dialect in conjunction with the <code>_schema.Table</code> construct:</p>
<ul>
<li><p class="rst-first"><tt class="rst-docutils literal">WITHOUT ROWID</tt>:</p>
<pre class="rst-literal-block">
Table("some_table", metadata, ..., sqlite_with_rowid=False)
</pre>
</li>
</ul>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a class="rst-reference external" href="https://www.sqlite.org/lang_createtable.html" target="_top">SQLite CREATE TABLE options</a></p>
</div>
</div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id14362">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.sqlite.SQLiteCompiler.html" class="internal-link" title="sqlalchemy.databases.sqlite.SQLiteCompiler">​SQLite​Compiler</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.sqlite.SQLiteDDLCompiler.html" class="internal-link" title="sqlalchemy.databases.sqlite.SQLiteDDLCompiler">​SQLite​DDLCompiler</a></code></td>
    <td><span class="undocumented">No class docstring; 1/9 method documented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.sqlite.SQLiteDialect.html" class="internal-link" title="sqlalchemy.databases.sqlite.SQLiteDialect">​SQLite​Dialect</a></code></td>
    <td><span class="undocumented">No class docstring; 0/9 instance variable, 0/11 class variable, 1/23 method documented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.sqlite.SQLiteExecutionContext.html" class="internal-link" title="sqlalchemy.databases.sqlite.SQLiteExecutionContext">​SQLite​Execution​Context</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.sqlite.SQLiteIdentifierPreparer.html" class="internal-link" title="sqlalchemy.databases.sqlite.SQLiteIdentifierPreparer">​SQLite​Identifier​Preparer</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.sqlite.SQLiteTypeCompiler.html" class="internal-link" title="sqlalchemy.databases.sqlite.SQLiteTypeCompiler">​SQLite​Type​Compiler</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><code><a href="#colspecs" class="internal-link" title="sqlalchemy.databases.sqlite.colspecs">colspecs</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><code><a href="#ischema_names" class="internal-link" title="sqlalchemy.databases.sqlite.ischema_names">ischema​_names</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.sqlite._DateTimeMixin.html" class="internal-link" title="sqlalchemy.databases.sqlite._DateTimeMixin">_​Date​Time​Mixin</a></code></td>
    <td><span class="undocumented">No class docstring; 1/1 property, 0/2 instance variable, 0/3 method documented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.sqlite._SQliteJson.html" class="internal-link" title="sqlalchemy.databases.sqlite._SQliteJson">_​SQlite​Json</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basevariable">
  
  
  <a name="sqlalchemy.databases.sqlite.colspecs">
    
  </a>
  <a name="colspecs">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">colspecs</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="basevariable">
  
  
  <a name="sqlalchemy.databases.sqlite.ischema_names">
    
  </a>
  <a name="ischema_names">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">ischema_names</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 04:41:59.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>