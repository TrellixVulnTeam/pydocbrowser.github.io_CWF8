<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.databases.postgresql</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    <div id="banner" class="container">    
    <div>
        <a href="https://pydocbrowser.github.io/">Home</a>
        &gt; sqlalchemy-1.4.31 
        <!-- This is an important placeholder and will be 
            replaced by project name and version on building docs -->
        
        <!-- (<a href=""&gt;show all versions</a&gt;) -->
    </div>
</div>

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.databases.html" class="internal-link" title="sqlalchemy.databases">databases</a></code><wbr></wbr>.<code><a href="sqlalchemy.databases.postgresql.html" class="internal-link" title="sqlalchemy.databases.postgresql">postgresql</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        <a href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/dialects/postgresql/base.py" class="sourceLink">(source)</a>
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><div class="rst-section" id="rst-sequences-serial-identity">
<span id="rst-postgresql-sequences"></span><h2 class="heading">Sequences/SERIAL/IDENTITY</h2>
<p>PostgreSQL supports sequences, and SQLAlchemy uses these as the default means
of creating new primary key values for integer-based primary key columns. When
creating tables, SQLAlchemy will issue the <tt class="rst-docutils literal">SERIAL</tt> datatype for
integer-based primary key columns, which generates a sequence and server side
default corresponding to the column.</p>
<p>To specify a specific named sequence to be used for primary key generation,
use the <code>~sqlalchemy.schema.Sequence</code> construct:</p>
<pre class="rst-literal-block">
Table('sometable', metadata,
        Column('id', Integer, Sequence('some_id_seq'), primary_key=True)
    )
</pre>
<p>When SQLAlchemy issues a single INSERT statement, to fulfill the contract of
having the "last insert identifier" available, a RETURNING clause is added to
the INSERT statement which specifies the primary key columns should be
returned after the statement completes. The RETURNING functionality only takes
place if PostgreSQL 8.2 or later is in use. As a fallback approach, the
sequence, whether specified explicitly or implicitly via <tt class="rst-docutils literal">SERIAL</tt>, is
executed independently beforehand, the returned value to be used in the
subsequent insert. Note that when an
<code>~sqlalchemy.sql.expression.insert()</code> construct is executed using
"executemany" semantics, the "last inserted identifier" functionality does not
apply; no RETURNING clause is emitted nor is the sequence pre-executed in this
case.</p>
<p>To force the usage of RETURNING by default off, specify the flag
<tt class="rst-docutils literal">implicit_returning=False</tt> to <code>_sa.create_engine</code>.</p>
<div class="rst-section" id="rst-postgresql-10-and-above-identity-columns">
<h3 class="heading">PostgreSQL 10 and above IDENTITY columns</h3>
<p>PostgreSQL 10 and above have a new IDENTITY feature that supersedes the use
of SERIAL. The <code>_schema.Identity</code> construct in a
<code>_schema.Column</code> can be used to control its behavior:</p>
<pre class="rst-literal-block">
from sqlalchemy import Table, Column, MetaData, Integer, Computed

metadata = MetaData()

data = Table(
    "data",
    metadata,
    Column(
        'id', Integer, Identity(start=42, cycle=True), primary_key=True
    ),
    Column('data', String)
)
</pre>
<p>The CREATE TABLE for the above <code>_schema.Table</code> object would be:</p>
<pre class="rst-code rst-sql rst-literal-block">
CREATE TABLE data (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 42 CYCLE),
    data VARCHAR,
    PRIMARY KEY (id)
)
</pre>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>Added <code>_schema.Identity</code> construct
in a <code>_schema.Column</code> to specify the option of an autoincrementing
column.</span></div>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p>Previous versions of SQLAlchemy did not have built-in support for rendering
of IDENTITY, and could use the following compilation hook to replace
occurrences of SERIAL with IDENTITY:</p>
<pre class="rst-literal-block">
from sqlalchemy.schema import CreateColumn
from sqlalchemy.ext.compiler import compiles


@compiles(CreateColumn, 'postgresql')
def use_identity(element, compiler, **kw):
    text = compiler.visit_create_column(element, **kw)
    text = text.replace(
        "SERIAL", "INT GENERATED BY DEFAULT AS IDENTITY"
     )
    return text
</pre>
<p>Using the above, a table such as:</p>
<pre class="rst-literal-block">
t = Table(
    't', m,
    Column('id', Integer, primary_key=True),
    Column('data', String)
)
</pre>
<p>Will generate on the backing database as:</p>
<pre class="rst-last rst-literal-block">
CREATE TABLE t (
    id INT GENERATED BY DEFAULT AS IDENTITY,
    data VARCHAR,
    PRIMARY KEY (id)
)
</pre>
</div>
</div>
</div>
<div class="rst-section" id="rst-server-side-cursors">
<span id="rst-postgresql-ss-cursors"></span><h2 class="heading">Server Side Cursors</h2>
<p>Server-side cursor support is available for the psycopg2, asyncpg
dialects and may also be available in others.</p>
<p>Server side cursors are enabled on a per-statement basis by using the
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`.Connection.execution_options.stream_results`</span></a> connection execution
option:</p>
<pre class="rst-literal-block">
with engine.connect() as conn:
    result = conn.execution_options(stream_results=True).execute(text("select * from table"))
</pre>
<p>Note that some kinds of SQL statements may not be supported with
server side cursors; generally, only SQL statements that return rows should be
used with this option.</p>
<div class="rst-deprecated">
<span class="rst-versionmodified rst-deprecated">Deprecated since version 1.4: </span><span>The dialect-level server_side_cursors flag is deprecated
and will be removed in a future release.  Please use the
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`_engine.Connection.stream_results`</span></a> execution option for
unbuffered cursor support.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:ref:`engine_stream_results`</span></a></p>
</div>
</div>
<div class="rst-section" id="rst-transaction-isolation-level">
<span id="rst-postgresql-isolation-level"></span><h2 class="heading">Transaction Isolation Level</h2>
<p>Most SQLAlchemy dialects support setting of transaction isolation level
using the <a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:paramref:`_sa.create_engine.execution_options`</span></a> parameter
at the <code>_sa.create_engine</code> level, and at the <code>_engine.Connection</code>
level via the <a href="#system-message-5"><span class="rst-problematic" id="rst-problematic-5">:paramref:`.Connection.execution_options.isolation_level`</span></a>
parameter.</p>
<p>For PostgreSQL dialects, this feature works either by making use of the
DBAPI-specific features, such as psycopg2's isolation level flags which will
embed the isolation level setting inline with the <tt class="rst-docutils literal">"BEGIN"</tt> statement, or for
DBAPIs with no direct support by emitting <tt class="rst-docutils literal">SET SESSION CHARACTERISTICS AS
TRANSACTION ISOLATION LEVEL &lt;level&gt;</tt> ahead of the <tt class="rst-docutils literal">"BEGIN"</tt> statement
emitted by the DBAPI.   For the special AUTOCOMMIT isolation level,
DBAPI-specific techniques are used which is typically an <tt class="rst-docutils literal">.autocommit</tt>
flag on the DBAPI connection object.</p>
<p>To set isolation level using <code>_sa.create_engine</code>:</p>
<pre class="rst-literal-block">
engine = create_engine(
    "postgresql+pg8000://scott:tiger@localhost/test",
    execution_options={
        "isolation_level": "REPEATABLE READ"
    }
)
</pre>
<p>To set using per-connection execution options:</p>
<pre class="rst-literal-block">
with engine.connect() as conn:
    conn = conn.execution_options(
        isolation_level="REPEATABLE READ"
    )
    with conn.begin():
        # ... work with transaction
</pre>
<p>Valid values for <tt class="rst-docutils literal">isolation_level</tt> on most PostgreSQL dialects include:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">READ COMMITTED</tt></li>
<li><tt class="rst-docutils literal">READ UNCOMMITTED</tt></li>
<li><tt class="rst-docutils literal">REPEATABLE READ</tt></li>
<li><tt class="rst-docutils literal">SERIALIZABLE</tt></li>
<li><tt class="rst-docutils literal">AUTOCOMMIT</tt></li>
</ul>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-6"><span class="rst-problematic" id="rst-problematic-6">:ref:`postgresql_readonly_deferrable`</span></a></p>
<p><a href="#system-message-7"><span class="rst-problematic" id="rst-problematic-7">:ref:`dbapi_autocommit`</span></a></p>
<p><a href="#system-message-8"><span class="rst-problematic" id="rst-problematic-8">:ref:`psycopg2_isolation_level`</span></a></p>
<p class="rst-last"><a href="#system-message-9"><span class="rst-problematic" id="rst-problematic-9">:ref:`pg8000_isolation_level`</span></a></p>
</div>
</div>
<div class="rst-section" id="rst-setting-read-only-deferrable">
<span id="rst-postgresql-readonly-deferrable"></span><h2 class="heading">Setting READ ONLY / DEFERRABLE</h2>
<p>Most PostgreSQL dialects support setting the "READ ONLY" and "DEFERRABLE"
characteristics of the transaction, which is in addition to the isolation level
setting. These two attributes can be established either in conjunction with or
independently of the isolation level by passing the <tt class="rst-docutils literal">postgresql_readonly</tt> and
<tt class="rst-docutils literal">postgresql_deferrable</tt> flags with
<code>_engine.Connection.execution_options</code>.  The example below illustrates
passing the <tt class="rst-docutils literal">"SERIALIZABLE"</tt> isolation level at the same time as setting
"READ ONLY" and "DEFERRABLE":</p>
<pre class="rst-literal-block">
with engine.connect() as conn:
    conn = conn.execution_options(
        isolation_level="SERIALIZABLE",
        postgresql_readonly=True,
        postgresql_deferrable=True
    )
    with conn.begin():
        #  ... work with transaction
</pre>
<p>Note that some DBAPIs such as asyncpg only support "readonly" with
SERIALIZABLE isolation.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4: </span><span>added support for the <tt class="rst-docutils literal">postgresql_readonly</tt>
and <tt class="rst-docutils literal">postgresql_deferrable</tt> execution options.</span></div>
</div>
<div class="rst-section" id="rst-setting-alternate-search-paths-on-connect">
<span id="rst-postgresql-alternate-search-path"></span><h2 class="heading">Setting Alternate Search Paths on Connect</h2>
<p>The PostgreSQL <tt class="rst-docutils literal">search_path</tt> variable refers to the list of schema names
that will be implicitly referred towards when a particular table or other
object is referenced in a SQL statement.  As detailed in the next section
<a href="#system-message-10"><span class="rst-problematic" id="rst-problematic-10">:ref:`postgresql_schema_reflection`</span></a>, SQLAlchemy is generally organized around
the concept of keeping this variable at its default value of <tt class="rst-docutils literal">public</tt>,
however, in order to have it set to any arbitrary name or names when connections
are used automatically, the "SET SESSION search_path" command may be invoked
for all connections in a pool using the following event handler, as discussed
at <a href="#system-message-11"><span class="rst-problematic" id="rst-problematic-11">:ref:`schema_set_default_connections`</span></a>:</p>
<pre class="rst-literal-block">
from sqlalchemy import event
from sqlalchemy import create_engine

engine = create_engine("postgresql+psycopg2://scott:tiger@host/dbname")

@event.listens_for(engine, "connect", insert=True)
def set_search_path(dbapi_connection, connection_record):
    existing_autocommit = dbapi_connection.autocommit
    dbapi_connection.autocommit = True
    cursor = dbapi_connection.cursor()
    cursor.execute("SET SESSION search_path='%s'" % schema_name)
    cursor.close()
    dbapi_connection.autocommit = existing_autocommit
</pre>
<p>The reason the recipe is complicated by use of the <tt class="rst-docutils literal">.autocommit</tt> DBAPI
attribute is so that when the <tt class="rst-docutils literal">SET SESSION search_path</tt> directive is invoked,
it is invoked outside of the scope of any transaction and therefore will not
be reverted when the DBAPI connection has a rollback.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-12"><span class="rst-problematic" id="rst-problematic-12">:ref:`schema_set_default_connections`</span></a> - in the <a href="#system-message-13"><span class="rst-problematic" id="rst-problematic-13">:ref:`metadata_toplevel`</span></a> documentation</p>
</div>
</div>
<div class="rst-section" id="rst-remote-schema-table-introspection-and-postgresql-search-path">
<span id="rst-postgresql-schema-reflection"></span><h2 class="heading">Remote-Schema Table Introspection and PostgreSQL search_path</h2>
<div class="rst-admonition rst-admonition-section-best-practices-summarized">
<p class="rst-first rst-admonition-title">Section Best Practices Summarized</p>
<p class="rst-last">keep the <tt class="rst-docutils literal">search_path</tt> variable set to its default of <tt class="rst-docutils literal">public</tt>, without
any other schema names. For other schema names, name these explicitly
within <code>_schema.Table</code> definitions. Alternatively, the
<tt class="rst-docutils literal">postgresql_ignore_search_path</tt> option will cause all reflected
<code>_schema.Table</code> objects to have a <code>_schema.Table.schema</code>
attribute set up.</p>
</div>
<p>The PostgreSQL dialect can reflect tables from any schema, as outlined in
<a href="#system-message-14"><span class="rst-problematic" id="rst-problematic-14">:ref:`schema_table_reflection`</span></a>.</p>
<p>With regards to tables which these <code>_schema.Table</code>
objects refer to via foreign key constraint, a decision must be made as to how
the <tt class="rst-docutils literal">.schema</tt> is represented in those remote tables, in the case where that
remote schema name is also a member of the current
<a class="rst-reference external" href="https://www.postgresql.org/docs/current/static/ddl-schemas.html#DDL-SCHEMAS-PATH" target="_top">PostgreSQL search path</a>.</p>
<p>By default, the PostgreSQL dialect mimics the behavior encouraged by
PostgreSQL's own <tt class="rst-docutils literal">pg_get_constraintdef()</tt> builtin procedure.  This function
returns a sample definition for a particular foreign key constraint,
omitting the referenced schema name from that definition when the name is
also in the PostgreSQL schema search path.  The interaction below
illustrates this behavior:</p>
<pre class="rst-literal-block">
test=&gt; CREATE TABLE test_schema.referred(id INTEGER PRIMARY KEY);
CREATE TABLE
test=&gt; CREATE TABLE referring(
test(&gt;         id INTEGER PRIMARY KEY,
test(&gt;         referred_id INTEGER REFERENCES test_schema.referred(id));
CREATE TABLE
test=&gt; SET search_path TO public, test_schema;
test=&gt; SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM
test-&gt; pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n
test-&gt; ON n.oid = c.relnamespace
test-&gt; JOIN pg_catalog.pg_constraint r  ON c.oid = r.conrelid
test-&gt; WHERE c.relname='referring' AND r.contype = 'f'
test-&gt; ;
               pg_get_constraintdef
---------------------------------------------------
 FOREIGN KEY (referred_id) REFERENCES referred(id)
(1 row)
</pre>
<p>Above, we created a table <tt class="rst-docutils literal">referred</tt> as a member of the remote schema
<tt class="rst-docutils literal">test_schema</tt>, however when we added <tt class="rst-docutils literal">test_schema</tt> to the
PG <tt class="rst-docutils literal">search_path</tt> and then asked <tt class="rst-docutils literal">pg_get_constraintdef()</tt> for the
<tt class="rst-docutils literal">FOREIGN KEY</tt> syntax, <tt class="rst-docutils literal">test_schema</tt> was not included in the output of
the function.</p>
<p>On the other hand, if we set the search path back to the typical default
of <tt class="rst-docutils literal">public</tt>:</p>
<pre class="rst-literal-block">
test=&gt; SET search_path TO public;
SET
</pre>
<p>The same query against <tt class="rst-docutils literal">pg_get_constraintdef()</tt> now returns the fully
schema-qualified name for us:</p>
<pre class="rst-literal-block">
test=&gt; SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM
test-&gt; pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n
test-&gt; ON n.oid = c.relnamespace
test-&gt; JOIN pg_catalog.pg_constraint r  ON c.oid = r.conrelid
test-&gt; WHERE c.relname='referring' AND r.contype = 'f';
                     pg_get_constraintdef
---------------------------------------------------------------
 FOREIGN KEY (referred_id) REFERENCES test_schema.referred(id)
(1 row)
</pre>
<p>SQLAlchemy will by default use the return value of <tt class="rst-docutils literal">pg_get_constraintdef()</tt>
in order to determine the remote schema name.  That is, if our <tt class="rst-docutils literal">search_path</tt>
were set to include <tt class="rst-docutils literal">test_schema</tt>, and we invoked a table
reflection process as follows:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy import Table, MetaData, create_engine, text
&gt;&gt;&gt; engine = create_engine("postgresql://scott:tiger@localhost/test")
&gt;&gt;&gt; with engine.connect() as conn:
...     conn.execute(text("SET search_path TO test_schema, public"))
...     metadata_obj = MetaData()
...     referring = Table('referring', metadata_obj,
...                       autoload_with=conn)
...
&lt;sqlalchemy.engine.result.CursorResult object at 0x101612ed0&gt;
</pre>
<p>The above process would deliver to the <code>_schema.MetaData.tables</code>
collection
<tt class="rst-docutils literal">referred</tt> table named <strong>without</strong> the schema:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; metadata_obj.tables['referred'].schema is None
True
</pre>
<p>To alter the behavior of reflection such that the referred schema is
maintained regardless of the <tt class="rst-docutils literal">search_path</tt> setting, use the
<tt class="rst-docutils literal">postgresql_ignore_search_path</tt> option, which can be specified as a
dialect-specific argument to both <code>_schema.Table</code> as well as
<code>_schema.MetaData.reflect</code>:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; with engine.connect() as conn:
...     conn.execute(text("SET search_path TO test_schema, public"))
...     metadata_obj = MetaData()
...     referring = Table('referring', metadata_obj,
...                       autoload_with=conn,
...                       postgresql_ignore_search_path=True)
...
&lt;sqlalchemy.engine.result.CursorResult object at 0x1016126d0&gt;
</pre>
<p>We will now have <tt class="rst-docutils literal">test_schema.referred</tt> stored as schema-qualified:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; metadata_obj.tables['test_schema.referred'].schema
'test_schema'
</pre>
<div class="rst-sidebar">
<p class="rst-first rst-sidebar-title">Best Practices for PostgreSQL Schema reflection</p>
<p class="rst-last">The description of PostgreSQL schema reflection behavior is complex, and
is the product of many years of dealing with widely varied use cases and
user preferences. But in fact, there's no need to understand any of it if
you just stick to the simplest use pattern: leave the <tt class="rst-docutils literal">search_path</tt> set
to its default of <tt class="rst-docutils literal">public</tt> only, never refer to the name <tt class="rst-docutils literal">public</tt> as
an explicit schema name otherwise, and refer to all other schema names
explicitly when building up a <code>_schema.Table</code> object.  The options
described here are only for those users who can't, or prefer not to, stay
within these guidelines.</p>
</div>
<p>Note that <strong>in all cases</strong>, the "default" schema is always reflected as
<tt class="rst-docutils literal">None</tt>. The "default" schema on PostgreSQL is that which is returned by the
PostgreSQL <tt class="rst-docutils literal">current_schema()</tt> function.  On a typical PostgreSQL
installation, this is the name <tt class="rst-docutils literal">public</tt>.  So a table that refers to another
which is in the <tt class="rst-docutils literal">public</tt> (i.e. default) schema will always have the
<tt class="rst-docutils literal">.schema</tt> attribute set to <tt class="rst-docutils literal">None</tt>.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-15"><span class="rst-problematic" id="rst-problematic-15">:ref:`reflection_schema_qualified_interaction`</span></a> - discussion of the issue
from a backend-agnostic perspective</p>
<p class="rst-last"><a class="rst-reference external" href="https://www.postgresql.org/docs/9.0/static/ddl-schemas.html#DDL-SCHEMAS-PATH" target="_top">The Schema Search Path</a>
- on the PostgreSQL website.</p>
</div>
</div>
<div class="rst-section" id="rst-insert-update-returning">
<h2 class="heading">INSERT/UPDATE...RETURNING</h2>
<p>The dialect supports PG 8.2's <tt class="rst-docutils literal"><span class="pre">INSERT..RETURNING</span></tt>, <tt class="rst-docutils literal"><span class="pre">UPDATE..RETURNING</span></tt> and
<tt class="rst-docutils literal"><span class="pre">DELETE..RETURNING</span></tt> syntaxes.   <tt class="rst-docutils literal"><span class="pre">INSERT..RETURNING</span></tt> is used by default
for single-row INSERT statements in order to fetch newly generated
primary key identifiers.   To specify an explicit <tt class="rst-docutils literal">RETURNING</tt> clause,
use the <code>._UpdateBase.returning</code> method on a per-statement basis:</p>
<pre class="rst-literal-block">
# INSERT..RETURNING
result = table.insert().returning(table.c.col1, table.c.col2).\
    values(name='foo')
print(result.fetchall())

# UPDATE..RETURNING
result = table.update().returning(table.c.col1, table.c.col2).\
    where(table.c.name=='foo').values(name='bar')
print(result.fetchall())

# DELETE..RETURNING
result = table.delete().returning(table.c.col1, table.c.col2).\
    where(table.c.name=='foo')
print(result.fetchall())
</pre>
</div>
<div class="rst-section" id="rst-insert-on-conflict-upsert">
<span id="rst-postgresql-insert-on-conflict"></span><h2 class="heading">INSERT...ON CONFLICT (Upsert)</h2>
<p>Starting with version 9.5, PostgreSQL allows "upserts" (update or insert) of
rows into a table via the <tt class="rst-docutils literal">ON CONFLICT</tt> clause of the <tt class="rst-docutils literal">INSERT</tt> statement. A
candidate row will only be inserted if that row does not violate any unique
constraints.  In the case of a unique constraint violation, a secondary action
can occur which can be either "DO UPDATE", indicating that the data in the
target row should be updated, or "DO NOTHING", which indicates to silently skip
this row.</p>
<p>Conflicts are determined using existing unique constraints and indexes.  These
constraints may be identified either using their name as stated in DDL,
or they may be inferred by stating the columns and conditions that comprise
the indexes.</p>
<p>SQLAlchemy provides <tt class="rst-docutils literal">ON CONFLICT</tt> support via the PostgreSQL-specific
<code>_postgresql.insert()</code> function, which provides
the generative methods <code>_postgresql.Insert.on_conflict_do_update</code>
and <code>~.postgresql.Insert.on_conflict_do_nothing</code>:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; from sqlalchemy.dialects.postgresql import insert
&gt;&gt;&gt; insert_stmt = insert(my_table).values(
...     id='some_existing_id',
...     data='inserted value')
&gt;&gt;&gt; do_nothing_stmt = insert_stmt.on_conflict_do_nothing(
...     index_elements=['id']
... )
&gt;&gt;&gt; print(do_nothing_stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
ON CONFLICT (id) DO NOTHING
{stop}

&gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update(
...     constraint='pk_my_table',
...     set_=dict(data='updated value')
... )
&gt;&gt;&gt; print(do_update_stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
ON CONFLICT ON CONSTRAINT pk_my_table DO UPDATE SET data = %(param_1)s
</pre>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.1.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a class="rst-reference external" href="https://www.postgresql.org/docs/current/static/sql-insert.html#SQL-ON-CONFLICT" target="_top">INSERT .. ON CONFLICT</a>
- in the PostgreSQL documentation.</p>
</div>
<div class="rst-section" id="rst-specifying-the-target">
<h3 class="heading">Specifying the Target</h3>
<p>Both methods supply the "target" of the conflict using either the
named constraint or by column inference:</p>
<ul>
<li><p class="rst-first">The <a href="#system-message-16"><span class="rst-problematic" id="rst-problematic-16">:paramref:`_postgresql.Insert.on_conflict_do_update.index_elements`</span></a> argument
specifies a sequence containing string column names, <code>_schema.Column</code>
objects, and/or SQL expression elements, which would identify a unique
index:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update(
...     index_elements=['id'],
...     set_=dict(data='updated value')
... )
&gt;&gt;&gt; print(do_update_stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
ON CONFLICT (id) DO UPDATE SET data = %(param_1)s
{stop}

&gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update(
...     index_elements=[my_table.c.id],
...     set_=dict(data='updated value')
... )
&gt;&gt;&gt; print(do_update_stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
ON CONFLICT (id) DO UPDATE SET data = %(param_1)s
</pre>
</li>
<li><p class="rst-first">When using <a href="#system-message-17"><span class="rst-problematic" id="rst-problematic-17">:paramref:`_postgresql.Insert.on_conflict_do_update.index_elements`</span></a> to
infer an index, a partial index can be inferred by also specifying the
use the <a href="#system-message-18"><span class="rst-problematic" id="rst-problematic-18">:paramref:`_postgresql.Insert.on_conflict_do_update.index_where`</span></a> parameter:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; stmt = insert(my_table).values(user_email='a@b.com', data='inserted data')
&gt;&gt;&gt; stmt = stmt.on_conflict_do_update(
...     index_elements=[my_table.c.user_email],
...     index_where=my_table.c.user_email.like('%@gmail.com'),
...     set_=dict(data=stmt.excluded.data)
... )
&gt;&gt;&gt; print(stmt)
{opensql}INSERT INTO my_table (data, user_email)
VALUES (%(data)s, %(user_email)s) ON CONFLICT (user_email)
WHERE user_email LIKE %(user_email_1)s DO UPDATE SET data = excluded.data
</pre>
</li>
<li><p class="rst-first">The <a href="#system-message-19"><span class="rst-problematic" id="rst-problematic-19">:paramref:`_postgresql.Insert.on_conflict_do_update.constraint`</span></a> argument is
used to specify an index directly rather than inferring it.  This can be
the name of a UNIQUE constraint, a PRIMARY KEY constraint, or an INDEX:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update(
...     constraint='my_table_idx_1',
...     set_=dict(data='updated value')
... )
&gt;&gt;&gt; print(do_update_stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
ON CONFLICT ON CONSTRAINT my_table_idx_1 DO UPDATE SET data = %(param_1)s
{stop}

&gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update(
...     constraint='my_table_pk',
...     set_=dict(data='updated value')
... )
&gt;&gt;&gt; print(do_update_stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
ON CONFLICT ON CONSTRAINT my_table_pk DO UPDATE SET data = %(param_1)s
{stop}
</pre>
</li>
<li><p class="rst-first">The <a href="#system-message-20"><span class="rst-problematic" id="rst-problematic-20">:paramref:`_postgresql.Insert.on_conflict_do_update.constraint`</span></a> argument may
also refer to a SQLAlchemy construct representing a constraint,
e.g. <code>.UniqueConstraint</code>, <code>.PrimaryKeyConstraint</code>,
<code>.Index</code>, or <code>.ExcludeConstraint</code>.   In this use,
if the constraint has a name, it is used directly.  Otherwise, if the
constraint is unnamed, then inference will be used, where the expressions
and optional WHERE clause of the constraint will be spelled out in the
construct.  This use is especially convenient
to refer to the named or unnamed primary key of a <code>_schema.Table</code>
using the
<code>_schema.Table.primary_key</code> attribute:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update(
...     constraint=my_table.primary_key,
...     set_=dict(data='updated value')
... )
&gt;&gt;&gt; print(do_update_stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
ON CONFLICT (id) DO UPDATE SET data = %(param_1)s
</pre>
</li>
</ul>
</div>
<div class="rst-section" id="rst-the-set-clause">
<h3 class="heading">The SET Clause</h3>
<p><tt class="rst-docutils literal">ON <span class="pre">CONFLICT...DO</span> UPDATE</tt> is used to perform an update of the already
existing row, using any combination of new values as well as values
from the proposed insertion.   These values are specified using the
<a href="#system-message-21"><span class="rst-problematic" id="rst-problematic-21">:paramref:`_postgresql.Insert.on_conflict_do_update.set_`</span></a> parameter.  This
parameter accepts a dictionary which consists of direct values
for UPDATE:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; stmt = insert(my_table).values(id='some_id', data='inserted value')
&gt;&gt;&gt; do_update_stmt = stmt.on_conflict_do_update(
...     index_elements=['id'],
...     set_=dict(data='updated value')
... )
&gt;&gt;&gt; print(do_update_stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
ON CONFLICT (id) DO UPDATE SET data = %(param_1)s
</pre>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p class="rst-last">The <code>_expression.Insert.on_conflict_do_update</code>
method does <strong>not</strong> take into
account Python-side default UPDATE values or generation functions, e.g.
those specified using <a href="#system-message-22"><span class="rst-problematic" id="rst-problematic-22">:paramref:`_schema.Column.onupdate`</span></a>.
These values will not be exercised for an ON CONFLICT style of UPDATE,
unless they are manually specified in the
<a href="#system-message-23"><span class="rst-problematic" id="rst-problematic-23">:paramref:`_postgresql.Insert.on_conflict_do_update.set_`</span></a> dictionary.</p>
</div>
</div>
<div class="rst-section" id="rst-updating-using-the-excluded-insert-values">
<h3 class="heading">Updating using the Excluded INSERT Values</h3>
<p>In order to refer to the proposed insertion row, the special alias
<code>~.postgresql.Insert.excluded</code> is available as an attribute on
the <code>_postgresql.Insert</code> object; this object is a
<code>_expression.ColumnCollection</code>
which alias contains all columns of the target
table:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; stmt = insert(my_table).values(
...     id='some_id',
...     data='inserted value',
...     author='jlh'
... )
&gt;&gt;&gt; do_update_stmt = stmt.on_conflict_do_update(
...     index_elements=['id'],
...     set_=dict(data='updated value', author=stmt.excluded.author)
... )
&gt;&gt;&gt; print(do_update_stmt)
{opensql}INSERT INTO my_table (id, data, author)
VALUES (%(id)s, %(data)s, %(author)s)
ON CONFLICT (id) DO UPDATE SET data = %(param_1)s, author = excluded.author
</pre>
</div>
<div class="rst-section" id="rst-additional-where-criteria">
<h3 class="heading">Additional WHERE Criteria</h3>
<p>The <code>_expression.Insert.on_conflict_do_update</code> method also accepts
a WHERE clause using the <a href="#system-message-24"><span class="rst-problematic" id="rst-problematic-24">:paramref:`_postgresql.Insert.on_conflict_do_update.where`</span></a>
parameter, which will limit those rows which receive an UPDATE:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; stmt = insert(my_table).values(
...     id='some_id',
...     data='inserted value',
...     author='jlh'
... )
&gt;&gt;&gt; on_update_stmt = stmt.on_conflict_do_update(
...     index_elements=['id'],
...     set_=dict(data='updated value', author=stmt.excluded.author),
...     where=(my_table.c.status == 2)
... )
&gt;&gt;&gt; print(on_update_stmt)
{opensql}INSERT INTO my_table (id, data, author)
VALUES (%(id)s, %(data)s, %(author)s)
ON CONFLICT (id) DO UPDATE SET data = %(param_1)s, author = excluded.author
WHERE my_table.status = %(status_1)s
</pre>
</div>
<div class="rst-section" id="rst-skipping-rows-with-do-nothing">
<h3 class="heading">Skipping Rows with DO NOTHING</h3>
<p><tt class="rst-docutils literal">ON CONFLICT</tt> may be used to skip inserting a row entirely
if any conflict with a unique or exclusion constraint occurs; below
this is illustrated using the
<code>~.postgresql.Insert.on_conflict_do_nothing</code> method:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; stmt = insert(my_table).values(id='some_id', data='inserted value')
&gt;&gt;&gt; stmt = stmt.on_conflict_do_nothing(index_elements=['id'])
&gt;&gt;&gt; print(stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
ON CONFLICT (id) DO NOTHING
</pre>
<p>If <tt class="rst-docutils literal">DO NOTHING</tt> is used without specifying any columns or constraint,
it has the effect of skipping the INSERT for any unique or exclusion
constraint violation which occurs:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; stmt = insert(my_table).values(id='some_id', data='inserted value')
&gt;&gt;&gt; stmt = stmt.on_conflict_do_nothing()
&gt;&gt;&gt; print(stmt)
{opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
ON CONFLICT DO NOTHING
</pre>
</div>
</div>
<div class="rst-section" id="rst-full-text-search">
<span id="rst-postgresql-match"></span><h2 class="heading">Full Text Search</h2>
<p>SQLAlchemy makes available the PostgreSQL <tt class="rst-docutils literal">@@</tt> operator via the
<code>_expression.ColumnElement.match</code> method on any textual column expression.</p>
<p>On the PostgreSQL dialect, an expression like the following:</p>
<pre class="rst-literal-block">
select(sometable.c.text.match("search string"))
</pre>
<p>will emit to the database:</p>
<pre class="rst-literal-block">
SELECT text @@ to_tsquery('search string') FROM table
</pre>
<p>Various other PostgreSQL text search functions such as <tt class="rst-docutils literal">to_tsquery()</tt>,
<tt class="rst-docutils literal">to_tsvector()</tt>, and <tt class="rst-docutils literal">plainto_tsquery()</tt> are available by explicitly using
the standard SQLAlchemy <code>.func</code> construct.</p>
<p>For example:</p>
<pre class="rst-literal-block">
select(func.to_tsvector('fat cats ate rats').match('cat &amp; rat'))
</pre>
<p>Emits the equivalent of:</p>
<pre class="rst-literal-block">
SELECT to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')
</pre>
<p>The <code>_postgresql.TSVECTOR</code> type can provide for explicit CAST:</p>
<pre class="rst-literal-block">
from sqlalchemy.dialects.postgresql import TSVECTOR
from sqlalchemy import select, cast
select(cast("some text", TSVECTOR))
</pre>
<p>produces a statement equivalent to:</p>
<pre class="rst-literal-block">
SELECT CAST('some text' AS TSVECTOR) AS anon_1
</pre>
<div class="rst-admonition tip">
<p class="rst-first rst-admonition-title">Tip</p>
<p>It's important to remember that text searching in PostgreSQL is powerful but complicated,
and SQLAlchemy users are advised to reference the PostgreSQL documentation
regarding
<a class="rst-reference external" href="https://www.postgresql.org/docs/13/textsearch-controls.html" target="_top">Full Text Search</a>.</p>
<p class="rst-last">There are important differences between <tt class="rst-docutils literal">to_tsquery</tt> and
<tt class="rst-docutils literal">plainto_tsquery</tt>, the most significant of which is that <tt class="rst-docutils literal">to_tsquery</tt>
expects specially formatted "querytext" that is written to PostgreSQL's own
specification, while <tt class="rst-docutils literal">plainto_tsquery</tt> expects unformatted text that is
transformed into <tt class="rst-docutils literal">to_tsquery</tt> compatible querytext. This means the input to
<tt class="rst-docutils literal">.match()</tt> under PostgreSQL may be incompatible with the input to
<tt class="rst-docutils literal">.match()</tt> under another database backend. SQLAlchemy users who support
multiple backends are advised to carefully implement their usage of
<tt class="rst-docutils literal">.match()</tt> to work around these constraints.</p>
</div>
<p>Full Text Searches in PostgreSQL are influenced by a combination of: the
PostgreSQL setting of <tt class="rst-docutils literal">default_text_search_config</tt>, the <tt class="rst-docutils literal">regconfig</tt> used
to build the GIN/GiST indexes, and the <tt class="rst-docutils literal">regconfig</tt> optionally passed in
during a query.</p>
<p>When performing a Full Text Search against a column that has a GIN or
GiST index that is already pre-computed (which is common on full text
searches) one may need to explicitly pass in a particular PostgreSQL
<tt class="rst-docutils literal">regconfig</tt> value to ensure the query-planner utilizes the index and does
not re-compute the column on demand.</p>
<p>In order to provide for this explicit query planning, or to use different
search strategies, the <tt class="rst-docutils literal">match</tt> method accepts a <tt class="rst-docutils literal">postgresql_regconfig</tt>
keyword argument:</p>
<pre class="rst-literal-block">
select(mytable.c.id).where(
    mytable.c.title.match('somestring', postgresql_regconfig='english')
)
</pre>
<p>Emits the equivalent of:</p>
<pre class="rst-literal-block">
SELECT mytable.id FROM mytable
WHERE mytable.title @@ to_tsquery('english', 'somestring')
</pre>
<p>One can also specifically pass in a <code>'regconfig'</code> value to the
<tt class="rst-docutils literal">to_tsvector()</tt> command as the initial argument:</p>
<pre class="rst-literal-block">
select(mytable.c.id).where(
        func.to_tsvector('english', mytable.c.title )\
        .match('somestring', postgresql_regconfig='english')
    )
</pre>
<p>produces a statement equivalent to:</p>
<pre class="rst-literal-block">
SELECT mytable.id FROM mytable
WHERE to_tsvector('english', mytable.title) @@
    to_tsquery('english', 'somestring')
</pre>
<p>It is recommended that you use the <tt class="rst-docutils literal">EXPLAIN <span class="pre">ANALYZE...</span></tt> tool from
PostgreSQL to ensure that you are generating queries with SQLAlchemy that
take full advantage of any indexes you may have created for full text search.</p>
</div>
<div class="rst-section" id="rst-from-only">
<h2 class="heading">FROM ONLY ...</h2>
<p>The dialect supports PostgreSQL's ONLY keyword for targeting only a particular
table in an inheritance hierarchy. This can be used to produce the
<tt class="rst-docutils literal">SELECT ... FROM ONLY</tt>, <tt class="rst-docutils literal">UPDATE ONLY ...</tt>, and <tt class="rst-docutils literal">DELETE FROM ONLY ...</tt>
syntaxes. It uses SQLAlchemy's hints mechanism:</p>
<pre class="rst-literal-block">
# SELECT ... FROM ONLY ...
result = table.select().with_hint(table, 'ONLY', 'postgresql')
print(result.fetchall())

# UPDATE ONLY ...
table.update(values=dict(foo='bar')).with_hint('ONLY',
                                               dialect_name='postgresql')

# DELETE FROM ONLY ...
table.delete().with_hint('ONLY', dialect_name='postgresql')
</pre>
</div>
<div class="rst-section" id="rst-postgresql-specific-index-options">
<span id="rst-postgresql-indexes"></span><h2 class="heading">PostgreSQL-Specific Index Options</h2>
<p>Several extensions to the <code>.Index</code> construct are available, specific
to the PostgreSQL dialect.</p>
<div class="rst-section" id="rst-covering-indexes">
<h3 class="heading">Covering Indexes</h3>
<p>The <tt class="rst-docutils literal">postgresql_include</tt> option renders INCLUDE(colname) for the given
string names:</p>
<pre class="rst-literal-block">
Index("my_index", table.c.x, postgresql_include=['y'])
</pre>
<p>would render the index as <tt class="rst-docutils literal">CREATE INDEX my_index ON table (x) INCLUDE (y)</tt></p>
<p>Note that this feature requires PostgreSQL 11 or later.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.</span></div>
</div>
<div class="rst-section" id="rst-partial-indexes">
<span id="rst-postgresql-partial-indexes"></span><h3 class="heading">Partial Indexes</h3>
<p>Partial indexes add criterion to the index definition so that the index is
applied to a subset of rows.   These can be specified on <code>.Index</code>
using the <tt class="rst-docutils literal">postgresql_where</tt> keyword argument:</p>
<pre class="rst-literal-block">
Index('my_index', my_table.c.id, postgresql_where=my_table.c.value &gt; 10)
</pre>
</div>
<div class="rst-section" id="rst-operator-classes">
<span id="rst-postgresql-operator-classes"></span><h3 class="heading">Operator Classes</h3>
<p>PostgreSQL allows the specification of an <em>operator class</em> for each column of
an index (see
<a class="rst-reference external" href="https://www.postgresql.org/docs/8.3/interactive/indexes-opclass.html" target="_top">https://www.postgresql.org/docs/8.3/interactive/indexes-opclass.html</a>).
The <code>.Index</code> construct allows these to be specified via the
<tt class="rst-docutils literal">postgresql_ops</tt> keyword argument:</p>
<pre class="rst-literal-block">
Index(
    'my_index', my_table.c.id, my_table.c.data,
    postgresql_ops={
        'data': 'text_pattern_ops',
        'id': 'int4_ops'
    })
</pre>
<p>Note that the keys in the <tt class="rst-docutils literal">postgresql_ops</tt> dictionaries are the
"key" name of the <code>_schema.Column</code>, i.e. the name used to access it from
the <tt class="rst-docutils literal">.c</tt> collection of <code>_schema.Table</code>, which can be configured to be
different than the actual name of the column as expressed in the database.</p>
<p>If <tt class="rst-docutils literal">postgresql_ops</tt> is to be used against a complex SQL expression such
as a function call, then to apply to the column it must be given a label
that is identified in the dictionary by name, e.g.:</p>
<pre class="rst-literal-block">
Index(
    'my_index', my_table.c.id,
    func.lower(my_table.c.data).label('data_lower'),
    postgresql_ops={
        'data_lower': 'text_pattern_ops',
        'id': 'int4_ops'
    })
</pre>
<p>Operator classes are also supported by the
<code>_postgresql.ExcludeConstraint</code> construct using the
<a href="#system-message-25"><span class="rst-problematic" id="rst-problematic-25">:paramref:`_postgresql.ExcludeConstraint.ops`</span></a> parameter. See that parameter for
details.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.3.21: </span><span>added support for operator classes with
<code>_postgresql.ExcludeConstraint</code>.</span></div>
</div>
<div class="rst-section" id="rst-index-types">
<h3 class="heading">Index Types</h3>
<p>PostgreSQL provides several index types: B-Tree, Hash, GiST, and GIN, as well
as the ability for users to create their own (see
<a class="rst-reference external" href="https://www.postgresql.org/docs/8.3/static/indexes-types.html" target="_top">https://www.postgresql.org/docs/8.3/static/indexes-types.html</a>). These can be
specified on <code>.Index</code> using the <tt class="rst-docutils literal">postgresql_using</tt> keyword argument:</p>
<pre class="rst-literal-block">
Index('my_index', my_table.c.data, postgresql_using='gin')
</pre>
<p>The value passed to the keyword argument will be simply passed through to the
underlying CREATE INDEX command, so it <em>must</em> be a valid index type for your
version of PostgreSQL.</p>
</div>
<div class="rst-section" id="rst-index-storage-parameters">
<span id="rst-postgresql-index-storage"></span><h3 class="heading">Index Storage Parameters</h3>
<p>PostgreSQL allows storage parameters to be set on indexes. The storage
parameters available depend on the index method used by the index. Storage
parameters can be specified on <code>.Index</code> using the <tt class="rst-docutils literal">postgresql_with</tt>
keyword argument:</p>
<pre class="rst-literal-block">
Index('my_index', my_table.c.data, postgresql_with={"fillfactor": 50})
</pre>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.0.6.</span></div>
<p>PostgreSQL allows to define the tablespace in which to create the index.
The tablespace can be specified on <code>.Index</code> using the
<tt class="rst-docutils literal">postgresql_tablespace</tt> keyword argument:</p>
<pre class="rst-literal-block">
Index('my_index', my_table.c.data, postgresql_tablespace='my_tablespace')
</pre>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.1.</span></div>
<p>Note that the same option is available on <code>_schema.Table</code> as well.</p>
</div>
<div class="rst-section" id="rst-indexes-with-concurrently">
<span id="rst-postgresql-index-concurrently"></span><h3 class="heading">Indexes with CONCURRENTLY</h3>
<p>The PostgreSQL index option CONCURRENTLY is supported by passing the
flag <tt class="rst-docutils literal">postgresql_concurrently</tt> to the <code>.Index</code> construct:</p>
<pre class="rst-literal-block">
tbl = Table('testtbl', m, Column('data', Integer))

idx1 = Index('test_idx1', tbl.c.data, postgresql_concurrently=True)
</pre>
<p>The above index construct will render DDL for CREATE INDEX, assuming
PostgreSQL 8.2 or higher is detected or for a connection-less dialect, as:</p>
<pre class="rst-literal-block">
CREATE INDEX CONCURRENTLY test_idx1 ON testtbl (data)
</pre>
<p>For DROP INDEX, assuming PostgreSQL 9.2 or higher is detected or for
a connection-less dialect, it will emit:</p>
<pre class="rst-literal-block">
DROP INDEX CONCURRENTLY test_idx1
</pre>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.1: </span><span>support for CONCURRENTLY on DROP INDEX.  The
CONCURRENTLY keyword is now only emitted if a high enough version
of PostgreSQL is detected on the connection (or for a connection-less
dialect).</span></div>
<p>When using CONCURRENTLY, the PostgreSQL database requires that the statement
be invoked outside of a transaction block.   The Python DBAPI enforces that
even for a single statement, a transaction is present, so to use this
construct, the DBAPI's "autocommit" mode must be used:</p>
<pre class="rst-literal-block">
metadata = MetaData()
table = Table(
    "foo", metadata,
    Column("id", String))
index = Index(
    "foo_idx", table.c.id, postgresql_concurrently=True)

with engine.connect() as conn:
    with conn.execution_options(isolation_level='AUTOCOMMIT'):
        table.create(conn)
</pre>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-26"><span class="rst-problematic" id="rst-problematic-26">:ref:`postgresql_isolation_level`</span></a></p>
</div>
</div>
</div>
<div class="rst-section" id="rst-postgresql-index-reflection-1">
<span id="rst-postgresql-index-reflection"></span><h2 class="heading">PostgreSQL Index Reflection</h2>
<p>The PostgreSQL database creates a UNIQUE INDEX implicitly whenever the
UNIQUE CONSTRAINT construct is used.   When inspecting a table using
<code>_reflection.Inspector</code>, the <code>_reflection.Inspector.get_indexes</code>
and the <code>_reflection.Inspector.get_unique_constraints</code>
will report on these
two constructs distinctly; in the case of the index, the key
<tt class="rst-docutils literal">duplicates_constraint</tt> will be present in the index entry if it is
detected as mirroring a constraint.   When performing reflection using
<tt class="rst-docutils literal"><span class="pre">Table(...,</span> autoload_with=engine)</tt>, the UNIQUE INDEX is <strong>not</strong> returned
in <code>_schema.Table.indexes</code> when it is detected as mirroring a
<code>.UniqueConstraint</code> in the <code>_schema.Table.constraints</code> collection
.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.0.0: </span><span>- <code>_schema.Table</code> reflection now includes
<code>.UniqueConstraint</code> objects present in the
<code>_schema.Table.constraints</code>
collection; the PostgreSQL backend will no longer include a "mirrored"
<code>.Index</code> construct in <code>_schema.Table.indexes</code>
if it is detected
as corresponding to a unique constraint.</span></div>
</div>
<div class="rst-section" id="rst-special-reflection-options">
<h2 class="heading">Special Reflection Options</h2>
<p>The <code>_reflection.Inspector</code>
used for the PostgreSQL backend is an instance
of <code>.PGInspector</code>, which offers additional methods:</p>
<pre class="rst-literal-block">
from sqlalchemy import create_engine, inspect

engine = create_engine("postgresql+psycopg2://localhost/test")
insp = inspect(engine)  # will be a PGInspector

print(insp.get_enums())
</pre>
</div>
<div class="rst-section" id="rst-postgresql-table-options-1">
<span id="rst-postgresql-table-options"></span><h2 class="heading">PostgreSQL Table Options</h2>
<p>Several options for CREATE TABLE are supported directly by the PostgreSQL
dialect in conjunction with the <code>_schema.Table</code> construct:</p>
<ul>
<li><p class="rst-first"><tt class="rst-docutils literal">TABLESPACE</tt>:</p>
<pre class="rst-literal-block">
Table("some_table", metadata, ..., postgresql_tablespace='some_tablespace')
</pre>
<p>The above option is also available on the <code>.Index</code> construct.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">ON COMMIT</tt>:</p>
<pre class="rst-literal-block">
Table("some_table", metadata, ..., postgresql_on_commit='PRESERVE ROWS')
</pre>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">WITH OIDS</tt>:</p>
<pre class="rst-literal-block">
Table("some_table", metadata, ..., postgresql_with_oids=True)
</pre>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">WITHOUT OIDS</tt>:</p>
<pre class="rst-literal-block">
Table("some_table", metadata, ..., postgresql_with_oids=False)
</pre>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">INHERITS</tt>:</p>
<pre class="rst-literal-block">
Table("some_table", metadata, ..., postgresql_inherits="some_supertable")

Table("some_table", metadata, ..., postgresql_inherits=("t1", "t2", ...))

.. versionadded:: 1.0.0
</pre>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">PARTITION BY</tt>:</p>
<pre class="rst-literal-block">
Table("some_table", metadata, ...,
      postgresql_partition_by='LIST (part_column)')

.. versionadded:: 1.2.6
</pre>
</li>
</ul>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a class="rst-reference external" href="https://www.postgresql.org/docs/current/static/sql-createtable.html" target="_top">PostgreSQL CREATE TABLE options</a></p>
</div>
</div>
<div class="rst-section" id="rst-table-values-table-and-column-valued-functions-row-and-tuple-objects">
<span id="rst-postgresql-table-valued-overview"></span><h2 class="heading">Table values, Table and Column valued functions, Row and Tuple objects</h2>
<p>PostgreSQL makes great use of modern SQL forms such as table-valued functions,
tables and rows as values.   These constructs are commonly used as part
of PostgreSQL's support for complex datatypes such as JSON, ARRAY, and other
datatypes.  SQLAlchemy's SQL expression language has native support for
most table-valued and row-valued forms.</p>
<div class="rst-section" id="rst-table-valued-functions">
<span id="rst-postgresql-table-valued"></span><h3 class="heading">Table-Valued Functions</h3>
<p>Many PostgreSQL built-in functions are intended to be used in the FROM clause
of a SELECT statement, and are capable of returning table rows or sets of table
rows. A large portion of PostgreSQL's JSON functions for example such as
<tt class="rst-docutils literal">json_array_elements()</tt>, <tt class="rst-docutils literal">json_object_keys()</tt>, <tt class="rst-docutils literal">json_each_text()</tt>,
<tt class="rst-docutils literal">json_each()</tt>, <tt class="rst-docutils literal">json_to_record()</tt>, <tt class="rst-docutils literal">json_populate_recordset()</tt> use such
forms. These classes of SQL function calling forms in SQLAlchemy are available
using the <code>_functions.FunctionElement.table_valued</code> method in conjunction
with <code>_functions.Function</code> objects generated from the <code>_sql.func</code>
namespace.</p>
<p>Examples from PostgreSQL's reference documentation follow below:</p>
<ul>
<li><p class="rst-first"><tt class="rst-docutils literal">json_each()</tt>:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy import select, func
&gt;&gt;&gt; stmt = select(func.json_each('{"a":"foo", "b":"bar"}').table_valued("key", "value"))
&gt;&gt;&gt; print(stmt)
SELECT anon_1.key, anon_1.value
FROM json_each(:json_each_1) AS anon_1
</pre>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">json_populate_record()</tt>:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy import select, func, literal_column
&gt;&gt;&gt; stmt = select(
...     func.json_populate_record(
...         literal_column("null::myrowtype"),
...         '{"a":1,"b":2}'
...     ).table_valued("a", "b", name="x")
... )
&gt;&gt;&gt; print(stmt)
SELECT x.a, x.b
FROM json_populate_record(null::myrowtype, :json_populate_record_1) AS x
</pre>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">json_to_record()</tt> - this form uses a PostgreSQL specific form of derived
columns in the alias, where we may make use of <code>_sql.column</code> elements with
types to produce them.  The <code>_functions.FunctionElement.table_valued</code>
method produces  a <code>_sql.TableValuedAlias</code> construct, and the method
<code>_sql.TableValuedAlias.render_derived</code> method sets up the derived
columns specification:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy import select, func, column, Integer, Text
&gt;&gt;&gt; stmt = select(
...     func.json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}').table_valued(
...         column("a", Integer), column("b", Text), column("d", Text),
...     ).render_derived(name="x", with_types=True)
... )
&gt;&gt;&gt; print(stmt)
SELECT x.a, x.b, x.d
FROM json_to_record(:json_to_record_1) AS x(a INTEGER, b TEXT, d TEXT)
</pre>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">WITH ORDINALITY</tt> - part of the SQL standard, <tt class="rst-docutils literal">WITH ORDINALITY</tt> adds an
ordinal counter to the output of a function and is accepted by a limited set
of PostgreSQL functions including <tt class="rst-docutils literal">unnest()</tt> and <tt class="rst-docutils literal">generate_series()</tt>. The
<code>_functions.FunctionElement.table_valued</code> method accepts a keyword
parameter <tt class="rst-docutils literal">with_ordinality</tt> for this purpose, which accepts the string name
that will be applied to the "ordinality" column:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy import select, func
&gt;&gt;&gt; stmt = select(
...     func.generate_series(4, 1, -1).table_valued("value", with_ordinality="ordinality")
... )
&gt;&gt;&gt; print(stmt)
SELECT anon_1.value, anon_1.ordinality
FROM generate_series(:generate_series_1, :generate_series_2, :generate_series_3) WITH ORDINALITY AS anon_1
</pre>
</li>
</ul>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.0b2.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-27"><span class="rst-problematic" id="rst-problematic-27">:ref:`tutorial_functions_table_valued`</span></a> - in the <a href="#system-message-28"><span class="rst-problematic" id="rst-problematic-28">:ref:`unified_tutorial`</span></a></p>
</div>
</div>
<div class="rst-section" id="rst-column-valued-functions">
<span id="rst-postgresql-column-valued"></span><h3 class="heading">Column Valued Functions</h3>
<p>Similar to the table valued function, a column valued function is present
in the FROM clause, but delivers itself to the columns clause as a single
scalar value.  PostgreSQL functions such as <tt class="rst-docutils literal">json_array_elements()</tt>,
<tt class="rst-docutils literal">unnest()</tt> and <tt class="rst-docutils literal">generate_series()</tt> may use this form. Column valued functions are available using the
<code>_functions.FunctionElement.column_valued</code> method of <code>_functions.FunctionElement</code>:</p>
<ul>
<li><p class="rst-first"><tt class="rst-docutils literal">json_array_elements()</tt>:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy import select, func
&gt;&gt;&gt; stmt = select(func.json_array_elements('["one", "two"]').column_valued("x"))
&gt;&gt;&gt; print(stmt)
SELECT x
FROM json_array_elements(:json_array_elements_1) AS x
</pre>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">unnest()</tt> - in order to generate a PostgreSQL ARRAY literal, the
<code>_postgresql.array</code> construct may be used:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy.dialects.postgresql import array
&gt;&gt;&gt; from sqlalchemy import select, func
&gt;&gt;&gt; stmt = select(func.unnest(array([1, 2])).column_valued())
&gt;&gt;&gt; print(stmt)
SELECT anon_1
FROM unnest(ARRAY[%(param_1)s, %(param_2)s]) AS anon_1
</pre>
<p>The function can of course be used against an existing table-bound column
that's of type <code>_types.ARRAY</code>:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy import table, column, ARRAY, Integer
&gt;&gt;&gt; from sqlalchemy import select, func
&gt;&gt;&gt; t = table("t", column('value', ARRAY(Integer)))
&gt;&gt;&gt; stmt = select(func.unnest(t.c.value).column_valued("unnested_value"))
&gt;&gt;&gt; print(stmt)
SELECT unnested_value
FROM unnest(t.value) AS unnested_value
</pre>
</li>
</ul>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-29"><span class="rst-problematic" id="rst-problematic-29">:ref:`tutorial_functions_column_valued`</span></a> - in the <a href="#system-message-30"><span class="rst-problematic" id="rst-problematic-30">:ref:`unified_tutorial`</span></a></p>
</div>
</div>
<div class="rst-section" id="rst-row-types">
<h3 class="heading">Row Types</h3>
<p>Built-in support for rendering a <tt class="rst-docutils literal">ROW</tt> may be approximated using
<tt class="rst-docutils literal">func.ROW</tt> with the <code>_sa.func</code> namespace, or by using the
<code>_sql.tuple_</code> construct:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy import table, column, func, tuple_
&gt;&gt;&gt; t = table("t", column("id"), column("fk"))
&gt;&gt;&gt; stmt = t.select().where(
...     tuple_(t.c.id, t.c.fk) &gt; (1,2)
... ).where(
...     func.ROW(t.c.id, t.c.fk) &lt; func.ROW(3, 7)
... )
&gt;&gt;&gt; print(stmt)
SELECT t.id, t.fk
FROM t
WHERE (t.id, t.fk) &gt; (:param_1, :param_2) AND ROW(t.id, t.fk) &lt; ROW(:ROW_1, :ROW_2)
</pre>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a class="rst-reference external" href="https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" target="_top">PostgreSQL Row Constructors</a></p>
<p class="rst-last"><a class="rst-reference external" href="https://www.postgresql.org/docs/current/functions-comparisons.html#ROW-WISE-COMPARISON" target="_top">PostgreSQL Row Constructor Comparison</a></p>
</div>
</div>
<div class="rst-section" id="rst-table-types-passed-to-functions">
<h3 class="heading">Table Types passed to Functions</h3>
<p>PostgreSQL supports passing a table as an argument to a function, which it
refers towards as a "record" type. SQLAlchemy <code>_sql.FromClause</code> objects
such as <code>_schema.Table</code> support this special form using the
<code>_sql.FromClause.table_valued</code> method, which is comparable to the
<code>_functions.FunctionElement.table_valued</code> method except that the collection
of columns is already established by that of the <code>_sql.FromClause</code>
itself:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy import table, column, func, select
&gt;&gt;&gt; a = table( "a", column("id"), column("x"), column("y"))
&gt;&gt;&gt; stmt = select(func.row_to_json(a.table_valued()))
&gt;&gt;&gt; print(stmt)
SELECT row_to_json(a) AS row_to_json_1
FROM a
</pre>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.0b2.</span></div>
</div>
</div>
<div class="rst-section" id="rst-array-types">
<h2 class="heading">ARRAY Types</h2>
<p>The PostgreSQL dialect supports arrays, both as multidimensional column types
as well as array literals:</p>
<ul class="rst-simple">
<li><code>_postgresql.ARRAY</code> - ARRAY datatype</li>
<li><code>_postgresql.array</code> - array literal</li>
<li><code>_postgresql.array_agg</code> - ARRAY_AGG SQL function</li>
<li><code>_postgresql.aggregate_order_by</code> - helper for PG's ORDER BY aggregate
function syntax.</li>
</ul>
</div>
<div class="rst-section" id="rst-json-types">
<h2 class="heading">JSON Types</h2>
<p>The PostgreSQL dialect supports both JSON and JSONB datatypes, including
psycopg2's native support and support for all of PostgreSQL's special
operators:</p>
<ul class="rst-simple">
<li><code>_postgresql.JSON</code></li>
<li><code>_postgresql.JSONB</code></li>
</ul>
</div>
<div class="rst-section" id="rst-hstore-type">
<h2 class="heading">HSTORE Type</h2>
<p>The PostgreSQL HSTORE type as well as hstore literals are supported:</p>
<ul class="rst-simple">
<li><code>_postgresql.HSTORE</code> - HSTORE datatype</li>
<li><code>_postgresql.hstore</code> - hstore literal</li>
</ul>
</div>
<div class="rst-section" id="rst-enum-types">
<h2 class="heading">ENUM Types</h2>
<p>PostgreSQL has an independently creatable TYPE structure which is used
to implement an enumerated type.   This approach introduces significant
complexity on the SQLAlchemy side in terms of when this type should be
CREATED and DROPPED.   The type object is also an independently reflectable
entity.   The following sections should be consulted:</p>
<ul class="rst-simple">
<li><code>_postgresql.ENUM</code> - DDL and typing support for ENUM.</li>
<li><code>.PGInspector.get_enums</code> - retrieve a listing of current ENUM types</li>
<li><code>.postgresql.ENUM.create</code> , <code>.postgresql.ENUM.drop</code> - individual
CREATE and DROP commands for ENUM.</li>
</ul>
<div class="rst-section" id="rst-using-enum-with-array">
<span id="rst-postgresql-array-of-enum"></span><h3 class="heading">Using ENUM with ARRAY</h3>
<p>The combination of ENUM and ARRAY is not directly supported by backend
DBAPIs at this time.   Prior to SQLAlchemy 1.3.17, a special workaround
was needed in order to allow this combination to work, described below.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.3.17: </span><span>The combination of ENUM and ARRAY is now directly
handled by SQLAlchemy's implementation without any workarounds needed.</span></div>
<pre class="rst-code rst-python rst-literal-block">
from sqlalchemy import TypeDecorator
from sqlalchemy.dialects.postgresql import ARRAY

class ArrayOfEnum(TypeDecorator):
    impl = ARRAY

    def bind_expression(self, bindvalue):
        return sa.cast(bindvalue, self)

    def result_processor(self, dialect, coltype):
        super_rp = super(ArrayOfEnum, self).result_processor(
            dialect, coltype)

        def handle_raw_string(value):
            inner = re.match(r"^{(.*)}$", value).group(1)
            return inner.split(",") if inner else []

        def process(value):
            if value is None:
                return None
            return super_rp(handle_raw_string(value))
        return process
</pre>
<p>E.g.:</p>
<pre class="rst-literal-block">
Table(
    'mydata', metadata,
    Column('id', Integer, primary_key=True),
    Column('data', ArrayOfEnum(ENUM('a', 'b, 'c', name='myenum')))

)
</pre>
<p>This type is not included as a built-in type as it would be incompatible
with a DBAPI that suddenly decides to support ARRAY of ENUM directly in
a new version.</p>
</div>
<div class="rst-section" id="rst-using-json-jsonb-with-array">
<span id="rst-postgresql-array-of-json"></span><h3 class="heading">Using JSON/JSONB with ARRAY</h3>
<p>Similar to using ENUM, prior to SQLAlchemy 1.3.17, for an ARRAY of JSON/JSONB
we need to render the appropriate CAST.   Current psycopg2 drivers accommodate
the result set correctly without any special steps.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.3.17: </span><span>The combination of JSON/JSONB and ARRAY is now
directly handled by SQLAlchemy's implementation without any workarounds
needed.</span></div>
<pre class="rst-code rst-python rst-literal-block">
class CastingArray(ARRAY):
    def bind_expression(self, bindvalue):
        return sa.cast(bindvalue, self)
</pre>
<p>E.g.:</p>
<pre class="rst-literal-block">
Table(
    'mydata', metadata,
    Column('id', Integer, primary_key=True),
    Column('data', CastingArray(JSONB))
)
</pre>
</div>
</div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id18300">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.postgresql.PGCompiler.html" class="internal-link" title="sqlalchemy.databases.postgresql.PGCompiler">​PGCompiler</a></code></td>
    <td><span class="undocumented">No class docstring; 1/29 method documented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.postgresql.PGDDLCompiler.html" class="internal-link" title="sqlalchemy.databases.postgresql.PGDDLCompiler">​PGDDLCompiler</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.postgresql.PGDeferrableConnectionCharacteristic.html" class="internal-link" title="sqlalchemy.databases.postgresql.PGDeferrableConnectionCharacteristic">​PGDeferrable​Connection​Characteristic</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.postgresql.PGDialect.html" class="internal-link" title="sqlalchemy.databases.postgresql.PGDialect">​PGDialect</a></code></td>
    <td><span class="undocumented">No class docstring; 0/12 instance variable, 0/20 class variable, 1/38 method documented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.postgresql.PGExecutionContext.html" class="internal-link" title="sqlalchemy.databases.postgresql.PGExecutionContext">​PGExecution​Context</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.postgresql.PGIdentifierPreparer.html" class="internal-link" title="sqlalchemy.databases.postgresql.PGIdentifierPreparer">​PGIdentifier​Preparer</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.postgresql.PGInspector.html" class="internal-link" title="sqlalchemy.databases.postgresql.PGInspector">​PGInspector</a></code></td>
    <td><span class="undocumented">No class docstring; 4/4 methods documented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.postgresql.PGReadOnlyConnectionCharacteristic.html" class="internal-link" title="sqlalchemy.databases.postgresql.PGReadOnlyConnectionCharacteristic">​PGRead​Only​Connection​Characteristic</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.postgresql.PGTypeCompiler.html" class="internal-link" title="sqlalchemy.databases.postgresql.PGTypeCompiler">​PGType​Compiler</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#AUTOCOMMIT_REGEXP" class="internal-link" title="sqlalchemy.databases.postgresql.AUTOCOMMIT_REGEXP">AUTOCOMMIT​_REGEXP</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#IDX_USING" class="internal-link" title="sqlalchemy.databases.postgresql.IDX_USING">IDX​_USING</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#RESERVED_WORDS" class="internal-link" title="sqlalchemy.databases.postgresql.RESERVED_WORDS">RESERVED​_WORDS</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><code><a href="#colspecs" class="internal-link" title="sqlalchemy.databases.postgresql.colspecs">colspecs</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><code><a href="#ischema_names" class="internal-link" title="sqlalchemy.databases.postgresql.ischema_names">ischema​_names</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.postgresql._ColonCast.html" class="internal-link" title="sqlalchemy.databases.postgresql._ColonCast">_​Colon​Cast</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant private">
    
    <td>Constant</td>
    <td><code><a href="#_DECIMAL_TYPES" class="internal-link" title="sqlalchemy.databases.postgresql._DECIMAL_TYPES">​_DECIMAL​_TYPES</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant private">
    
    <td>Constant</td>
    <td><code><a href="#_FLOAT_TYPES" class="internal-link" title="sqlalchemy.databases.postgresql._FLOAT_TYPES">​_FLOAT​_TYPES</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant private">
    
    <td>Constant</td>
    <td><code><a href="#_INT_TYPES" class="internal-link" title="sqlalchemy.databases.postgresql._INT_TYPES">​_INT​_TYPES</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.postgresql.AUTOCOMMIT_REGEXP">
    
  </a>
  <a name="AUTOCOMMIT_REGEXP">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">AUTOCOMMIT_REGEXP</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/dialects/postgresql/base.py#L1414">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code><a href="https://docs.python.org/3/library/re.html#re.compile" class="intersphinx-link">re.compile</a>(r<span class="rst-variable-quote">'</span>\s<span class="rst-re-op">*</span><span class="rst-re-group">(?:</span>UPDATE<span class="rst-re-op">|</span>INSERT<span class="rst-re-op">|</span>CREATE<span class="rst-re-op">|</span>DELETE<span class="rst-re-op">|</span>DROP<span class="rst-re-op">|</span>ALTER<span class="rst-re-op">|</span>GRANT<span class="rst-re-op">|</span>REVOKE<span class="rst-re-op">|</span>IMPORT FO<span class="rst-variable-linewrap">↵</span>
REIGN SCHEMA<span class="rst-re-op">|</span>REFRESH MATERIALIZED VIEW<span class="rst-re-op">|</span>TRUNCATE<span class="rst-re-group">)</span><span class="rst-variable-quote">'</span>,
           <a href="https://docs.python.org/3/library/re.html#re.I" class="intersphinx-link">re.I</a>|re.UNICODE)</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.postgresql.IDX_USING">
    
  </a>
  <a name="IDX_USING">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">IDX_USING</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/dialects/postgresql/base.py#L1412">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code><a href="https://docs.python.org/3/library/re.html#re.compile" class="intersphinx-link">re.compile</a>(r<span class="rst-variable-quote">'</span>^<span class="rst-re-group">(?:</span>btree<span class="rst-re-op">|</span>hash<span class="rst-re-op">|</span>gist<span class="rst-re-op">|</span>gin<span class="rst-re-op">|</span><span class="rst-re-group">[</span>\w_<span class="rst-re-group">]</span><span class="rst-re-op">+</span><span class="rst-re-group">)</span>$<span class="rst-variable-quote">'</span>,
           <a href="https://docs.python.org/3/library/re.html#re.I" class="intersphinx-link">re.I</a>)</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.postgresql.RESERVED_WORDS">
    
  </a>
  <a name="RESERVED_WORDS">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">RESERVED_WORDS</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/dialects/postgresql/base.py#L1420">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code><a href="https://docs.python.org/3/library/stdtypes.html#set" class="intersphinx-link">set</a>(<wbr></wbr>[<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">all</span><span class="rst-variable-quote">'</span>,
     <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">analyse</span><span class="rst-variable-quote">'</span>,
     <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">analyze</span><span class="rst-variable-quote">'</span>,
     <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">and</span><span class="rst-variable-quote">'</span>,
     <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">any</span><span class="rst-variable-quote">'</span>,
     <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">array</span><span class="rst-variable-quote">'</span>,
     <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">as</span><span class="rst-variable-quote">'</span>,
<span class="rst-variable-ellipsis">...</span></code></pre></td></tr></table>
  </div>
</div><div class="basevariable">
  
  
  <a name="sqlalchemy.databases.postgresql.colspecs">
    
  </a>
  <a name="colspecs">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">colspecs</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/dialects/postgresql/base.py#L2076">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="basevariable">
  
  
  <a name="sqlalchemy.databases.postgresql.ischema_names">
    
  </a>
  <a name="ischema_names">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">ischema_names</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/dialects/postgresql/base.py#L2084">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseconstant private">
  
  
  <a name="sqlalchemy.databases.postgresql._DECIMAL_TYPES">
    
  </a>
  <a name="_DECIMAL_TYPES">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_DECIMAL_TYPES</span>: <code><a href="https://docs.python.org/3/library/stdtypes.html#tuple" class="intersphinx-link">tuple</a>[<wbr></wbr><a href="https://docs.python.org/3/library/functions.html#int" class="intersphinx-link">int</a>, <wbr></wbr><span class="rst-variable-ellipsis">...</span>]</code> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/dialects/postgresql/base.py#L1527">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>(<wbr></wbr>1231, <wbr></wbr>1700)</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant private">
  
  
  <a name="sqlalchemy.databases.postgresql._FLOAT_TYPES">
    
  </a>
  <a name="_FLOAT_TYPES">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_FLOAT_TYPES</span>: <code><a href="https://docs.python.org/3/library/stdtypes.html#tuple" class="intersphinx-link">tuple</a>[<wbr></wbr><a href="https://docs.python.org/3/library/functions.html#int" class="intersphinx-link">int</a>, <wbr></wbr><span class="rst-variable-ellipsis">...</span>]</code> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/dialects/postgresql/base.py#L1528">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>(<wbr></wbr>700, <wbr></wbr>701, <wbr></wbr>1021, <wbr></wbr>1022)</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant private">
  
  
  <a name="sqlalchemy.databases.postgresql._INT_TYPES">
    
  </a>
  <a name="_INT_TYPES">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_INT_TYPES</span>: <code><a href="https://docs.python.org/3/library/stdtypes.html#tuple" class="intersphinx-link">tuple</a>[<wbr></wbr><a href="https://docs.python.org/3/library/functions.html#int" class="intersphinx-link">int</a>, <wbr></wbr><span class="rst-variable-ellipsis">...</span>]</code> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/dialects/postgresql/base.py#L1529">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>(<wbr></wbr>20, <wbr></wbr>21, <wbr></wbr>23, <wbr></wbr>26, <wbr></wbr>1005, <wbr></wbr>1007, <wbr></wbr>1016)</code></pre></td></tr></table>
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 08:22:50.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>