<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.future.engine.Connection</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.future.html" class="internal-link" title="sqlalchemy.future">future</a></code><wbr></wbr>.<code><a href="sqlalchemy.future.engine.html" class="internal-link" title="sqlalchemy.future.engine">engine</a></code><wbr></wbr>.<code><a href="sqlalchemy.future.engine.Connection.html" class="internal-link" title="sqlalchemy.future.engine.Connection">Connection</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> <span class="py-defname">Connection</span>(<a href="sqlalchemy.engine.base.Connection.html" class="internal-link" title="sqlalchemy.engine.Connection">_LegacyConnection</a>):</code></p>
        <p><a href="classIndex.html#sqlalchemy.future.engine.Connection">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p>Provides high-level functionality for a wrapped DB-API connection.</p>
<p>The <code>_future.Connection</code> object is procured by calling
the <code>_future.Engine.connect</code> method of the <code>_future.Engine</code>
object, and provides services for execution of SQL statements as well
as transaction control.</p>
<p><strong>This is the SQLAlchemy 2.0 version</strong> of the <code>_engine.Connection</code>
class.   The API and behavior of this object is largely the same, with the
following differences in behavior:</p>
<ul class="rst-simple">
<li>The result object returned for results is the
<code>_engine.CursorResult</code>
object, which is a subclass of the <code>_engine.Result</code>.
This object has a slightly different API and behavior than the
<code>_engine.LegacyCursorResult</code> returned for 1.x style usage.</li>
<li>The object has <code>_future.Connection.commit</code> and
<code>_future.Connection.rollback</code> methods which commit or roll back
the current transaction in progress, if any.</li>
<li>The object features "autobegin" behavior, such that any call to
<code>_future.Connection.execute</code> will
unconditionally start a
transaction which can be controlled using the above mentioned
<code>_future.Connection.commit</code> and
<code>_future.Connection.rollback</code> methods.</li>
<li>The object does not have any "autocommit" functionality.  Any SQL
statement or DDL statement will not be followed by any COMMIT until
the transaction is explicitly committed, either via the
<code>_future.Connection.commit</code> method, or if the connection is
being used in a context manager that commits such as the one
returned by <code>_future.Engine.begin</code>.</li>
<li>The SAVEPOINT method <code>_future.Connection.begin_nested</code> returns
a <code>_engine.NestedTransaction</code> as was always the case, and the
savepoint can be controlled by invoking
<code>_engine.NestedTransaction.commit</code> or
<code>_engine.NestedTransaction.rollback</code> as was the case before.
However, this savepoint "transaction" is not associated with the
transaction that is controlled by the connection itself; the overall
transaction can be committed or rolled back directly which will not emit
any special instructions for the SAVEPOINT (this will typically have the
effect that one desires).</li>
<li>The <code>_future.Connection</code> object does not support "branching",
which was a pattern by which a sub "connection" would be used that
refers to this connection as a parent.</li>
</ul>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id16651">
  
  
  <tr class="method">
    
    <td>Method</td>
    <td><code><a href="#begin" class="internal-link" title="sqlalchemy.future.engine.Connection.begin">begin</a></code></td>
    <td>Begin a transaction prior to autobegin occurring.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#begin_nested" class="internal-link" title="sqlalchemy.future.engine.Connection.begin_nested">begin​_nested</a></code></td>
    <td>Begin a nested transaction (i.e. SAVEPOINT) and return a transaction handle.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#close" class="internal-link" title="sqlalchemy.future.engine.Connection.close">close</a></code></td>
    <td>Close this <code>_future.Connection</code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#commit" class="internal-link" title="sqlalchemy.future.engine.Connection.commit">commit</a></code></td>
    <td>Commit the transaction that is currently in progress.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#execute" class="internal-link" title="sqlalchemy.future.engine.Connection.execute">execute</a></code></td>
    <td>Executes a SQL statement construct and returns a <code>_engine.Result</code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#rollback" class="internal-link" title="sqlalchemy.future.engine.Connection.rollback">rollback</a></code></td>
    <td>Roll back the transaction that is currently in progress.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#scalar" class="internal-link" title="sqlalchemy.future.engine.Connection.scalar">scalar</a></code></td>
    <td>Executes a SQL statement construct and returns a scalar object.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_branch" class="internal-link" title="sqlalchemy.future.engine.Connection._branch">​_branch</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable private">
    
    <td>Class Variable</td>
    <td><code><a href="#_is_future" class="internal-link" title="sqlalchemy.future.engine.Connection._is_future">​_is​_future</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  
  <a name="sqlalchemy.future.engine.Connection.begin">
    
  </a>
  <a name="begin">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">begin</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Begin a transaction prior to autobegin occurring.</p>
<p>The returned object is an instance of <code>_engine.RootTransaction</code>.
This object represents the "scope" of the transaction,
which completes when either the <code>_engine.Transaction.rollback</code>
or <code>_engine.Transaction.commit</code> method is called.</p>
<p>The <code>_future.Connection.begin</code> method in SQLAlchemy 2.0 begins a
transaction that normally will be begun in any case when the connection
is first used to execute a statement.  The reason this method might be
used would be to invoke the <code>_events.ConnectionEvents.begin</code>
event at a specific time, or to organize code within the scope of a
connection checkout in terms of context managed blocks, such as:</p>
<pre class="rst-literal-block">
with engine.connect() as conn:
    with conn.begin():
        conn.execute(...)
        conn.execute(...)

    with conn.begin():
        conn.execute(...)
        conn.execute(...)
</pre>
<p>The above code is not  fundamentally any different in its behavior than
the following code  which does not use
<code>_future.Connection.begin</code>; the below style is referred towards
as "commit as you go" style:</p>
<pre class="rst-literal-block">
with engine.connect() as conn:
    conn.execute(...)
    conn.execute(...)
    conn.commit()

    conn.execute(...)
    conn.execute(...)
    conn.commit()
</pre>
<p>From a database point of view, the <code>_future.Connection.begin</code>
method does not emit any SQL or change the state of the underlying
DBAPI connection in any way; the Python DBAPI does not have any
concept of explicit transaction begin.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`tutorial_working_with_transactions`</span></a> - in the
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`unified_tutorial`</span></a></p>
<p><code>_future.Connection.begin_nested</code> - use a SAVEPOINT</p>
<p><code>_engine.Connection.begin_twophase</code> -
use a two phase /XID transaction</p>
<p class="rst-last"><code>_future.Engine.begin</code> - context manager available from
<code>_future.Engine</code></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.future.engine.Connection.begin_nested">
    
  </a>
  <a name="begin_nested">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">begin_nested</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Begin a nested transaction (i.e. SAVEPOINT) and return a transaction
handle.</p>
<p>The returned object is an instance of
<code>_engine.NestedTransaction</code>.</p>
<p>Nested transactions require SAVEPOINT support in the
underlying database.  Any transaction in the hierarchy may
<tt class="rst-docutils literal">commit</tt> and <tt class="rst-docutils literal">rollback</tt>, however the outermost transaction
still controls the overall <tt class="rst-docutils literal">commit</tt> or <tt class="rst-docutils literal">rollback</tt> of the
transaction of a whole.</p>
<p>If an outer <code>.RootTransaction</code> is not present on this
<code>_future.Connection</code>, a new one is created using "autobegin".
This outer transaction may be completed using "commit-as-you-go" style
usage, by calling upon <code>_future.Connection.commit</code> or
<code>_future.Connection.rollback</code>.</p>
<div class="rst-admonition tip">
<p class="rst-first rst-admonition-title">Tip</p>
<p class="rst-last">The "autobegin" behavior of <code>_future.Connection.begin_nested</code>
is specific to <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:term:`2.0 style`</span></a> use; for legacy behaviors, see
<code>_engine.Connection.begin_nested</code>.</p>
</div>
<p>The <code>_engine.NestedTransaction</code> remains independent of the
<code>_future.Connection</code> object itself. Calling the
<code>_future.Connection.commit</code> or
<code>_future.Connection.rollback</code> will always affect the actual
containing database transaction itself, and not the SAVEPOINT itself.
When a database transaction is committed, any SAVEPOINTs that have been
established are cleared and the data changes within their scope is also
committed.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_future.Connection.begin</code></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.future.engine.Connection.close">
    
  </a>
  <a name="close">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">close</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Close this <code>_future.Connection</code>.</p>
<p>This has the effect of also calling <code>_future.Connection.rollback</code>
if any transaction is in place.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.future.engine.Connection.commit">
    
  </a>
  <a name="commit">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">commit</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Commit the transaction that is currently in progress.</p>
<p>This method commits the current transaction if one has been started.
If no transaction was started, the method has no effect, assuming
the connection is in a non-invalidated state.</p>
<p>A transaction is begun on a <code>_future.Connection</code> automatically
whenever a statement is first executed, or when the
<code>_future.Connection.begin</code> method is called.</p>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p class="rst-last">The <code>_future.Connection.commit</code> method only acts upon
the primary database transaction that is linked to the
<code>_future.Connection</code> object.  It does not operate upon a
SAVEPOINT that would have been invoked from the
<code>_future.Connection.begin_nested</code> method; for control of a
SAVEPOINT, call <code>_engine.NestedTransaction.commit</code> on the
<code>_engine.NestedTransaction</code> that is returned by the
<code>_future.Connection.begin_nested</code> method itself.</p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.future.engine.Connection.execute">
    
  </a>
  <a name="execute">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">execute</span>(self, statement, parameters=None, execution_options=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Executes a SQL statement construct and returns a
<code>_engine.Result</code>.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">statement</span></td><td class="fieldArgDesc"><p>The statement to be executed.  This is always
an object that is in both the <code>_expression.ClauseElement</code> and
<code>_expression.Executable</code> hierarchies, including:</p>
<ul class="rst-simple">
<li><code>_expression.Select</code></li>
<li><code>_expression.Insert</code>, <code>_expression.Update</code>,
<code>_expression.Delete</code></li>
<li><code>_expression.TextClause</code> and
<code>_expression.TextualSelect</code></li>
<li><code>_schema.DDL</code> and objects which inherit from
<code>_schema.DDLElement</code></li>
</ul>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">parameters</span></td><td class="fieldArgDesc">parameters which will be bound into the statement.
This may be either a dictionary of parameter names to values,
or a mutable sequence (e.g. a list) of dictionaries.  When a
list of dictionaries is passed, the underlying statement execution
will make use of the DBAPI <tt class="rst-docutils literal">cursor.executemany()</tt> method.
When a single dictionary is passed, the DBAPI <tt class="rst-docutils literal">cursor.execute()</tt>
method will be used.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">execution​_options</span></td><td class="fieldArgDesc">optional dictionary of execution options,
which will be associated with the statement execution.  This
dictionary can provide a subset of the options that are accepted
by <code>_future.Connection.execution_options</code>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code>_engine.Result</code> object.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.future.engine.Connection.rollback">
    
  </a>
  <a name="rollback">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rollback</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Roll back the transaction that is currently in progress.</p>
<p>This method rolls back the current transaction if one has been started.
If no transaction was started, the method has no effect.  If a
transaction was started and the connection is in an invalidated state,
the transaction is cleared using this method.</p>
<p>A transaction is begun on a <code>_future.Connection</code> automatically
whenever a statement is first executed, or when the
<code>_future.Connection.begin</code> method is called.</p>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p class="rst-last">The <code>_future.Connection.rollback</code> method only acts
upon the primary database transaction that is linked to the
<code>_future.Connection</code> object.  It does not operate upon a
SAVEPOINT that would have been invoked from the
<code>_future.Connection.begin_nested</code> method; for control of a
SAVEPOINT, call <code>_engine.NestedTransaction.rollback</code> on the
<code>_engine.NestedTransaction</code> that is returned by the
<code>_future.Connection.begin_nested</code> method itself.</p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.future.engine.Connection.scalar">
    
  </a>
  <a name="scalar">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">scalar</span>(self, statement, parameters=None, execution_options=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Executes a SQL statement construct and returns a scalar object.</p>
<p>This method is shorthand for invoking the
<code>_engine.Result.scalar</code> method after invoking the
<code>_future.Connection.execute</code> method.  Parameters are equivalent.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a scalar Python value representing the first column of the
first row returned.</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.future.engine.Connection._branch">
    
  </a>
  <a name="_branch">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_branch</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="baseclassvariable private">
  
  
  <a name="sqlalchemy.future.engine.Connection._is_future">
    
  </a>
  <a name="_is_future">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_is_future</span>: <code>bool</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 04:41:59.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>