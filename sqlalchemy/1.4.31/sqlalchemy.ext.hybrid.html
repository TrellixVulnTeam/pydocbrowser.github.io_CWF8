<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.ext.hybrid</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.ext.html" class="internal-link" title="sqlalchemy.ext">ext</a></code><wbr></wbr>.<code><a href="sqlalchemy.ext.hybrid.html" class="internal-link" title="sqlalchemy.ext.hybrid">hybrid</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p>Define attributes on ORM-mapped classes that have "hybrid" behavior.</p>
<p>"hybrid" means the attribute has distinct behaviors defined at the
class level and at the instance level.</p>
<p>The <code>~sqlalchemy.ext.hybrid</code> extension provides a special form of
method decorator, is around 50 lines of code and has almost no
dependencies on the rest of SQLAlchemy.  It can, in theory, work with
any descriptor-based expression system.</p>
<p>Consider a mapping <tt class="rst-docutils literal">Interval</tt>, representing integer <tt class="rst-docutils literal">start</tt> and <tt class="rst-docutils literal">end</tt>
values. We can define higher level functions on mapped classes that produce SQL
expressions at the class level, and Python expression evaluation at the
instance level.  Below, each function decorated with <code>.hybrid_method</code> or
<code>.hybrid_property</code> may receive <tt class="rst-docutils literal">self</tt> as an instance of the class, or
as the class itself:</p>
<pre class="rst-literal-block">
from sqlalchemy import Column, Integer
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import Session, aliased
from sqlalchemy.ext.hybrid import hybrid_property, hybrid_method

Base = declarative_base()

class Interval(Base):
    __tablename__ = 'interval'

    id = Column(Integer, primary_key=True)
    start = Column(Integer, nullable=False)
    end = Column(Integer, nullable=False)

    def __init__(self, start, end):
        self.start = start
        self.end = end

    @hybrid_property
    def length(self):
        return self.end - self.start

    @hybrid_method
    def contains(self, point):
        return (self.start &lt;= point) &amp; (point &lt;= self.end)

    @hybrid_method
    def intersects(self, other):
        return self.contains(other.start) | self.contains(other.end)
</pre>
<p>Above, the <tt class="rst-docutils literal">length</tt> property returns the difference between the
<tt class="rst-docutils literal">end</tt> and <tt class="rst-docutils literal">start</tt> attributes.  With an instance of <tt class="rst-docutils literal">Interval</tt>,
this subtraction occurs in Python, using normal Python descriptor
mechanics:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; i1 = Interval(5, 10)
&gt;&gt;&gt; i1.length
5
</pre>
<p>When dealing with the <tt class="rst-docutils literal">Interval</tt> class itself, the <code>.hybrid_property</code>
descriptor evaluates the function body given the <tt class="rst-docutils literal">Interval</tt> class as
the argument, which when evaluated with SQLAlchemy expression mechanics
(here using the <code>.QueryableAttribute.expression</code> accessor)
returns a new SQL expression:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; print(Interval.length.expression)
interval."end" - interval.start

&gt;&gt;&gt; print(Session().query(Interval).filter(Interval.length &gt; 10))
SELECT interval.id AS interval_id, interval.start AS interval_start,
interval."end" AS interval_end
FROM interval
WHERE interval."end" - interval.start &gt; :param_1
</pre>
<p>ORM methods such as <code>_query.Query.filter_by</code>
generally use <tt class="rst-docutils literal">getattr()</tt> to
locate attributes, so can also be used with hybrid attributes:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; print(Session().query(Interval).filter_by(length=5))
SELECT interval.id AS interval_id, interval.start AS interval_start,
interval."end" AS interval_end
FROM interval
WHERE interval."end" - interval.start = :param_1
</pre>
<p>The <tt class="rst-docutils literal">Interval</tt> class example also illustrates two methods,
<tt class="rst-docutils literal">contains()</tt> and <tt class="rst-docutils literal">intersects()</tt>, decorated with
<code>.hybrid_method</code>. This decorator applies the same idea to
methods that <code>.hybrid_property</code> applies to attributes.   The
methods return boolean values, and take advantage of the Python <tt class="rst-docutils literal">|</tt>
and <tt class="rst-docutils literal">&amp;</tt> bitwise operators to produce equivalent instance-level and
SQL expression-level boolean behavior:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; i1.contains(6)
True
&gt;&gt;&gt; i1.contains(15)
False
&gt;&gt;&gt; i1.intersects(Interval(7, 18))
True
&gt;&gt;&gt; i1.intersects(Interval(25, 29))
False

&gt;&gt;&gt; print(Session().query(Interval).filter(Interval.contains(15)))
SELECT interval.id AS interval_id, interval.start AS interval_start,
interval."end" AS interval_end
FROM interval
WHERE interval.start &lt;= :start_1 AND interval."end" &gt; :end_1

&gt;&gt;&gt; ia = aliased(Interval)
&gt;&gt;&gt; print(Session().query(Interval, ia).filter(Interval.intersects(ia)))
SELECT interval.id AS interval_id, interval.start AS interval_start,
interval."end" AS interval_end, interval_1.id AS interval_1_id,
interval_1.start AS interval_1_start, interval_1."end" AS interval_1_end
FROM interval, interval AS interval_1
WHERE interval.start &lt;= interval_1.start
    AND interval."end" &gt; interval_1.start
    OR interval.start &lt;= interval_1."end"
    AND interval."end" &gt; interval_1."end"
</pre>
<div class="rst-section" id="rst-defining-expression-behavior-distinct-from-attribute-behavior">
<span id="rst-hybrid-distinct-expression"></span><h2 class="heading">Defining Expression Behavior Distinct from Attribute Behavior</h2>
<p>Our usage of the <tt class="rst-docutils literal">&amp;</tt> and <tt class="rst-docutils literal">|</tt> bitwise operators above was
fortunate, considering our functions operated on two boolean values to
return a new one.   In many cases, the construction of an in-Python
function and a SQLAlchemy SQL expression have enough differences that
two separate Python expressions should be defined.  The
<code>~sqlalchemy.ext.hybrid</code> decorators define the
<code>.hybrid_property.expression</code> modifier for this purpose.   As an
example we'll define the radius of the interval, which requires the
usage of the absolute value function:</p>
<pre class="rst-literal-block">
from sqlalchemy import func

class Interval(object):
    # ...

    @hybrid_property
    def radius(self):
        return abs(self.length) / 2

    @radius.expression
    def radius(cls):
        return func.abs(cls.length) / 2
</pre>
<p>Above the Python function <tt class="rst-docutils literal">abs()</tt> is used for instance-level
operations, the SQL function <tt class="rst-docutils literal">ABS()</tt> is used via the <code>.func</code>
object for class-level expressions:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; i1.radius
2

&gt;&gt;&gt; print(Session().query(Interval).filter(Interval.radius &gt; 5))
SELECT interval.id AS interval_id, interval.start AS interval_start,
    interval."end" AS interval_end
FROM interval
WHERE abs(interval."end" - interval.start) / :abs_1 &gt; :param_1
</pre>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p>When defining an expression for a hybrid property or method, the
expression method <strong>must</strong> retain the name of the original hybrid, else
the new hybrid with the additional state will be attached to the class
with the non-matching name. To use the example above:</p>
<pre class="rst-literal-block">
class Interval(object):
    # ...

    @hybrid_property
    def radius(self):
        return abs(self.length) / 2

    # WRONG - the non-matching name will cause this function to be
    # ignored
    @radius.expression
    def radius_expression(cls):
        return func.abs(cls.length) / 2
</pre>
<p class="rst-last">This is also true for other mutator methods, such as
<code>.hybrid_property.update_expression</code>. This is the same behavior
as that of the <tt class="rst-docutils literal">@property</tt> construct that is part of standard Python.</p>
</div>
</div>
<div class="rst-section" id="rst-defining-setters">
<h2 class="heading">Defining Setters</h2>
<p>Hybrid properties can also define setter methods.  If we wanted
<tt class="rst-docutils literal">length</tt> above, when set, to modify the endpoint value:</p>
<pre class="rst-literal-block">
class Interval(object):
    # ...

    @hybrid_property
    def length(self):
        return self.end - self.start

    @length.setter
    def length(self, value):
        self.end = self.start + value
</pre>
<p>The <tt class="rst-docutils literal">length(self, value)</tt> method is now called upon set:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; i1 = Interval(5, 10)
&gt;&gt;&gt; i1.length
5
&gt;&gt;&gt; i1.length = 12
&gt;&gt;&gt; i1.end
17
</pre>
</div>
<div class="rst-section" id="rst-allowing-bulk-orm-update">
<span id="rst-hybrid-bulk-update"></span><h2 class="heading">Allowing Bulk ORM Update</h2>
<p>A hybrid can define a custom "UPDATE" handler for when using the
<code>_query.Query.update</code> method, allowing the hybrid to be used in the
SET clause of the update.</p>
<p>Normally, when using a hybrid with <code>_query.Query.update</code>, the SQL
expression is used as the column that's the target of the SET.  If our
<tt class="rst-docutils literal">Interval</tt> class had a hybrid <tt class="rst-docutils literal">start_point</tt> that linked to
<tt class="rst-docutils literal">Interval.start</tt>, this could be substituted directly:</p>
<pre class="rst-literal-block">
session.query(Interval).update({Interval.start_point: 10})
</pre>
<p>However, when using a composite hybrid like <tt class="rst-docutils literal">Interval.length</tt>, this
hybrid represents more than one column.   We can set up a handler that will
accommodate a value passed to <code>_query.Query.update</code> which can affect
this, using the <code>.hybrid_property.update_expression</code> decorator.
A handler that works similarly to our setter would be:</p>
<pre class="rst-literal-block">
class Interval(object):
    # ...

    @hybrid_property
    def length(self):
        return self.end - self.start

    @length.setter
    def length(self, value):
        self.end = self.start + value

    @length.update_expression
    def length(cls, value):
        return [
            (cls.end, cls.start + value)
        ]
</pre>
<p>Above, if we use <tt class="rst-docutils literal">Interval.length</tt> in an UPDATE expression as:</p>
<pre class="rst-literal-block">
session.query(Interval).update(
    {Interval.length: 25}, synchronize_session='fetch')
</pre>
<p>We'll get an UPDATE statement along the lines of:</p>
<pre class="rst-literal-block">
UPDATE interval SET end=start + :value
</pre>
<p>In some cases, the default "evaluate" strategy can't perform the SET
expression in Python; while the addition operator we're using above
is supported, for more complex SET expressions it will usually be necessary
to use either the "fetch" or False synchronization strategy as illustrated
above.</p>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p>For ORM bulk updates to work with hybrids, the function name
of the hybrid must match that of how it is accessed.    Something
like this wouldn't work:</p>
<pre class="rst-last rst-literal-block">
    class Interval(object):
        # ...

        def _get(self):
            return self.end - self.start

        def _set(self, value):
            self.end = self.start + value

        def _update_expr(cls, value):
            return [
                (cls.end, cls.start + value)
            ]

        length = hybrid_property(
            fget=_get, fset=_set, update_expr=_update_expr
        )

The Python descriptor protocol does not provide any reliable way for
a descriptor to know what attribute name it was accessed as, and
the UPDATE scheme currently relies upon being able to access the
attribute from an instance by name in order to perform the instance
synchronization step.
</pre>
</div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.2: </span><span>added support for bulk updates to hybrid properties.</span></div>
</div>
<div class="rst-section" id="rst-working-with-relationships">
<h2 class="heading">Working with Relationships</h2>
<p>There's no essential difference when creating hybrids that work with
related objects as opposed to column-based data. The need for distinct
expressions tends to be greater.  The two variants we'll illustrate
are the "join-dependent" hybrid, and the "correlated subquery" hybrid.</p>
<div class="rst-section" id="rst-join-dependent-relationship-hybrid">
<h3 class="heading">Join-Dependent Relationship Hybrid</h3>
<p>Consider the following declarative
mapping which relates a <tt class="rst-docutils literal">User</tt> to a <tt class="rst-docutils literal">SavingsAccount</tt>:</p>
<pre class="rst-literal-block">
from sqlalchemy import Column, Integer, ForeignKey, Numeric, String
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.ext.hybrid import hybrid_property

Base = declarative_base()

class SavingsAccount(Base):
    __tablename__ = 'account'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('user.id'), nullable=False)
    balance = Column(Numeric(15, 5))

class User(Base):
    __tablename__ = 'user'
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)

    accounts = relationship("SavingsAccount", backref="owner")

    @hybrid_property
    def balance(self):
        if self.accounts:
            return self.accounts[0].balance
        else:
            return None

    @balance.setter
    def balance(self, value):
        if not self.accounts:
            account = Account(owner=self)
        else:
            account = self.accounts[0]
        account.balance = value

    @balance.expression
    def balance(cls):
        return SavingsAccount.balance
</pre>
<p>The above hybrid property <tt class="rst-docutils literal">balance</tt> works with the first
<tt class="rst-docutils literal">SavingsAccount</tt> entry in the list of accounts for this user.   The
in-Python getter/setter methods can treat <tt class="rst-docutils literal">accounts</tt> as a Python
list available on <tt class="rst-docutils literal">self</tt>.</p>
<p>However, at the expression level, it's expected that the <tt class="rst-docutils literal">User</tt> class will
be used in an appropriate context such that an appropriate join to
<tt class="rst-docutils literal">SavingsAccount</tt> will be present:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; print(Session().query(User, User.balance).
...       join(User.accounts).filter(User.balance &gt; 5000))
SELECT "user".id AS user_id, "user".name AS user_name,
account.balance AS account_balance
FROM "user" JOIN account ON "user".id = account.user_id
WHERE account.balance &gt; :balance_1
</pre>
<p>Note however, that while the instance level accessors need to worry
about whether <tt class="rst-docutils literal">self.accounts</tt> is even present, this issue expresses
itself differently at the SQL expression level, where we basically
would use an outer join:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from sqlalchemy import or_
&gt;&gt;&gt; print (Session().query(User, User.balance).outerjoin(User.accounts).
...         filter(or_(User.balance &lt; 5000, User.balance == None)))
SELECT "user".id AS user_id, "user".name AS user_name,
account.balance AS account_balance
FROM "user" LEFT OUTER JOIN account ON "user".id = account.user_id
WHERE account.balance &lt;  :balance_1 OR account.balance IS NULL
</pre>
</div>
<div class="rst-section" id="rst-correlated-subquery-relationship-hybrid">
<h3 class="heading">Correlated Subquery Relationship Hybrid</h3>
<p>We can, of course, forego being dependent on the enclosing query's usage
of joins in favor of the correlated subquery, which can portably be packed
into a single column expression. A correlated subquery is more portable, but
often performs more poorly at the SQL level. Using the same technique
illustrated at <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`mapper_column_property_sql_expressions`</span></a>,
we can adjust our <tt class="rst-docutils literal">SavingsAccount</tt> example to aggregate the balances for
<em>all</em> accounts, and use a correlated subquery for the column expression:</p>
<pre class="rst-literal-block">
from sqlalchemy import Column, Integer, ForeignKey, Numeric, String
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy import select, func

Base = declarative_base()

class SavingsAccount(Base):
    __tablename__ = 'account'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('user.id'), nullable=False)
    balance = Column(Numeric(15, 5))

class User(Base):
    __tablename__ = 'user'
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)

    accounts = relationship("SavingsAccount", backref="owner")

    @hybrid_property
    def balance(self):
        return sum(acc.balance for acc in self.accounts)

    @balance.expression
    def balance(cls):
        return select(func.sum(SavingsAccount.balance)).\
                where(SavingsAccount.user_id==cls.id).\
                label('total_balance')
</pre>
<p>The above recipe will give us the <tt class="rst-docutils literal">balance</tt> column which renders
a correlated SELECT:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; print(s.query(User).filter(User.balance &gt; 400))
SELECT "user".id AS user_id, "user".name AS user_name
FROM "user"
WHERE (SELECT sum(account.balance) AS sum_1
FROM account
WHERE account.user_id = "user".id) &gt; :param_1
</pre>
</div>
</div>
<div class="rst-section" id="rst-building-custom-comparators">
<span id="rst-hybrid-custom-comparators"></span><h2 class="heading">Building Custom Comparators</h2>
<p>The hybrid property also includes a helper that allows construction of
custom comparators. A comparator object allows one to customize the
behavior of each SQLAlchemy expression operator individually.  They
are useful when creating custom types that have some highly
idiosyncratic behavior on the SQL side.</p>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p class="rst-last">The <code>.hybrid_property.comparator</code> decorator introduced
in this section <strong>replaces</strong> the use of the
<code>.hybrid_property.expression</code> decorator.
They cannot be used together.</p>
</div>
<p>The example class below allows case-insensitive comparisons on the attribute
named <tt class="rst-docutils literal">word_insensitive</tt>:</p>
<pre class="rst-literal-block">
from sqlalchemy.ext.hybrid import Comparator, hybrid_property
from sqlalchemy import func, Column, Integer, String
from sqlalchemy.orm import Session
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class CaseInsensitiveComparator(Comparator):
    def __eq__(self, other):
        return func.lower(self.__clause_element__()) == func.lower(other)

class SearchWord(Base):
    __tablename__ = 'searchword'
    id = Column(Integer, primary_key=True)
    word = Column(String(255), nullable=False)

    @hybrid_property
    def word_insensitive(self):
        return self.word.lower()

    @word_insensitive.comparator
    def word_insensitive(cls):
        return CaseInsensitiveComparator(cls.word)
</pre>
<p>Above, SQL expressions against <tt class="rst-docutils literal">word_insensitive</tt> will apply the <tt class="rst-docutils literal">LOWER()</tt>
SQL function to both sides:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; print(Session().query(SearchWord).filter_by(word_insensitive="Trucks"))
SELECT searchword.id AS searchword_id, searchword.word AS searchword_word
FROM searchword
WHERE lower(searchword.word) = lower(:lower_1)
</pre>
<p>The <tt class="rst-docutils literal">CaseInsensitiveComparator</tt> above implements part of the
<code>.ColumnOperators</code> interface.   A "coercion" operation like
lowercasing can be applied to all comparison operations (i.e. <tt class="rst-docutils literal">eq</tt>,
<tt class="rst-docutils literal">lt</tt>, <tt class="rst-docutils literal">gt</tt>, etc.) using <code>.Operators.operate</code>:</p>
<pre class="rst-literal-block">
class CaseInsensitiveComparator(Comparator):
    def operate(self, op, other):
        return op(func.lower(self.__clause_element__()), func.lower(other))
</pre>
</div>
<div class="rst-section" id="rst-reusing-hybrid-properties-across-subclasses">
<span id="rst-hybrid-reuse-subclass"></span><h2 class="heading">Reusing Hybrid Properties across Subclasses</h2>
<p>A hybrid can be referred to from a superclass, to allow modifying
methods like <code>.hybrid_property.getter</code>, <code>.hybrid_property.setter</code>
to be used to redefine those methods on a subclass.  This is similar to
how the standard Python <tt class="rst-docutils literal">@property</tt> object works:</p>
<pre class="rst-literal-block">
class FirstNameOnly(Base):
    # ...

    first_name = Column(String)

    @hybrid_property
    def name(self):
        return self.first_name

    @name.setter
    def name(self, value):
        self.first_name = value

class FirstNameLastName(FirstNameOnly):
    # ...

    last_name = Column(String)

    @FirstNameOnly.name.getter
    def name(self):
        return self.first_name + ' ' + self.last_name

    @name.setter
    def name(self, value):
        self.first_name, self.last_name = value.split(' ', 1)
</pre>
<p>Above, the <tt class="rst-docutils literal">FirstNameLastName</tt> class refers to the hybrid from
<tt class="rst-docutils literal">FirstNameOnly.name</tt> to repurpose its getter and setter for the subclass.</p>
<p>When overriding <code>.hybrid_property.expression</code> and
<code>.hybrid_property.comparator</code> alone as the first reference to the
superclass, these names conflict with the same-named accessors on the class-
level <code>.QueryableAttribute</code> object returned at the class level.  To
override these methods when referring directly to the parent class descriptor,
add the special qualifier <code>.hybrid_property.overrides</code>, which will de-
reference the instrumented attribute back to the hybrid object:</p>
<pre class="rst-literal-block">
class FirstNameLastName(FirstNameOnly):
    # ...

    last_name = Column(String)

    @FirstNameOnly.name.overrides.expression
    def name(cls):
        return func.concat(cls.first_name, ' ', cls.last_name)
</pre>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.2: </span><span>Added <code>.hybrid_property.getter</code> as well as the
ability to redefine accessors per-subclass.</span></div>
</div>
<div class="rst-section" id="rst-hybrid-value-objects">
<h2 class="heading">Hybrid Value Objects</h2>
<p>Note in our previous example, if we were to compare the <tt class="rst-docutils literal">word_insensitive</tt>
attribute of a <tt class="rst-docutils literal">SearchWord</tt> instance to a plain Python string, the plain
Python string would not be coerced to lower case - the
<tt class="rst-docutils literal">CaseInsensitiveComparator</tt> we built, being returned by
<tt class="rst-docutils literal">@word_insensitive.comparator</tt>, only applies to the SQL side.</p>
<p>A more comprehensive form of the custom comparator is to construct a <em>Hybrid
Value Object</em>. This technique applies the target value or expression to a value
object which is then returned by the accessor in all cases.   The value object
allows control of all operations upon the value as well as how compared values
are treated, both on the SQL expression side as well as the Python value side.
Replacing the previous <tt class="rst-docutils literal">CaseInsensitiveComparator</tt> class with a new
<tt class="rst-docutils literal">CaseInsensitiveWord</tt> class:</p>
<pre class="rst-literal-block">
class CaseInsensitiveWord(Comparator):
    "Hybrid value representing a lower case representation of a word."

    def __init__(self, word):
        if isinstance(word, basestring):
            self.word = word.lower()
        elif isinstance(word, CaseInsensitiveWord):
            self.word = word.word
        else:
            self.word = func.lower(word)

    def operate(self, op, other):
        if not isinstance(other, CaseInsensitiveWord):
            other = CaseInsensitiveWord(other)
        return op(self.word, other.word)

    def __clause_element__(self):
        return self.word

    def __str__(self):
        return self.word

    key = 'word'
    "Label to apply to Query tuple results"
</pre>
<p>Above, the <tt class="rst-docutils literal">CaseInsensitiveWord</tt> object represents <tt class="rst-docutils literal">self.word</tt>, which may
be a SQL function, or may be a Python native.   By overriding <tt class="rst-docutils literal">operate()</tt> and
<tt class="rst-docutils literal">__clause_element__()</tt> to work in terms of <tt class="rst-docutils literal">self.word</tt>, all comparison
operations will work against the "converted" form of <tt class="rst-docutils literal">word</tt>, whether it be
SQL side or Python side. Our <tt class="rst-docutils literal">SearchWord</tt> class can now deliver the
<tt class="rst-docutils literal">CaseInsensitiveWord</tt> object unconditionally from a single hybrid call:</p>
<pre class="rst-literal-block">
class SearchWord(Base):
    __tablename__ = 'searchword'
    id = Column(Integer, primary_key=True)
    word = Column(String(255), nullable=False)

    @hybrid_property
    def word_insensitive(self):
        return CaseInsensitiveWord(self.word)
</pre>
<p>The <tt class="rst-docutils literal">word_insensitive</tt> attribute now has case-insensitive comparison behavior
universally, including SQL expression vs. Python expression (note the Python
value is converted to lower case on the Python side here):</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; print(Session().query(SearchWord).filter_by(word_insensitive="Trucks"))
SELECT searchword.id AS searchword_id, searchword.word AS searchword_word
FROM searchword
WHERE lower(searchword.word) = :lower_1
</pre>
<p>SQL expression versus SQL expression:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; sw1 = aliased(SearchWord)
&gt;&gt;&gt; sw2 = aliased(SearchWord)
&gt;&gt;&gt; print(Session().query(
...                    sw1.word_insensitive,
...                    sw2.word_insensitive).\
...                        filter(
...                            sw1.word_insensitive &gt; sw2.word_insensitive
...                        ))
SELECT lower(searchword_1.word) AS lower_1,
lower(searchword_2.word) AS lower_2
FROM searchword AS searchword_1, searchword AS searchword_2
WHERE lower(searchword_1.word) &gt; lower(searchword_2.word)
</pre>
<p>Python only expression:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; ws1 = SearchWord(word="SomeWord")
&gt;&gt;&gt; ws1.word_insensitive == "sOmEwOrD"
True
&gt;&gt;&gt; ws1.word_insensitive == "XOmEwOrX"
False
&gt;&gt;&gt; print(ws1.word_insensitive)
someword
</pre>
<p>The Hybrid Value pattern is very useful for any kind of value that may have
multiple representations, such as timestamps, time deltas, units of
measurement, currencies and encrypted passwords.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a class="rst-reference external" href="https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/" target="_top">Hybrids and Value Agnostic Types</a>
- on the techspot.zzzeek.org blog</p>
<p class="rst-last"><a class="rst-reference external" href="https://techspot.zzzeek.org/2011/10/29/value-agnostic-types-part-ii/" target="_top">Value Agnostic Types, Part II</a> -
on the techspot.zzzeek.org blog</p>
</div>
</div>
<div class="rst-section" id="rst-building-transformers">
<span id="rst-hybrid-transformers"></span><h2 class="heading">Building Transformers</h2>
<p>A <em>transformer</em> is an object which can receive a <code>_query.Query</code>
object and
return a new one.   The <code>_query.Query</code> object includes a method
<code>.with_transformation</code> that returns a new <code>_query.Query</code>
transformed by
the given function.</p>
<p>We can combine this with the <code>.Comparator</code> class to produce one type
of recipe which can both set up the FROM clause of a query as well as assign
filtering criterion.</p>
<p>Consider a mapped class <tt class="rst-docutils literal">Node</tt>, which assembles using adjacency list into a
hierarchical tree pattern:</p>
<pre class="rst-literal-block">
from sqlalchemy import Column, Integer, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base()

class Node(Base):
    __tablename__ = 'node'
    id = Column(Integer, primary_key=True)
    parent_id = Column(Integer, ForeignKey('node.id'))
    parent = relationship("Node", remote_side=id)
</pre>
<p>Suppose we wanted to add an accessor <tt class="rst-docutils literal">grandparent</tt>.  This would return the
<tt class="rst-docutils literal">parent</tt> of <tt class="rst-docutils literal">Node.parent</tt>.  When we have an instance of <tt class="rst-docutils literal">Node</tt>, this is
simple:</p>
<pre class="rst-literal-block">
from sqlalchemy.ext.hybrid import hybrid_property

class Node(Base):
    # ...

    @hybrid_property
    def grandparent(self):
        return self.parent.parent
</pre>
<p>For the expression, things are not so clear.   We'd need to construct a
<code>_query.Query</code> where we <code>_query.Query.join</code> twice along
<tt class="rst-docutils literal">Node.parent</tt> to get to the <tt class="rst-docutils literal">grandparent</tt>.   We can instead return a
transforming callable that we'll combine with the <code>.Comparator</code> class to
receive any <code>_query.Query</code> object, and return a new one that's joined to
the <tt class="rst-docutils literal">Node.parent</tt> attribute and filtered based on the given criterion:</p>
<pre class="rst-literal-block">
from sqlalchemy.ext.hybrid import Comparator

class GrandparentTransformer(Comparator):
    def operate(self, op, other):
        def transform(q):
            cls = self.__clause_element__()
            parent_alias = aliased(cls)
            return q.join(parent_alias, cls.parent).\
                        filter(op(parent_alias.parent, other))
        return transform

Base = declarative_base()

class Node(Base):
    __tablename__ = 'node'
    id = Column(Integer, primary_key=True)
    parent_id = Column(Integer, ForeignKey('node.id'))
    parent = relationship("Node", remote_side=id)

    @hybrid_property
    def grandparent(self):
        return self.parent.parent

    @grandparent.comparator
    def grandparent(cls):
        return GrandparentTransformer(cls)
</pre>
<p>The <tt class="rst-docutils literal">GrandparentTransformer</tt> overrides the core <code>.Operators.operate</code>
method at the base of the <code>.Comparator</code> hierarchy to return a query-
transforming callable, which then runs the given comparison operation in a
particular context. Such as, in the example above, the <tt class="rst-docutils literal">operate</tt> method is
called, given the <code>.Operators.eq</code> callable as well as the right side of
the comparison <tt class="rst-docutils literal">Node(id=5)</tt>.  A function <tt class="rst-docutils literal">transform</tt> is then returned which
will transform a <code>_query.Query</code> first to join to <tt class="rst-docutils literal">Node.parent</tt>,
then to
compare <tt class="rst-docutils literal">parent_alias</tt> using <code>.Operators.eq</code> against the left and right
sides, passing into <code>_query.Query.filter</code>:</p>
<pre class="rst-code rst-pycon+sql rst-literal-block">
&gt;&gt;&gt; from sqlalchemy.orm import Session
&gt;&gt;&gt; session = Session()
{sql}&gt;&gt;&gt; session.query(Node).\
...        with_transformation(Node.grandparent==Node(id=5)).\
...        all()
SELECT node.id AS node_id, node.parent_id AS node_parent_id
FROM node JOIN node AS node_1 ON node_1.id = node.parent_id
WHERE :param_1 = node_1.parent_id
{stop}
</pre>
<p>We can modify the pattern to be more verbose but flexible by separating the
"join" step from the "filter" step.  The tricky part here is ensuring that
successive instances of <tt class="rst-docutils literal">GrandparentTransformer</tt> use the same
<code>.AliasedClass</code> object against <tt class="rst-docutils literal">Node</tt>.  Below we use a simple
memoizing approach that associates a <tt class="rst-docutils literal">GrandparentTransformer</tt> with each
class:</p>
<pre class="rst-literal-block">
class Node(Base):

    # ...

    @grandparent.comparator
    def grandparent(cls):
        # memoize a GrandparentTransformer
        # per class
        if '_gp' not in cls.__dict__:
            cls._gp = GrandparentTransformer(cls)
        return cls._gp

class GrandparentTransformer(Comparator):

    def __init__(self, cls):
        self.parent_alias = aliased(cls)

    @property
    def join(self):
        def go(q):
            return q.join(self.parent_alias, Node.parent)
        return go

    def operate(self, op, other):
        return op(self.parent_alias.parent, other)
</pre>
<pre class="rst-code rst-pycon+sql rst-literal-block">
{sql}&gt;&gt;&gt; session.query(Node).\
...            with_transformation(Node.grandparent.join).\
...            filter(Node.grandparent==Node(id=5))
SELECT node.id AS node_id, node.parent_id AS node_parent_id
FROM node JOIN node AS node_1 ON node_1.id = node.parent_id
WHERE :param_1 = node_1.parent_id
{stop}
</pre>
<p>The "transformer" pattern is an experimental pattern that starts to make usage
of some functional programming paradigms. While it's only recommended for
advanced and/or patient developers, there's probably a whole lot of amazing
things it can be used for.</p>
</div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id16594">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid.Comparator.html" class="internal-link" title="sqlalchemy.ext.hybrid.Comparator">​Comparator</a></code></td>
    <td>A helper class that allows easy construction of custom <code>~.orm.interfaces.PropComparator</code> classes for usage with hybrids.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid.ExprComparator.html" class="internal-link" title="sqlalchemy.ext.hybrid.ExprComparator">​Expr​Comparator</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid.hybrid_method.html" class="internal-link" title="sqlalchemy.ext.hybrid.hybrid_method">hybrid​_method</a></code></td>
    <td>A decorator which allows definition of a Python object method with both instance-level and class-level behavior.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid.hybrid_property.html" class="internal-link" title="sqlalchemy.ext.hybrid.hybrid_property">hybrid​_property</a></code></td>
    <td>A decorator which allows definition of a Python descriptor with both instance-level and class-level behavior.</td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#HYBRID_METHOD" class="internal-link" title="sqlalchemy.ext.hybrid.HYBRID_METHOD">HYBRID​_METHOD</a></code></td>
    <td>Symbol indicating an <code><a href="sqlalchemy.orm.base.InspectionAttr.html" class="internal-link" title="sqlalchemy.orm.base.InspectionAttr">InspectionAttr</a></code> that's of type <code>.hybrid_method</code>.</td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#HYBRID_PROPERTY" class="internal-link" title="sqlalchemy.ext.hybrid.HYBRID_PROPERTY">HYBRID​_PROPERTY</a></code></td>
    <td>Symbol indicating an <code><a href="sqlalchemy.orm.base.InspectionAttr.html" class="internal-link" title="sqlalchemy.orm.base.InspectionAttr">InspectionAttr</a></code> that's of type <code>.hybrid_method</code>.</td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="baseconstant">
  
  
  <a name="sqlalchemy.ext.hybrid.HYBRID_METHOD">
    
  </a>
  <a name="HYBRID_METHOD">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">HYBRID_METHOD</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p>Symbol indicating an <code><a href="sqlalchemy.orm.base.InspectionAttr.html" class="internal-link" title="sqlalchemy.orm.base.InspectionAttr">InspectionAttr</a></code> that's
of type <code>.hybrid_method</code>.</p>
<p>Is assigned to the <code>.InspectionAttr.extension_type</code>
attribute.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_orm.Mapper.all_orm_attributes</code></p>
</div>
</div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code><a href="sqlalchemy.util.langhelpers.symbol.html" class="internal-link" title="sqlalchemy.util.langhelpers.symbol">util.symbol</a>(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">HYBRID_METHOD</span><span class="rst-variable-quote">'</span>)</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant">
  
  
  <a name="sqlalchemy.ext.hybrid.HYBRID_PROPERTY">
    
  </a>
  <a name="HYBRID_PROPERTY">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">HYBRID_PROPERTY</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><dl class="rst-docutils">
<dt>Symbol indicating an <code><a href="sqlalchemy.orm.base.InspectionAttr.html" class="internal-link" title="sqlalchemy.orm.base.InspectionAttr">InspectionAttr</a></code> that's</dt>
<dd>of type <code>.hybrid_method</code>.</dd>
</dl>
<p>Is assigned to the <code>.InspectionAttr.extension_type</code>
attribute.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_orm.Mapper.all_orm_attributes</code></p>
</div>
</div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code><a href="sqlalchemy.util.langhelpers.symbol.html" class="internal-link" title="sqlalchemy.util.langhelpers.symbol">util.symbol</a>(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">HYBRID_PROPERTY</span><span class="rst-variable-quote">'</span>)</code></pre></td></tr></table>
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 04:41:59.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>