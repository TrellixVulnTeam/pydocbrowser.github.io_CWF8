<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>setuptools._vendor.more_itertools.more</title>
    <meta name="generator" content="pydoctor 22.4.0.dev0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1 maximum-scale=1" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    <div id="banner">    
    <div>
        <a href="/">Home</a>
        &gt; setuptools-62.1.0 <!-- This is a placeholder -->
        
        <!-- (<a href=""&gt;show all versions</a&gt;) -->
    </div>
</div>

    <nav class="navbar navbar-default mainnavbar">
      
  
  <div class="container-fluid">


    <div class="navbar-header">
      
      <div class="navlinks">
        <span class="navbar-brand">
          setuptools <a href="index.html">API Documentation</a>
        </span>

        <a href="moduleIndex.html">
          Modules
        </a>

        <a href="classIndex.html">
          Classes
        </a>

        <a href="nameIndex.html">
          Names
        </a>

        <div id="search-box-container">
          <div class="input-group">
            <input id="search-box" type="search" name="search-query" placeholder="Search..." aria-label="Search" minlength="2" class="form-control" autocomplete="off" />
            
            <span class="input-group-btn">
              <a style="display: none;" class="btn btn-default" id="search-clear-button" title="Clear" onclick="clearSearch()"><img src="fonts/x-circle.svg" alt="Clear" /></a>
              <a class="btn btn-default" id="search-help-button" title="Help" onclick="toggleSearchHelpText()"><img src="fonts/info.svg" alt="Help" /></a>
            </span>
          </div>
        </div>

      </div>

      <div id="search-results-container" style="display: none;">
        
        <div id="search-buttons">
          <span class="label label-default" id="search-docstrings-button">
          <label class="checkbox-inline">
            <input type="checkbox" id="toggle-search-in-docstrings-checkbox" value="false" onclick="toggleSearchInDocstrings()">
              search in docstrings
            </input>
          </label>
          </span>
          
        </div>
        
        <noscript>
            <h1>Cannot search: JavaScript is not supported/enabled in your browser.</h1>
        </noscript>

        <div class="hint" id="search-help-box">
          <p class="rst-last">
      
            Search bar offers the following options:
            <ul>   
                <li>
                  <strong>Term presence.</strong> The below example searches for documents that 
                    must contain “foo”, might contain “bar” and must not contain “baz”: <code>+foo bar -baz</code>
                </li> 

                <li>
                  <strong>Wildcards.</strong> The below example searches for documents with words beginning with “foo”: <code>foo*</code>
                </li> 

                <li>
                  <strong>Search in specific fields.</strong> The following search matches all objects 
                  in "twisted.mail" that matches “search”: <code>+qname:twisted.mail.* +search</code>

                  <p>
                    Possible fields: 'name', 'qname' (fully qualified name), 'docstring', and 'kind'.
                    Last two fields are only applicable if "search in docstrings" is enabled.
                  </p>
                </li>

                <li>
                  <strong>Fuzzy matches.</strong> The following search matches all documents 
                  that have a word within 1 edit distance of “foo”: <code>foo~1</code>
                </li>
            </ul>

          </p>
        </div>

        <div id="search-status"> </div>

        <div class="warning" id="search-warn-box" style="display: none;">
          <p class="rst-last"><span id="search-warn"></span></p>
        </div>

        <table id="search-results">
          <!-- Filled dynamically by JS -->
        </table>
        
        <div style="margin-top: 8px;">
          <p>Results provided by <a href="https://lunrjs.com">Lunr.js</a></p>
        </div>
      </div>

    </div>


  </div>
</nav>
    
    <div class="container-fluid">

      <!-- Side navigation -->
      <div class="sidebarcontainer" style="display: none;">
        
        <div class="sidebar"><nav class="sidebar">
  

  <div>

      <div class="thingTitle">
        <span>Module</span>
        <code class="thisobject"><a href="setuptools._vendor.more_itertools.more.html" class="internal-link" title="This module">more</a></code> 
      </div>
      
      <div>
        

        
         

        <div class="childrenKindTitle">Classes</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.AbortThread.html" class="internal-link" title="setuptools._vendor.more_itertools.more.AbortThread"><wbr></wbr>Abort<wbr></wbr>Thread</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.bucket.html" class="internal-link" title="setuptools._vendor.more_itertools.more.bucket">bucket</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.callback_iter.html" class="internal-link" title="setuptools._vendor.more_itertools.more.callback_iter">callback<wbr></wbr>_iter</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.countable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.countable">countable</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.islice_extended.html" class="internal-link" title="setuptools._vendor.more_itertools.more.islice_extended">islice<wbr></wbr>_extended</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.numeric_range.html" class="internal-link" title="setuptools._vendor.more_itertools.more.numeric_range">numeric<wbr></wbr>_range</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.peekable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.peekable">peekable</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.run_length.html" class="internal-link" title="setuptools._vendor.more_itertools.more.run_length">run<wbr></wbr>_length</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.seekable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.seekable">seekable</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.SequenceView.html" class="internal-link" title="setuptools._vendor.more_itertools.more.SequenceView"><wbr></wbr>Sequence<wbr></wbr>View</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.time_limited.html" class="internal-link" title="setuptools._vendor.more_itertools.more.time_limited">time<wbr></wbr>_limited</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.UnequalIterablesError.html" class="internal-link" title="setuptools._vendor.more_itertools.more.UnequalIterablesError"><wbr></wbr>Unequal<wbr></wbr>Iterables<wbr></wbr>Error</a></code>
            </div>
        

    </li>
</ul>

        <div class="childrenKindTitle">Functions</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="#adjacent" class="internal-link" title="setuptools._vendor.more_itertools.more.adjacent">adjacent</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#all_unique" class="internal-link" title="setuptools._vendor.more_itertools.more.all_unique">all<wbr></wbr>_unique</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#always_iterable" class="internal-link" title="setuptools._vendor.more_itertools.more.always_iterable">always<wbr></wbr>_iterable</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#always_reversible" class="internal-link" title="setuptools._vendor.more_itertools.more.always_reversible">always<wbr></wbr>_reversible</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#chunked" class="internal-link" title="setuptools._vendor.more_itertools.more.chunked">chunked</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#circular_shifts" class="internal-link" title="setuptools._vendor.more_itertools.more.circular_shifts">circular<wbr></wbr>_shifts</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#collapse" class="internal-link" title="setuptools._vendor.more_itertools.more.collapse">collapse</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#collate" class="internal-link" title="setuptools._vendor.more_itertools.more.collate">collate</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#combination_index" class="internal-link" title="setuptools._vendor.more_itertools.more.combination_index">combination<wbr></wbr>_index</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#consecutive_groups" class="internal-link" title="setuptools._vendor.more_itertools.more.consecutive_groups">consecutive<wbr></wbr>_groups</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#consumer" class="internal-link" title="setuptools._vendor.more_itertools.more.consumer">consumer</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#count_cycle" class="internal-link" title="setuptools._vendor.more_itertools.more.count_cycle">count<wbr></wbr>_cycle</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#difference" class="internal-link" title="setuptools._vendor.more_itertools.more.difference">difference</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#distinct_combinations" class="internal-link" title="setuptools._vendor.more_itertools.more.distinct_combinations">distinct<wbr></wbr>_combinations</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#distinct_permutations" class="internal-link" title="setuptools._vendor.more_itertools.more.distinct_permutations">distinct<wbr></wbr>_permutations</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#distribute" class="internal-link" title="setuptools._vendor.more_itertools.more.distribute">distribute</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#divide" class="internal-link" title="setuptools._vendor.more_itertools.more.divide">divide</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#exactly_n" class="internal-link" title="setuptools._vendor.more_itertools.more.exactly_n">exactly<wbr></wbr>_n</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#filter_except" class="internal-link" title="setuptools._vendor.more_itertools.more.filter_except">filter<wbr></wbr>_except</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#first" class="internal-link" title="setuptools._vendor.more_itertools.more.first">first</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#groupby_transform" class="internal-link" title="setuptools._vendor.more_itertools.more.groupby_transform">groupby<wbr></wbr>_transform</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#ichunked" class="internal-link" title="setuptools._vendor.more_itertools.more.ichunked">ichunked</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#ilen" class="internal-link" title="setuptools._vendor.more_itertools.more.ilen">ilen</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#interleave" class="internal-link" title="setuptools._vendor.more_itertools.more.interleave">interleave</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#interleave_longest" class="internal-link" title="setuptools._vendor.more_itertools.more.interleave_longest">interleave<wbr></wbr>_longest</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#intersperse" class="internal-link" title="setuptools._vendor.more_itertools.more.intersperse">intersperse</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_sorted" class="internal-link" title="setuptools._vendor.more_itertools.more.is_sorted">is<wbr></wbr>_sorted</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#iterate" class="internal-link" title="setuptools._vendor.more_itertools.more.iterate">iterate</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#last" class="internal-link" title="setuptools._vendor.more_itertools.more.last">last</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#locate" class="internal-link" title="setuptools._vendor.more_itertools.more.locate">locate</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#lstrip" class="internal-link" title="setuptools._vendor.more_itertools.more.lstrip">lstrip</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#make_decorator" class="internal-link" title="setuptools._vendor.more_itertools.more.make_decorator">make<wbr></wbr>_decorator</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#map_except" class="internal-link" title="setuptools._vendor.more_itertools.more.map_except">map<wbr></wbr>_except</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#map_reduce" class="internal-link" title="setuptools._vendor.more_itertools.more.map_reduce">map<wbr></wbr>_reduce</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#mark_ends" class="internal-link" title="setuptools._vendor.more_itertools.more.mark_ends">mark<wbr></wbr>_ends</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#nth_or_last" class="internal-link" title="setuptools._vendor.more_itertools.more.nth_or_last">nth<wbr></wbr>_or<wbr></wbr>_last</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#nth_permutation" class="internal-link" title="setuptools._vendor.more_itertools.more.nth_permutation">nth<wbr></wbr>_permutation</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#nth_product" class="internal-link" title="setuptools._vendor.more_itertools.more.nth_product">nth<wbr></wbr>_product</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#one" class="internal-link" title="setuptools._vendor.more_itertools.more.one">one</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#only" class="internal-link" title="setuptools._vendor.more_itertools.more.only">only</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#padded" class="internal-link" title="setuptools._vendor.more_itertools.more.padded">padded</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#partitions" class="internal-link" title="setuptools._vendor.more_itertools.more.partitions">partitions</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#permutation_index" class="internal-link" title="setuptools._vendor.more_itertools.more.permutation_index">permutation<wbr></wbr>_index</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#product_index" class="internal-link" title="setuptools._vendor.more_itertools.more.product_index">product<wbr></wbr>_index</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#repeat_last" class="internal-link" title="setuptools._vendor.more_itertools.more.repeat_last">repeat<wbr></wbr>_last</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#replace" class="internal-link" title="setuptools._vendor.more_itertools.more.replace">replace</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#rlocate" class="internal-link" title="setuptools._vendor.more_itertools.more.rlocate">rlocate</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#rstrip" class="internal-link" title="setuptools._vendor.more_itertools.more.rstrip">rstrip</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#sample" class="internal-link" title="setuptools._vendor.more_itertools.more.sample">sample</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#set_partitions" class="internal-link" title="setuptools._vendor.more_itertools.more.set_partitions">set<wbr></wbr>_partitions</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#side_effect" class="internal-link" title="setuptools._vendor.more_itertools.more.side_effect">side<wbr></wbr>_effect</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#sliced" class="internal-link" title="setuptools._vendor.more_itertools.more.sliced">sliced</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#sort_together" class="internal-link" title="setuptools._vendor.more_itertools.more.sort_together">sort<wbr></wbr>_together</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#split_after" class="internal-link" title="setuptools._vendor.more_itertools.more.split_after">split<wbr></wbr>_after</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#split_at" class="internal-link" title="setuptools._vendor.more_itertools.more.split_at">split<wbr></wbr>_at</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#split_before" class="internal-link" title="setuptools._vendor.more_itertools.more.split_before">split<wbr></wbr>_before</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#split_into" class="internal-link" title="setuptools._vendor.more_itertools.more.split_into">split<wbr></wbr>_into</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#split_when" class="internal-link" title="setuptools._vendor.more_itertools.more.split_when">split<wbr></wbr>_when</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#spy" class="internal-link" title="setuptools._vendor.more_itertools.more.spy">spy</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#stagger" class="internal-link" title="setuptools._vendor.more_itertools.more.stagger">stagger</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#strip" class="internal-link" title="setuptools._vendor.more_itertools.more.strip">strip</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#substrings" class="internal-link" title="setuptools._vendor.more_itertools.more.substrings">substrings</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#substrings_indexes" class="internal-link" title="setuptools._vendor.more_itertools.more.substrings_indexes">substrings<wbr></wbr>_indexes</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#unique_to_each" class="internal-link" title="setuptools._vendor.more_itertools.more.unique_to_each">unique<wbr></wbr>_to<wbr></wbr>_each</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#unzip" class="internal-link" title="setuptools._vendor.more_itertools.more.unzip">unzip</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#value_chain" class="internal-link" title="setuptools._vendor.more_itertools.more.value_chain">value<wbr></wbr>_chain</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#windowed" class="internal-link" title="setuptools._vendor.more_itertools.more.windowed">windowed</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#windowed_complete" class="internal-link" title="setuptools._vendor.more_itertools.more.windowed_complete">windowed<wbr></wbr>_complete</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#with_iter" class="internal-link" title="setuptools._vendor.more_itertools.more.with_iter">with<wbr></wbr>_iter</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#zip_equal" class="internal-link" title="setuptools._vendor.more_itertools.more.zip_equal">zip<wbr></wbr>_equal</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#zip_offset" class="internal-link" title="setuptools._vendor.more_itertools.more.zip_offset">zip<wbr></wbr>_offset</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_islice_helper" class="internal-link" title="setuptools._vendor.more_itertools.more._islice_helper">_islice<wbr></wbr>_helper</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_sample_unweighted" class="internal-link" title="setuptools._vendor.more_itertools.more._sample_unweighted">_sample<wbr></wbr>_unweighted</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_sample_weighted" class="internal-link" title="setuptools._vendor.more_itertools.more._sample_weighted">_sample<wbr></wbr>_weighted</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_zip_equal_generator" class="internal-link" title="setuptools._vendor.more_itertools.more._zip_equal_generator">_zip<wbr></wbr>_equal<wbr></wbr>_generator</a></code>
            </div>
        

    </li>
</ul> 

        
         

        <div class="childrenKindTitle">Variables</div>
        <ul>
    
    <li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_marker" class="internal-link" title="setuptools._vendor.more_itertools.more._marker">_marker</a></code>
            </div>
        

    </li>
</ul> 

        
         
        
      </div>
  </div><div>

      <div class="thingTitle">
        <span>Package</span>
        <code><a href="setuptools._vendor.more_itertools.html" class="internal-link" title="The parent of this module">more<wbr></wbr>_itertools</a></code> 
      </div>
      
      <div>
        

        <div class="childrenKindTitle">Modules</div>
        <ul>
    
    <li class=" thisobject">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.more.html" class="internal-link" title="setuptools._vendor.more_itertools.more">more</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.recipes.html" class="internal-link" title="setuptools._vendor.more_itertools.recipes">recipes</a></code>
            </div>
        

    </li>
</ul> 

        
        

        
         

        
         

        <div class="childrenKindTitle">Variables</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="setuptools._vendor.more_itertools.html#__version__" class="internal-link" title="setuptools._vendor.more_itertools.__version__">__version__</a></code>
            </div>
        

    </li>
</ul> 

        
         
        
      </div>
  </div>

</nav>
        </div>
        <div id="collapseSideBar">
          <a class="btn btn-link" onclick="toggleSideBarCollapse()" title="Toggle Sidebar Collapse">
          </a>
        </div> 
        <script src="sidebartoggle.js" type="text/javascript"></script>
       
      </div>

      <div id="main" class="">
        

        

        <div class="page-header">
          <h1 class="module"><code><code><a href="index.html" class="internal-link">setuptools</a></code><wbr></wbr>.<code><a href="setuptools._vendor.html" class="internal-link" title="setuptools._vendor">_vendor</a></code><wbr></wbr>.<code><a href="setuptools._vendor.more_itertools.html" class="internal-link" title="setuptools._vendor.more_itertools">more_itertools</a></code><wbr></wbr>.<code><a href="setuptools._vendor.more_itertools.more.html" class="internal-link" title="setuptools._vendor.more_itertools.more">more</a></code></code></h1>
          <div id="showPrivate">
            <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
          </div>
        </div>

        <div class="categoryHeader">
          module documentation
        </div>

        <div class="extrasDocstring">
          <a href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py" class="sourceLink">(source)</a>
          <p></p>
        </div>

        <div class="moduleDocstring">
          <div><p class="undocumented">Undocumented</p></div>
        </div>

        <div id="splitTables">
          <table class="children sortable" id="id7138">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.AbortThread.html" class="internal-link" title="setuptools._vendor.more_itertools.more.AbortThread"><wbr></wbr>Abort<wbr></wbr>Thread</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.bucket.html" class="internal-link" title="setuptools._vendor.more_itertools.more.bucket">bucket</a></code></td>
    <td>Wrap *iterable* and return an object that buckets it iterable into child iterables based on a *key* function.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.callback_iter.html" class="internal-link" title="setuptools._vendor.more_itertools.more.callback_iter">callback<wbr></wbr>_iter</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.countable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.countable">countable</a></code></td>
    <td>Wrap *iterable* and keep a count of how many items have been consumed.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.islice_extended.html" class="internal-link" title="setuptools._vendor.more_itertools.more.islice_extended">islice<wbr></wbr>_extended</a></code></td>
    <td>An extension of :func:`itertools.islice` that supports negative values for *stop*, *start*, and *step*.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.numeric_range.html" class="internal-link" title="setuptools._vendor.more_itertools.more.numeric_range">numeric<wbr></wbr>_range</a></code></td>
    <td>An extension of the built-in ``range()`` function whose arguments can be any orderable numeric type.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.peekable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.peekable">peekable</a></code></td>
    <td>Wrap an iterator to allow lookahead and prepending elements.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.run_length.html" class="internal-link" title="setuptools._vendor.more_itertools.more.run_length">run<wbr></wbr>_length</a></code></td>
    <td>:func:`run_length.encode` compresses an iterable with run-length encoding. It yields groups of repeated items with the count of how many times they were repeated:</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.seekable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.seekable">seekable</a></code></td>
    <td>Wrap an iterator to allow for seeking backward and forward. This progressively caches the items in the source iterable so they can be re-visited.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.SequenceView.html" class="internal-link" title="setuptools._vendor.more_itertools.more.SequenceView"><wbr></wbr>Sequence<wbr></wbr>View</a></code></td>
    <td>Return a read-only view of the sequence object *target*.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.time_limited.html" class="internal-link" title="setuptools._vendor.more_itertools.more.time_limited">time<wbr></wbr>_limited</a></code></td>
    <td>Yield items from *iterable* until *limit_seconds* have passed. If the time limit expires before all items have been yielded, the ``timed_out`` parameter will be set to ``True``.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.UnequalIterablesError.html" class="internal-link" title="setuptools._vendor.more_itertools.more.UnequalIterablesError"><wbr></wbr>Unequal<wbr></wbr>Iterables<wbr></wbr>Error</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#adjacent" class="internal-link" title="setuptools._vendor.more_itertools.more.adjacent">adjacent</a></code></td>
    <td>Return an iterable over `(bool, item)` tuples where the `item` is drawn from *iterable* and the `bool` indicates whether that item satisfies the *predicate* or is adjacent to an item that does.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#all_unique" class="internal-link" title="setuptools._vendor.more_itertools.more.all_unique">all<wbr></wbr>_unique</a></code></td>
    <td>Returns ``True`` if all the elements of *iterable* are unique (no two elements are equal).</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#always_iterable" class="internal-link" title="setuptools._vendor.more_itertools.more.always_iterable">always<wbr></wbr>_iterable</a></code></td>
    <td>If *obj* is iterable, return an iterator over its items:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#always_reversible" class="internal-link" title="setuptools._vendor.more_itertools.more.always_reversible">always<wbr></wbr>_reversible</a></code></td>
    <td>An extension of :func:`reversed` that supports all iterables, not just those which implement the ``Reversible`` or ``Sequence`` protocols.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#chunked" class="internal-link" title="setuptools._vendor.more_itertools.more.chunked">chunked</a></code></td>
    <td>Break *iterable* into lists of length *n*:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#circular_shifts" class="internal-link" title="setuptools._vendor.more_itertools.more.circular_shifts">circular<wbr></wbr>_shifts</a></code></td>
    <td>Return a list of circular shifts of *iterable*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#collapse" class="internal-link" title="setuptools._vendor.more_itertools.more.collapse">collapse</a></code></td>
    <td>Flatten an iterable with multiple levels of nesting (e.g., a list of lists of tuples) into non-iterable types.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#collate" class="internal-link" title="setuptools._vendor.more_itertools.more.collate">collate</a></code></td>
    <td>Return a sorted merge of the items from each of several already-sorted *iterables*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#combination_index" class="internal-link" title="setuptools._vendor.more_itertools.more.combination_index">combination<wbr></wbr>_index</a></code></td>
    <td>Equivalent to ``list(combinations(iterable, r)).index(element)``</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#consecutive_groups" class="internal-link" title="setuptools._vendor.more_itertools.more.consecutive_groups">consecutive<wbr></wbr>_groups</a></code></td>
    <td>Yield groups of consecutive items using :func:`itertools.groupby`. The *ordering* function determines whether two items are adjacent by returning their position.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#consumer" class="internal-link" title="setuptools._vendor.more_itertools.more.consumer">consumer</a></code></td>
    <td>Decorator that automatically advances a PEP-342-style "reverse iterator" to its first yield point so you don't have to call ``next()`` on it manually.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#count_cycle" class="internal-link" title="setuptools._vendor.more_itertools.more.count_cycle">count<wbr></wbr>_cycle</a></code></td>
    <td>Cycle through the items from *iterable* up to *n* times, yielding the number of completed cycles along with each item. If *n* is omitted the process repeats indefinitely.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#difference" class="internal-link" title="setuptools._vendor.more_itertools.more.difference">difference</a></code></td>
    <td>This function is the inverse of :func:`itertools.accumulate`. By default it will compute the first difference of *iterable* using :func:`operator.sub`:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#distinct_combinations" class="internal-link" title="setuptools._vendor.more_itertools.more.distinct_combinations">distinct<wbr></wbr>_combinations</a></code></td>
    <td>Yield the distinct combinations of *r* items taken from *iterable*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#distinct_permutations" class="internal-link" title="setuptools._vendor.more_itertools.more.distinct_permutations">distinct<wbr></wbr>_permutations</a></code></td>
    <td>Yield successive distinct permutations of the elements in *iterable*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#distribute" class="internal-link" title="setuptools._vendor.more_itertools.more.distribute">distribute</a></code></td>
    <td>Distribute the items from *iterable* among *n* smaller iterables.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#divide" class="internal-link" title="setuptools._vendor.more_itertools.more.divide">divide</a></code></td>
    <td>Divide the elements from *iterable* into *n* parts, maintaining order.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#exactly_n" class="internal-link" title="setuptools._vendor.more_itertools.more.exactly_n">exactly<wbr></wbr>_n</a></code></td>
    <td>Return ``True`` if exactly ``n`` items in the iterable are ``True`` according to the *predicate* function.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#filter_except" class="internal-link" title="setuptools._vendor.more_itertools.more.filter_except">filter<wbr></wbr>_except</a></code></td>
    <td>Yield the items from *iterable* for which the *validator* function does not raise one of the specified *exceptions*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#first" class="internal-link" title="setuptools._vendor.more_itertools.more.first">first</a></code></td>
    <td>Return the first item of *iterable*, or *default* if *iterable* is empty.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#groupby_transform" class="internal-link" title="setuptools._vendor.more_itertools.more.groupby_transform">groupby<wbr></wbr>_transform</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#ichunked" class="internal-link" title="setuptools._vendor.more_itertools.more.ichunked">ichunked</a></code></td>
    <td>Break *iterable* into sub-iterables with *n* elements each. :func:`ichunked` is like :func:`chunked`, but it yields iterables instead of lists.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#ilen" class="internal-link" title="setuptools._vendor.more_itertools.more.ilen">ilen</a></code></td>
    <td>Return the number of items in *iterable*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#interleave" class="internal-link" title="setuptools._vendor.more_itertools.more.interleave">interleave</a></code></td>
    <td>Return a new iterable yielding from each iterable in turn, until the shortest is exhausted.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#interleave_longest" class="internal-link" title="setuptools._vendor.more_itertools.more.interleave_longest">interleave<wbr></wbr>_longest</a></code></td>
    <td>Return a new iterable yielding from each iterable in turn, skipping any that are exhausted.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#intersperse" class="internal-link" title="setuptools._vendor.more_itertools.more.intersperse">intersperse</a></code></td>
    <td>Intersperse filler element *e* among the items in *iterable*, leaving *n* items between each filler element.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#is_sorted" class="internal-link" title="setuptools._vendor.more_itertools.more.is_sorted">is<wbr></wbr>_sorted</a></code></td>
    <td>Returns ``True`` if the items of iterable are in sorted order, and ``False`` otherwise. *key* and *reverse* have the same meaning that they do in the built-in :func:`sorted` function.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#iterate" class="internal-link" title="setuptools._vendor.more_itertools.more.iterate">iterate</a></code></td>
    <td>Return ``start``, ``func(start)``, ``func(func(start))``, ...</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#last" class="internal-link" title="setuptools._vendor.more_itertools.more.last">last</a></code></td>
    <td>Return the last item of *iterable*, or *default* if *iterable* is empty.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#locate" class="internal-link" title="setuptools._vendor.more_itertools.more.locate">locate</a></code></td>
    <td>Yield the index of each item in *iterable* for which *pred* returns ``True``.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#lstrip" class="internal-link" title="setuptools._vendor.more_itertools.more.lstrip">lstrip</a></code></td>
    <td>Yield the items from *iterable*, but strip any from the beginning for which *pred* returns ``True``.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#make_decorator" class="internal-link" title="setuptools._vendor.more_itertools.more.make_decorator">make<wbr></wbr>_decorator</a></code></td>
    <td>Return a decorator version of *wrapping_func*, which is a function that modifies an iterable. *result_index* is the position in that function's signature where the iterable goes.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#map_except" class="internal-link" title="setuptools._vendor.more_itertools.more.map_except">map<wbr></wbr>_except</a></code></td>
    <td>Transform each item from *iterable* with *function* and yield the result, unless *function* raises one of the specified *exceptions*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#map_reduce" class="internal-link" title="setuptools._vendor.more_itertools.more.map_reduce">map<wbr></wbr>_reduce</a></code></td>
    <td>Return a dictionary that maps the items in *iterable* to categories defined by *keyfunc*, transforms them with *valuefunc*, and then summarizes them by category with *reducefunc*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#mark_ends" class="internal-link" title="setuptools._vendor.more_itertools.more.mark_ends">mark<wbr></wbr>_ends</a></code></td>
    <td>Yield 3-tuples of the form ``(is_first, is_last, item)``.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#nth_or_last" class="internal-link" title="setuptools._vendor.more_itertools.more.nth_or_last">nth<wbr></wbr>_or<wbr></wbr>_last</a></code></td>
    <td>Return the nth or the last item of *iterable*, or *default* if *iterable* is empty.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#nth_permutation" class="internal-link" title="setuptools._vendor.more_itertools.more.nth_permutation">nth<wbr></wbr>_permutation</a></code></td>
    <td>Equivalent to ``list(permutations(iterable, r))[index]```</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#nth_product" class="internal-link" title="setuptools._vendor.more_itertools.more.nth_product">nth<wbr></wbr>_product</a></code></td>
    <td>Equivalent to ``list(product(*args))[index]``.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#one" class="internal-link" title="setuptools._vendor.more_itertools.more.one">one</a></code></td>
    <td>Return the first item from *iterable*, which is expected to contain only that item. Raise an exception if *iterable* is empty or has more than one item.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#only" class="internal-link" title="setuptools._vendor.more_itertools.more.only">only</a></code></td>
    <td>If *iterable* has only one item, return it. If it has zero items, return *default*. If it has more than one item, raise the exception given by *too_long*, which is ``ValueError`` by default.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#padded" class="internal-link" title="setuptools._vendor.more_itertools.more.padded">padded</a></code></td>
    <td>Yield the elements from *iterable*, followed by *fillvalue*, such that at least *n* items are emitted.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#partitions" class="internal-link" title="setuptools._vendor.more_itertools.more.partitions">partitions</a></code></td>
    <td>Yield all possible order-preserving partitions of *iterable*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#permutation_index" class="internal-link" title="setuptools._vendor.more_itertools.more.permutation_index">permutation<wbr></wbr>_index</a></code></td>
    <td>Equivalent to ``list(permutations(iterable, r)).index(element)```</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#product_index" class="internal-link" title="setuptools._vendor.more_itertools.more.product_index">product<wbr></wbr>_index</a></code></td>
    <td>Equivalent to ``list(product(*args)).index(element)``</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#repeat_last" class="internal-link" title="setuptools._vendor.more_itertools.more.repeat_last">repeat<wbr></wbr>_last</a></code></td>
    <td>After the *iterable* is exhausted, keep yielding its last element.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#replace" class="internal-link" title="setuptools._vendor.more_itertools.more.replace">replace</a></code></td>
    <td>Yield the items from *iterable*, replacing the items for which *pred* returns ``True`` with the items from the iterable *substitutes*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#rlocate" class="internal-link" title="setuptools._vendor.more_itertools.more.rlocate">rlocate</a></code></td>
    <td>Yield the index of each item in *iterable* for which *pred* returns ``True``, starting from the right and moving left.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#rstrip" class="internal-link" title="setuptools._vendor.more_itertools.more.rstrip">rstrip</a></code></td>
    <td>Yield the items from *iterable*, but strip any from the end for which *pred* returns ``True``.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#sample" class="internal-link" title="setuptools._vendor.more_itertools.more.sample">sample</a></code></td>
    <td>Return a *k*-length list of elements chosen (without replacement) from the *iterable*. Like :func:`random.sample`, but works on iterables of unknown length.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#set_partitions" class="internal-link" title="setuptools._vendor.more_itertools.more.set_partitions">set<wbr></wbr>_partitions</a></code></td>
    <td>Yield the set partitions of *iterable* into *k* parts. Set partitions are not order-preserving.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#side_effect" class="internal-link" title="setuptools._vendor.more_itertools.more.side_effect">side<wbr></wbr>_effect</a></code></td>
    <td>Invoke *func* on each item in *iterable* (or on each *chunk_size* group of items) before yielding the item.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#sliced" class="internal-link" title="setuptools._vendor.more_itertools.more.sliced">sliced</a></code></td>
    <td>Yield slices of length *n* from the sequence *seq*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#sort_together" class="internal-link" title="setuptools._vendor.more_itertools.more.sort_together">sort<wbr></wbr>_together</a></code></td>
    <td>Return the input iterables sorted together, with *key_list* as the priority for sorting. All iterables are trimmed to the length of the shortest one.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#split_after" class="internal-link" title="setuptools._vendor.more_itertools.more.split_after">split<wbr></wbr>_after</a></code></td>
    <td>Yield lists of items from *iterable*, where each list ends with an item where callable *pred* returns ``True``:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#split_at" class="internal-link" title="setuptools._vendor.more_itertools.more.split_at">split<wbr></wbr>_at</a></code></td>
    <td>Yield lists of items from *iterable*, where each list is delimited by an item where callable *pred* returns ``True``.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#split_before" class="internal-link" title="setuptools._vendor.more_itertools.more.split_before">split<wbr></wbr>_before</a></code></td>
    <td>Yield lists of items from *iterable*, where each list ends just before an item for which callable *pred* returns ``True``:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#split_into" class="internal-link" title="setuptools._vendor.more_itertools.more.split_into">split<wbr></wbr>_into</a></code></td>
    <td>Yield a list of sequential items from *iterable* of length 'n' for each integer 'n' in *sizes*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#split_when" class="internal-link" title="setuptools._vendor.more_itertools.more.split_when">split<wbr></wbr>_when</a></code></td>
    <td>Split *iterable* into pieces based on the output of *pred*. *pred* should be a function that takes successive pairs of items and returns ``True`` if the iterable should be split in between them.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#spy" class="internal-link" title="setuptools._vendor.more_itertools.more.spy">spy</a></code></td>
    <td>Return a 2-tuple with a list containing the first *n* elements of *iterable*, and an iterator with the same items as *iterable*. This allows you to "look ahead" at the items in the iterable without advancing it.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#stagger" class="internal-link" title="setuptools._vendor.more_itertools.more.stagger">stagger</a></code></td>
    <td>Yield tuples whose elements are offset from *iterable*. The amount by which the `i`-th item in each tuple is offset is given by the `i`-th item in *offsets*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#strip" class="internal-link" title="setuptools._vendor.more_itertools.more.strip">strip</a></code></td>
    <td>Yield the items from *iterable*, but strip any from the beginning and end for which *pred* returns ``True``.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#substrings" class="internal-link" title="setuptools._vendor.more_itertools.more.substrings">substrings</a></code></td>
    <td>Yield all of the substrings of *iterable*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#substrings_indexes" class="internal-link" title="setuptools._vendor.more_itertools.more.substrings_indexes">substrings<wbr></wbr>_indexes</a></code></td>
    <td>Yield all substrings and their positions in *seq*</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#unique_to_each" class="internal-link" title="setuptools._vendor.more_itertools.more.unique_to_each">unique<wbr></wbr>_to<wbr></wbr>_each</a></code></td>
    <td>Return the elements from each of the input iterables that aren't in the other input iterables.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#unzip" class="internal-link" title="setuptools._vendor.more_itertools.more.unzip">unzip</a></code></td>
    <td>The inverse of :func:`zip`, this function disaggregates the elements of the zipped *iterable*.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#value_chain" class="internal-link" title="setuptools._vendor.more_itertools.more.value_chain">value<wbr></wbr>_chain</a></code></td>
    <td>Yield all arguments passed to the function in the same order in which they were passed. If an argument itself is iterable then iterate over its values.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#windowed" class="internal-link" title="setuptools._vendor.more_itertools.more.windowed">windowed</a></code></td>
    <td>Return a sliding window of width *n* over the given iterable.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#windowed_complete" class="internal-link" title="setuptools._vendor.more_itertools.more.windowed_complete">windowed<wbr></wbr>_complete</a></code></td>
    <td>Yield ``(beginning, middle, end)`` tuples, where:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#with_iter" class="internal-link" title="setuptools._vendor.more_itertools.more.with_iter">with<wbr></wbr>_iter</a></code></td>
    <td>Wrap an iterable in a ``with`` statement, so it closes once exhausted.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#zip_equal" class="internal-link" title="setuptools._vendor.more_itertools.more.zip_equal">zip<wbr></wbr>_equal</a></code></td>
    <td>``zip`` the input *iterables* together, but raise ``UnequalIterablesError`` if they aren't all the same length.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#zip_offset" class="internal-link" title="setuptools._vendor.more_itertools.more.zip_offset">zip<wbr></wbr>_offset</a></code></td>
    <td>``zip`` the input *iterables* together, but offset the `i`-th iterable by the `i`-th item in *offsets*.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_islice_helper" class="internal-link" title="setuptools._vendor.more_itertools.more._islice_helper">_islice<wbr></wbr>_helper</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_sample_unweighted" class="internal-link" title="setuptools._vendor.more_itertools.more._sample_unweighted">_sample<wbr></wbr>_unweighted</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_sample_weighted" class="internal-link" title="setuptools._vendor.more_itertools.more._sample_weighted">_sample<wbr></wbr>_weighted</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_zip_equal_generator" class="internal-link" title="setuptools._vendor.more_itertools.more._zip_equal_generator">_zip<wbr></wbr>_equal<wbr></wbr>_generator</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#_marker" class="internal-link" title="setuptools._vendor.more_itertools.more._marker">_marker</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
          

            
        </div>

        <div id="childList">
          <div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.adjacent">
    
  </a>
  <a name="adjacent">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">adjacent</span>(predicate, iterable, distance=1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1804">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return an iterable over `(bool, item)` tuples where the `item` is drawn from *iterable* and the `bool` indicates whether that item satisfies the *predicate* or is adjacent to an item that does.</p>
<p>For example, to find whether items are adjacent to a ``3``:</p>
<pre class="rst-literal-block">
    &gt;&gt;&gt; list(adjacent(lambda x: x == 3, range(6)))
    [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]
</pre>
<p>Set *distance* to change what counts as adjacent. For example, to find whether items are two places away from a ``3``:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(adjacent(<span class="py-keyword">lambda</span> x: x == 3, <span class="py-builtin">range</span>(6), distance=2))
<span class="py-output">[(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]</span>
</pre><p>This is useful for contextualizing the results of a search function. For example, a code comparison tool might want to identify lines that have changed, but also surrounding lines to give the viewer of the diff context.</p>
<p>The predicate function will only be called once for each item in the iterable.</p>
<p>See also :func:`groupby_transform`, which can be used with this function to group ranges of items with the same `bool` value.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.all_unique">
    
  </a>
  <a name="all_unique">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">all_unique</span>(iterable, key=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3563">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns ``True`` if all the elements of *iterable* are unique (no two elements are equal).</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>all_unique(<span class="py-string">'ABCB'</span>)
<span class="py-output">False</span>
</pre><p>If a *key* function is specified, it will be used to make comparisons.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>all_unique(<span class="py-string">'ABCb'</span>)
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>all_unique(<span class="py-string">'ABCb'</span>, <span class="py-builtin">str</span>.lower)
<span class="py-output">False</span>
</pre><p>The function returns as soon as the first non-unique element is encountered. Iterables with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.always_iterable">
    
  </a>
  <a name="always_iterable">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">always_iterable</span>(obj, base_type=(<wbr></wbr><a href="https://docs.python.org/3/library/stdtypes.html#str" class="intersphinx-link">str</a>, <wbr></wbr><a href="https://docs.python.org/3/library/stdtypes.html#bytes" class="intersphinx-link">bytes</a>)):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1751">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>If *obj* is iterable, return an iterator over its items:</p>
<pre class="rst-literal-block">
    &gt;&gt;&gt; obj = (1, 2, 3)
    &gt;&gt;&gt; list(always_iterable(obj))
    [1, 2, 3]
</pre>
<p>If *obj* is not iterable, return a one-item iterable containing *obj*:</p>
<pre class="rst-literal-block">
    &gt;&gt;&gt; obj = 1
    &gt;&gt;&gt; list(always_iterable(obj))
    [1]
</pre>
<p>If *obj* is ``None``, return an empty iterable:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>obj = <span class="py-builtin">None</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(always_iterable(<span class="py-builtin">None</span>))
<span class="py-output">[]</span>
</pre><p>By default, binary and text strings are not considered iterable:</p>
<pre class="rst-literal-block">
    &gt;&gt;&gt; obj = 'foo'
    &gt;&gt;&gt; list(always_iterable(obj))
    ['foo']
</pre>
<p>If *base_type* is set, objects for which ``isinstance(obj, base_type)`` returns ``True`` won't be considered iterable.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>obj = {<span class="py-string">'a'</span>: 1}
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(always_iterable(obj))  <span class="py-comment"># Iterate over the dict's keys</span>
<span class="py-output">['a']</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(always_iterable(obj, base_type=<span class="py-builtin">dict</span>))  <span class="py-comment"># Treat dicts as a unit</span>
<span class="py-output">[{'a': 1}]</span>
</pre><p>Set *base_type* to ``None`` to avoid any special handling and treat objects Python considers iterable as iterable:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>obj = <span class="py-string">'foo'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(always_iterable(obj, base_type=<span class="py-builtin">None</span>))
<span class="py-output">['f', 'o', 'o']</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.always_reversible">
    
  </a>
  <a name="always_reversible">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">always_reversible</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2409">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>An extension of :func:`reversed` that supports all iterables, not just those which implement the ``Reversible`` or ``Sequence`` protocols.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">print</span>(*always_reversible(x <span class="py-keyword">for</span> x <span class="py-keyword">in</span> <span class="py-builtin">range</span>(3)))
<span class="py-output">2 1 0</span>
</pre><p>If the iterable is already reversible, this function returns the result of :func:`reversed()`. If the iterable is not reversible, this function will cache the remaining items in the iterable and yield them in reverse order, which may require significant storage.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.chunked">
    
  </a>
  <a name="chunked">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">chunked</span>(iterable, n, strict=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L126">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Break *iterable* into lists of length *n*:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(chunked([1, 2, 3, 4, 5, 6], 3))
<span class="py-output">[[1, 2, 3], [4, 5, 6]]</span>
</pre><p>By the default, the last yielded list will have fewer than *n* elements if the length of *iterable* is not divisible by *n*:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))
<span class="py-output">[[1, 2, 3], [4, 5, 6], [7, 8]]</span>
</pre><p>To use a fill-in value instead, see the :func:`grouper` recipe.</p>
<p>If the length of *iterable* is not divisible by *n* and *strict* is ``True``, then ``ValueError`` will be raised before the last list is yielded.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.circular_shifts">
    
  </a>
  <a name="circular_shifts">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">circular_shifts</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2749">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a list of circular shifts of *iterable*.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>circular_shifts(<span class="py-builtin">range</span>(4))
<span class="py-output">[(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.collapse">
    
  </a>
  <a name="collapse">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">collapse</span>(iterable, base_type=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, levels=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1019">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Flatten an iterable with multiple levels of nesting (e.g., a list of lists of tuples) into non-iterable types.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [(1, 2), ([3, 4], [[5], [6]])]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collapse(iterable))
<span class="py-output">[1, 2, 3, 4, 5, 6]</span>
</pre><p>Binary and text strings are not considered iterable and will not be collapsed.</p>
<p>To avoid collapsing other types, specify *base_type*:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [<span class="py-string">'ab'</span>, (<span class="py-string">'cd'</span>, <span class="py-string">'ef'</span>), [<span class="py-string">'gh'</span>, <span class="py-string">'ij'</span>]]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collapse(iterable, base_type=<span class="py-builtin">tuple</span>))
<span class="py-output">['ab', ('cd', 'ef'), 'gh', 'ij']</span>
</pre><p>Specify *levels* to stop flattening after a certain level:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [(<span class="py-string">'a'</span>, [<span class="py-string">'b'</span>]), (<span class="py-string">'c'</span>, [<span class="py-string">'d'</span>])]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collapse(iterable))  <span class="py-comment"># Fully flattened</span>
<span class="py-output">['a', 'b', 'c', 'd']</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collapse(iterable, levels=1))  <span class="py-comment"># Only one level flattened</span>
<span class="py-output">['a', ['b'], 'c', ['d']]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.collate">
    
  </a>
  <a name="collate">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">collate</span>(*iterables, **kwargs):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L398">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a sorted merge of the items from each of several already-sorted *iterables*.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collate(<span class="py-string">'ACDZ'</span>, <span class="py-string">'AZ'</span>, <span class="py-string">'JKL'</span>))
<span class="py-output">['A', 'A', 'C', 'D', 'J', 'K', 'L', 'Z', 'Z']</span>
</pre><p>Works lazily, keeping only the next value from each iterable in memory. Use :func:`collate` to, for example, perform a n-way mergesort of items that don't fit in memory.</p>
<p>If a *key* function is specified, the iterables will be sorted according to its result:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>key = <span class="py-keyword">lambda</span> s: <span class="py-builtin">int</span>(s)  <span class="py-comment"># Sort by numeric value, not by string</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collate([<span class="py-string">'1'</span>, <span class="py-string">'10'</span>], [<span class="py-string">'2'</span>, <span class="py-string">'11'</span>], key=key))
<span class="py-output">['1', '2', '10', '11']</span>
</pre><p>If the *iterables* are sorted in descending order, set *reverse* to ``True``:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collate([5, 3, 1], [4, 2, 0], reverse=<span class="py-builtin">True</span>))
<span class="py-output">[5, 4, 3, 2, 1, 0]</span>
</pre><p>If the elements of the passed-in iterables are out of order, you might get unexpected results.</p>
<p>On Python 3.5+, this function is an alias for :func:`heapq.merge`.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.combination_index">
    
  </a>
  <a name="combination_index">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">combination_index</span>(element, iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3728">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Equivalent to ``list(combinations(iterable, r)).index(element)``</p>
<p>The subsequences of *iterable* that are of length *r* can be ordered lexicographically. :func:`combination_index` computes the index of the first *element*, without computing the previous combinations.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>combination_index(<span class="py-string">'adf'</span>, <span class="py-string">'abcdefg'</span>)
<span class="py-output">10</span>
</pre><p>``ValueError`` will be raised if the given *element* isn't one of the combinations of *iterable*.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.consecutive_groups">
    
  </a>
  <a name="consecutive_groups">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">consecutive_groups</span>(iterable, ordering=(lambda x: x)):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2427">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield groups of consecutive items using :func:`itertools.groupby`. The *ordering* function determines whether two items are adjacent by returning their position.</p>
<p>By default, the ordering function is the identity function. This is suitable for finding runs of numbers:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> group <span class="py-keyword">in</span> consecutive_groups(iterable):
<span class="py-more">... </span>    <span class="py-builtin">print</span>(<span class="py-builtin">list</span>(group))
<span class="py-output">[1]</span>
<span class="py-output">[10, 11, 12]</span>
<span class="py-output">[20]</span>
<span class="py-output">[30, 31, 32, 33]</span>
<span class="py-output">[40]</span>
</pre><p>For finding runs of adjacent letters, try using the :meth:`index` method of a string of letters:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> string <span class="py-keyword">import</span> ascii_lowercase
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-string">'abcdfgilmnop'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>ordering = ascii_lowercase.index
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> group <span class="py-keyword">in</span> consecutive_groups(iterable, ordering):
<span class="py-more">... </span>    <span class="py-builtin">print</span>(<span class="py-builtin">list</span>(group))
<span class="py-output">['a', 'b', 'c', 'd']</span>
<span class="py-output">['f', 'g']</span>
<span class="py-output">['i']</span>
<span class="py-output">['l', 'm', 'n', 'o', 'p']</span>
</pre><p>Each group of consecutive items is an iterator that shares it source with *iterable*. When an an output group is advanced, the previous group is no longer available unless its elements are copied (e.g., into a ``list``).</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 2, 11, 12, 21, 22]
<span class="py-prompt">&gt;&gt;&gt; </span>saved_groups = []
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> group <span class="py-keyword">in</span> consecutive_groups(iterable):
<span class="py-more">... </span>    saved_groups.append(<span class="py-builtin">list</span>(group))  <span class="py-comment"># Copy group elements</span>
<span class="py-prompt">&gt;&gt;&gt; </span>saved_groups
<span class="py-output">[[1, 2], [11, 12], [21, 22]]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.consumer">
    
  </a>
  <a name="consumer">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">consumer</span>(func):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L436">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Decorator that automatically advances a PEP-342-style "reverse iterator" to its first yield point so you don't have to call ``next()`` on it manually.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>@consumer
<span class="py-more">... </span><span class="py-keyword">def</span> <span class="py-defname">tally</span>():
<span class="py-more">... </span>    i = 0
<span class="py-more">... </span>    <span class="py-keyword">while</span> <span class="py-builtin">True</span>:
<span class="py-more">... </span>        <span class="py-builtin">print</span>(<span class="py-string">'Thing number %s is %s.'</span> % (i, (<span class="py-keyword">yield</span>)))
<span class="py-more">... </span>        i += 1
<span class="py-more">...</span>
<span class="py-prompt">&gt;&gt;&gt; </span>t = tally()
<span class="py-prompt">&gt;&gt;&gt; </span>t.send(<span class="py-string">'red'</span>)
<span class="py-output">Thing number 0 is red.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>t.send(<span class="py-string">'fish'</span>)
<span class="py-output">Thing number 1 is fish.</span>
</pre><p>Without the decorator, you would have to call ``next(t)`` before ``t.send()`` could be used.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.count_cycle">
    
  </a>
  <a name="count_cycle">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">count_cycle</span>(iterable, n=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2105">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Cycle through the items from *iterable* up to *n* times, yielding the number of completed cycles along with each item. If *n* is omitted the process repeats indefinitely.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(count_cycle(<span class="py-string">'AB'</span>, 3))
<span class="py-output">[(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.difference">
    
  </a>
  <a name="difference">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">difference</span>(iterable, func=<a href="https://docs.python.org/3/library/operator.html#operator.sub" class="intersphinx-link">sub</a>, *, initial=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2475">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>This function is the inverse of :func:`itertools.accumulate`. By default it will compute the first difference of *iterable* using :func:`operator.sub`:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> itertools <span class="py-keyword">import</span> accumulate
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = accumulate([0, 1, 2, 3, 4])  <span class="py-comment"># produces 0, 1, 3, 6, 10</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(difference(iterable))
<span class="py-output">[0, 1, 2, 3, 4]</span>
</pre><p>*func* defaults to :func:`operator.sub`, but other functions can be specified. They will be applied as follows:</p>
<pre class="rst-literal-block">
    A, B, C, D, ... --&gt; A, func(B, A), func(C, B), func(D, C), ...
</pre>
<p>For example, to do progressive division:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 2, 6, 24, 120]
<span class="py-prompt">&gt;&gt;&gt; </span>func = <span class="py-keyword">lambda</span> x, y: x // y
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(difference(iterable, func))
<span class="py-output">[1, 2, 3, 4, 5]</span>
</pre><p>If the *initial* keyword is set, the first element will be skipped when computing successive differences.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>it = [10, 11, 13, 16]  <span class="py-comment"># from accumulate([1, 2, 3], initial=10)</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(difference(it, initial=10))
<span class="py-output">[1, 2, 3]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.distinct_combinations">
    
  </a>
  <a name="distinct_combinations">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">distinct_combinations</span>(iterable, r):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3194">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the distinct combinations of *r* items taken from *iterable*.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(distinct_combinations([0, 0, 1], 2))
<span class="py-output">[(0, 0), (0, 1)]</span>
</pre><p>Equivalent to ``set(combinations(iterable))``, except duplicates are not generated and thrown away. For larger input sequences this is much more efficient.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.distinct_permutations">
    
  </a>
  <a name="distinct_permutations">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">distinct_permutations</span>(iterable, r=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L580">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield successive distinct permutations of the elements in *iterable*.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(distinct_permutations([1, 0, 1]))
<span class="py-output">[(0, 1, 1), (1, 0, 1), (1, 1, 0)]</span>
</pre><p>Equivalent to ``set(permutations(iterable))``, except duplicates are not generated and thrown away. For larger input sequences this is much more efficient.</p>
<p>Duplicate permutations arise when there are duplicated elements in the input iterable. The number of items returned is `n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of items input, and each `x_i` is the count of a distinct item in the input sequence.</p>
<p>If *r* is given, only the *r*-length permutations are yielded.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(distinct_permutations([1, 0, 1], r=2))
<span class="py-output">[(0, 1), (1, 0), (1, 1)]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(distinct_permutations(<span class="py-builtin">range</span>(3), r=2))
<span class="py-output">[(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.distribute">
    
  </a>
  <a name="distribute">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">distribute</span>(n, iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1418">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Distribute the items from *iterable* among *n* smaller iterables.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(group_1)
<span class="py-output">[1, 3, 5]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(group_2)
<span class="py-output">[2, 4, 6]</span>
</pre><p>If the length of *iterable* is not evenly divisible by *n*, then the length of the returned iterables will not be identical:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>children = distribute(3, [1, 2, 3, 4, 5, 6, 7])
<span class="py-prompt">&gt;&gt;&gt; </span>[<span class="py-builtin">list</span>(c) <span class="py-keyword">for</span> c <span class="py-keyword">in</span> children]
<span class="py-output">[[1, 4, 7], [2, 5], [3, 6]]</span>
</pre><p>If the length of *iterable* is smaller than *n*, then the last returned iterables will be empty:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>children = distribute(5, [1, 2, 3])
<span class="py-prompt">&gt;&gt;&gt; </span>[<span class="py-builtin">list</span>(c) <span class="py-keyword">for</span> c <span class="py-keyword">in</span> children]
<span class="py-output">[[1], [2], [3], [], []]</span>
</pre><p>This function uses :func:`itertools.tee` and may require significant storage. If you need the order items in the smaller iterables to match the original iterable, see :func:`divide`.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.divide">
    
  </a>
  <a name="divide">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">divide</span>(n, iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1700">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Divide the elements from *iterable* into *n* parts, maintaining order.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(group_1)
<span class="py-output">[1, 2, 3]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(group_2)
<span class="py-output">[4, 5, 6]</span>
</pre><p>If the length of *iterable* is not evenly divisible by *n*, then the length of the returned iterables will not be identical:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>children = divide(3, [1, 2, 3, 4, 5, 6, 7])
<span class="py-prompt">&gt;&gt;&gt; </span>[<span class="py-builtin">list</span>(c) <span class="py-keyword">for</span> c <span class="py-keyword">in</span> children]
<span class="py-output">[[1, 2, 3], [4, 5], [6, 7]]</span>
</pre><p>If the length of the iterable is smaller than n, then the last returned iterables will be empty:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>children = divide(5, [1, 2, 3])
<span class="py-prompt">&gt;&gt;&gt; </span>[<span class="py-builtin">list</span>(c) <span class="py-keyword">for</span> c <span class="py-keyword">in</span> children]
<span class="py-output">[[1], [2], [3], [], []]</span>
</pre><p>This function will exhaust the iterable before returning and may require significant storage. If order is not important, see :func:`distribute`, which does not first pull the iterable into memory.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.exactly_n">
    
  </a>
  <a name="exactly_n">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">exactly_n</span>(iterable, n, predicate=<a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2731">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return ``True`` if exactly ``n`` items in the iterable are ``True`` according to the *predicate* function.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>exactly_n([<span class="py-builtin">True</span>, <span class="py-builtin">True</span>, <span class="py-builtin">False</span>], 2)
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>exactly_n([<span class="py-builtin">True</span>, <span class="py-builtin">True</span>, <span class="py-builtin">False</span>], 1)
<span class="py-output">False</span>
<span class="py-prompt">&gt;&gt;&gt; </span>exactly_n([0, 1, 2, 3, 4, 5], 3, <span class="py-keyword">lambda</span> x: x &lt; 3)
<span class="py-output">True</span>
</pre><p>The iterable will be advanced until ``n + 1`` truthy items are encountered, so avoid calling it on infinite iterables.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.filter_except">
    
  </a>
  <a name="filter_except">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">filter_except</span>(validator, iterable, *exceptions):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3234">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the items from *iterable* for which the *validator* function does not raise one of the specified *exceptions*.</p>
<p>*validator* is called for each item in *iterable*. It should be a function that accepts one argument and raises an exception if that item is not valid.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [<span class="py-string">'1'</span>, <span class="py-string">'2'</span>, <span class="py-string">'three'</span>, <span class="py-string">'4'</span>, <span class="py-builtin">None</span>]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(filter_except(<span class="py-builtin">int</span>, iterable, <span class="py-builtin">ValueError</span>, <span class="py-builtin">TypeError</span>))
<span class="py-output">['1', '2', '4']</span>
</pre><p>If an exception other than one given by *exceptions* is raised by *validator*, it is raised like normal.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.first">
    
  </a>
  <a name="first">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">first</span>(iterable, default=<a href="#_marker" class="internal-link" title="setuptools._vendor.more_itertools.more._marker">_marker</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L159">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the first item of *iterable*, or *default* if *iterable* is empty.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>first([0, 1, 2, 3])
<span class="py-output">0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>first([], <span class="py-string">'some default'</span>)
<span class="py-output">'some default'</span>
</pre><p>If *default* is not provided and there are no items in the iterable, raise ``ValueError``.</p>
<p>:func:`first` is useful when you have a generator of expensive-to-retrieve values and want any arbitrary one. It is marginally shorter than ``next(iter(iterable), default)``.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.groupby_transform">
    
  </a>
  <a name="groupby_transform">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">groupby_transform</span>(iterable, keyfunc=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, valuefunc=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, reducefunc=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1843">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.ichunked">
    
  </a>
  <a name="ichunked">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">ichunked</span>(iterable, n):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3157">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Break *iterable* into sub-iterables with *n* elements each. :func:`ichunked` is like :func:`chunked`, but it yields iterables instead of lists.</p>
<p>If the sub-iterables are read in order, the elements of *iterable* won't be stored in memory. If they are read out of order, :func:`itertools.tee` is used to cache elements as necessary.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> itertools <span class="py-keyword">import</span> count
<span class="py-prompt">&gt;&gt;&gt; </span>all_chunks = ichunked(count(), 4)
<span class="py-prompt">&gt;&gt;&gt; </span>c_1, c_2, c_3 = <span class="py-builtin">next</span>(all_chunks), <span class="py-builtin">next</span>(all_chunks), <span class="py-builtin">next</span>(all_chunks)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(c_2)  <span class="py-comment"># c_1's elements have been cached; c_3's haven't been</span>
<span class="py-output">[4, 5, 6, 7]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(c_1)
<span class="py-output">[0, 1, 2, 3]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(c_3)
<span class="py-output">[8, 9, 10, 11]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.ilen">
    
  </a>
  <a name="ilen">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">ilen</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L468">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the number of items in *iterable*.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>ilen(x <span class="py-keyword">for</span> x <span class="py-keyword">in</span> <span class="py-builtin">range</span>(1000000) <span class="py-keyword">if</span> x % 3 == 0)
<span class="py-output">333334</span>
</pre><p>This consumes the iterable, so handle with care.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.interleave">
    
  </a>
  <a name="interleave">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">interleave</span>(*iterables):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L989">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a new iterable yielding from each iterable in turn, until the shortest is exhausted.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(interleave([1, 2, 3], [4, 5], [6, 7, 8]))
<span class="py-output">[1, 4, 6, 2, 5, 7]</span>
</pre><p>For a version that doesn't terminate after the shortest iterable is exhausted, see :func:`interleave_longest`.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.interleave_longest">
    
  </a>
  <a name="interleave_longest">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">interleave_longest</span>(*iterables):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1003">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a new iterable yielding from each iterable in turn, skipping any that are exhausted.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))
<span class="py-output">[1, 4, 6, 2, 5, 7, 3, 8]</span>
</pre><p>This function produces the same output as :func:`roundrobin`, but may perform better for some inputs (in particular when the number of iterables is large).</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.intersperse">
    
  </a>
  <a name="intersperse">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">intersperse</span>(e, iterable, n=1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L680">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Intersperse filler element *e* among the items in *iterable*, leaving *n* items between each filler element.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(intersperse(<span class="py-string">'!'</span>, [1, 2, 3, 4, 5]))
<span class="py-output">[1, '!', 2, '!', 3, '!', 4, '!', 5]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(intersperse(<span class="py-builtin">None</span>, [1, 2, 3, 4, 5], n=2))
<span class="py-output">[1, 2, None, 3, 4, None, 5]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.is_sorted">
    
  </a>
  <a name="is_sorted">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_sorted</span>(iterable, key=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, reverse=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3376">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns ``True`` if the items of iterable are in sorted order, and ``False`` otherwise. *key* and *reverse* have the same meaning that they do in the built-in :func:`sorted` function.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>is_sorted([<span class="py-string">'1'</span>, <span class="py-string">'2'</span>, <span class="py-string">'3'</span>, <span class="py-string">'4'</span>, <span class="py-string">'5'</span>], key=<span class="py-builtin">int</span>)
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>is_sorted([5, 4, 3, 1, 2], reverse=<span class="py-builtin">True</span>)
<span class="py-output">False</span>
</pre><p>The function returns ``False`` after encountering the first out-of-order item. If there are no out-of-order items, the iterable is exhausted.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.iterate">
    
  </a>
  <a name="iterate">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">iterate</span>(func, start):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L485">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return ``start``, ``func(start)``, ``func(func(start))``, ...</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> itertools <span class="py-keyword">import</span> islice
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(islice(iterate(<span class="py-keyword">lambda</span> x: 2*x, 1), 10))
<span class="py-output">[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.last">
    
  </a>
  <a name="last">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">last</span>(iterable, default=<a href="#_marker" class="internal-link" title="setuptools._vendor.more_itertools.more._marker">_marker</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L187">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the last item of *iterable*, or *default* if *iterable* is empty.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>last([0, 1, 2, 3])
<span class="py-output">3</span>
<span class="py-prompt">&gt;&gt;&gt; </span>last([], <span class="py-string">'some default'</span>)
<span class="py-output">'some default'</span>
</pre><p>If *default* is not provided and there are no items in the iterable, raise ``ValueError``.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.locate">
    
  </a>
  <a name="locate">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">locate</span>(iterable, pred=<a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a>, window_size=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2158">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the index of each item in *iterable* for which *pred* returns ``True``.</p>
<p>*pred* defaults to :func:`bool`, which will select truthy items:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(locate([0, 1, 1, 0, 1, 0, 0]))
<span class="py-output">[1, 2, 4]</span>
</pre><p>Set *pred* to a custom function to, e.g., find the indexes for a particular item.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(locate([<span class="py-string">'a'</span>, <span class="py-string">'b'</span>, <span class="py-string">'c'</span>, <span class="py-string">'b'</span>], <span class="py-keyword">lambda</span> x: x == <span class="py-string">'b'</span>))
<span class="py-output">[1, 3]</span>
</pre><p>If *window_size* is given, then the *pred* function will be called with that many items. This enables searching for sub-sequences:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> *args: args == (1, 2, 3)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(locate(iterable, pred=pred, window_size=3))
<span class="py-output">[1, 5, 9]</span>
</pre><p>Use with :func:`seekable` to find indexes and then retrieve the associated items:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> itertools <span class="py-keyword">import</span> count
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> more_itertools <span class="py-keyword">import</span> seekable
<span class="py-prompt">&gt;&gt;&gt; </span>source = (3 * n + 1 <span class="py-keyword">if</span> (n % 2) <span class="py-keyword">else</span> n // 2 <span class="py-keyword">for</span> n <span class="py-keyword">in</span> count())
<span class="py-prompt">&gt;&gt;&gt; </span>it = seekable(source)
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x &gt; 100
<span class="py-prompt">&gt;&gt;&gt; </span>indexes = locate(it, pred=pred)
<span class="py-prompt">&gt;&gt;&gt; </span>i = <span class="py-builtin">next</span>(indexes)
<span class="py-prompt">&gt;&gt;&gt; </span>it.seek(i)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">next</span>(it)
<span class="py-output">106</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.lstrip">
    
  </a>
  <a name="lstrip">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">lstrip</span>(iterable, pred):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2206">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the items from *iterable*, but strip any from the beginning for which *pred* returns ``True``.</p>
<p>For example, to remove a set of items from the start of an iterable:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = (<span class="py-builtin">None</span>, <span class="py-builtin">False</span>, <span class="py-builtin">None</span>, 1, 2, <span class="py-builtin">None</span>, 3, <span class="py-builtin">False</span>, <span class="py-builtin">None</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x <span class="py-keyword">in</span> {<span class="py-builtin">None</span>, <span class="py-builtin">False</span>, <span class="py-string">''</span>}
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(lstrip(iterable, pred))
<span class="py-output">[1, 2, None, 3, False, None]</span>
</pre><p>This function is analogous to to :func:`str.lstrip`, and is essentially an wrapper for :func:`itertools.dropwhile`.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.make_decorator">
    
  </a>
  <a name="make_decorator">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">make_decorator</span>(wrapping_func, result_index=0):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2759">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a decorator version of *wrapping_func*, which is a function that modifies an iterable. *result_index* is the position in that function's signature where the iterable goes.</p>
<p>This lets you use itertools on the "production end," i.e. at function definition. This can augment what the function returns without changing the function's code.</p>
<p>For example, to produce a decorator version of :func:`chunked`:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> more_itertools <span class="py-keyword">import</span> chunked
<span class="py-prompt">&gt;&gt;&gt; </span>chunker = make_decorator(chunked, result_index=0)
<span class="py-prompt">&gt;&gt;&gt; </span>@chunker(3)
<span class="py-more">... </span><span class="py-keyword">def</span> <span class="py-defname">iter_range</span>(n):
<span class="py-more">... </span>    <span class="py-keyword">return</span> <span class="py-builtin">iter</span>(<span class="py-builtin">range</span>(n))
<span class="py-more">...</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(iter_range(9))
<span class="py-output">[[0, 1, 2], [3, 4, 5], [6, 7, 8]]</span>
</pre><p>To only allow truthy items to be returned:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>truth_serum = make_decorator(<span class="py-builtin">filter</span>, result_index=1)
<span class="py-prompt">&gt;&gt;&gt; </span>@truth_serum(<span class="py-builtin">bool</span>)
<span class="py-more">... </span><span class="py-keyword">def</span> <span class="py-defname">boolean_test</span>():
<span class="py-more">... </span>    <span class="py-keyword">return</span> [0, 1, <span class="py-string">''</span>, <span class="py-string">' '</span>, <span class="py-builtin">False</span>, <span class="py-builtin">True</span>]
<span class="py-more">...</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(boolean_test())
<span class="py-output">[1, ' ', True]</span>
</pre><p>The :func:`peekable` and :func:`seekable` wrappers make for practical decorators:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> more_itertools <span class="py-keyword">import</span> peekable
<span class="py-prompt">&gt;&gt;&gt; </span>peekable_function = make_decorator(peekable)
<span class="py-prompt">&gt;&gt;&gt; </span>@peekable_function()
<span class="py-more">... </span><span class="py-keyword">def</span> <span class="py-defname">str_range</span>(*args):
<span class="py-more">... </span>    <span class="py-keyword">return</span> (<span class="py-builtin">str</span>(x) <span class="py-keyword">for</span> x <span class="py-keyword">in</span> <span class="py-builtin">range</span>(*args))
<span class="py-more">...</span>
<span class="py-prompt">&gt;&gt;&gt; </span>it = str_range(1, 20, 2)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">next</span>(it), <span class="py-builtin">next</span>(it), <span class="py-builtin">next</span>(it)
<span class="py-output">('1', '3', '5')</span>
<span class="py-prompt">&gt;&gt;&gt; </span>it.peek()
<span class="py-output">'7'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">next</span>(it)
<span class="py-output">'7'</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.map_except">
    
  </a>
  <a name="map_except">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">map_except</span>(function, iterable, *exceptions):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3258">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Transform each item from *iterable* with *function* and yield the result, unless *function* raises one of the specified *exceptions*.</p>
<p>*function* is called to transform each item in *iterable*. It should be a accept one argument.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [<span class="py-string">'1'</span>, <span class="py-string">'2'</span>, <span class="py-string">'three'</span>, <span class="py-string">'4'</span>, <span class="py-builtin">None</span>]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(map_except(<span class="py-builtin">int</span>, iterable, <span class="py-builtin">ValueError</span>, <span class="py-builtin">TypeError</span>))
<span class="py-output">[1, 2, 4]</span>
</pre><p>If an exception other than one given by *exceptions* is raised by *function*, it is raised like normal.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.map_reduce">
    
  </a>
  <a name="map_reduce">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">map_reduce</span>(iterable, keyfunc, valuefunc=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, reducefunc=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2824">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a dictionary that maps the items in *iterable* to categories defined by *keyfunc*, transforms them with *valuefunc*, and then summarizes them by category with *reducefunc*.</p>
<p>*valuefunc* defaults to the identity function if it is unspecified. If *reducefunc* is unspecified, no summarization takes place:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>keyfunc = <span class="py-keyword">lambda</span> x: x.upper()
<span class="py-prompt">&gt;&gt;&gt; </span>result = map_reduce(<span class="py-string">'abbccc'</span>, keyfunc)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(result.items())
<span class="py-output">[('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]</span>
</pre><p>Specifying *valuefunc* transforms the categorized items:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>keyfunc = <span class="py-keyword">lambda</span> x: x.upper()
<span class="py-prompt">&gt;&gt;&gt; </span>valuefunc = <span class="py-keyword">lambda</span> x: 1
<span class="py-prompt">&gt;&gt;&gt; </span>result = map_reduce(<span class="py-string">'abbccc'</span>, keyfunc, valuefunc)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(result.items())
<span class="py-output">[('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]</span>
</pre><p>Specifying *reducefunc* summarizes the categorized items:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>keyfunc = <span class="py-keyword">lambda</span> x: x.upper()
<span class="py-prompt">&gt;&gt;&gt; </span>valuefunc = <span class="py-keyword">lambda</span> x: 1
<span class="py-prompt">&gt;&gt;&gt; </span>reducefunc = <span class="py-builtin">sum</span>
<span class="py-prompt">&gt;&gt;&gt; </span>result = map_reduce(<span class="py-string">'abbccc'</span>, keyfunc, valuefunc, reducefunc)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(result.items())
<span class="py-output">[('A', 1), ('B', 2), ('C', 3)]</span>
</pre><p>You may want to filter the input iterable before applying the map/reduce procedure:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>all_items = <span class="py-builtin">range</span>(30)
<span class="py-prompt">&gt;&gt;&gt; </span>items = [x <span class="py-keyword">for</span> x <span class="py-keyword">in</span> all_items <span class="py-keyword">if</span> 10 &lt;= x &lt;= 20]  <span class="py-comment"># Filter</span>
<span class="py-prompt">&gt;&gt;&gt; </span>keyfunc = <span class="py-keyword">lambda</span> x: x % 2  <span class="py-comment"># Evens map to 0; odds to 1</span>
<span class="py-prompt">&gt;&gt;&gt; </span>categories = map_reduce(items, keyfunc=keyfunc)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(categories.items())
<span class="py-output">[(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]</span>
<span class="py-prompt">&gt;&gt;&gt; </span>summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=<span class="py-builtin">sum</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(summaries.items())
<span class="py-output">[(0, 90), (1, 75)]</span>
</pre><p>Note that all items in the iterable are gathered into a list before the summarization step, which may require significant storage.</p>
<p>The returned object is a :obj:`collections.defaultdict` with the ``default_factory`` set to ``None``, such that it behaves like a normal dictionary.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.mark_ends">
    
  </a>
  <a name="mark_ends">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">mark_ends</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2121">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield 3-tuples of the form ``(is_first, is_last, item)``.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(mark_ends(<span class="py-string">'ABC'</span>))
<span class="py-output">[(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]</span>
</pre><p>Use this when looping over an iterable to take special action on its first and/or last items:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [<span class="py-string">'Header'</span>, 100, 200, <span class="py-string">'Footer'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>total = 0
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> is_first, is_last, item <span class="py-keyword">in</span> mark_ends(iterable):
<span class="py-more">... </span>    <span class="py-keyword">if</span> is_first:
<span class="py-more">... </span>        <span class="py-keyword">continue</span>  <span class="py-comment"># Skip the header</span>
<span class="py-more">... </span>    <span class="py-keyword">if</span> is_last:
<span class="py-more">... </span>        <span class="py-keyword">continue</span>  <span class="py-comment"># Skip the footer</span>
<span class="py-more">... </span>    total += item
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">print</span>(total)
<span class="py-output">300</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.nth_or_last">
    
  </a>
  <a name="nth_or_last">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">nth_or_last</span>(iterable, n, default=<a href="#_marker" class="internal-link" title="setuptools._vendor.more_itertools.more._marker">_marker</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L216">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the nth or the last item of *iterable*, or *default* if *iterable* is empty.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>nth_or_last([0, 1, 2, 3], 2)
<span class="py-output">2</span>
<span class="py-prompt">&gt;&gt;&gt; </span>nth_or_last([0, 1], 2)
<span class="py-output">1</span>
<span class="py-prompt">&gt;&gt;&gt; </span>nth_or_last([], 0, <span class="py-string">'some default'</span>)
<span class="py-output">'some default'</span>
</pre><p>If *default* is not provided and there are no items in the iterable, raise ``ValueError``.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.nth_permutation">
    
  </a>
  <a name="nth_permutation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">nth_permutation</span>(iterable, r, index):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3629">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Equivalent to ``list(permutations(iterable, r))[index]```</p>
<p>The subsequences of *iterable* that are of length *r* where order is important can be ordered lexicographically. :func:`nth_permutation` computes the subsequence at sort position *index* directly, without computing the previous subsequences.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>nth_permutation(<span class="py-string">'ghijk'</span>, 2, 5)
<span class="py-output">('h', 'i')</span>
</pre><p>``ValueError`` will be raised If *r* is negative or greater than the length of *iterable*. ``IndexError`` will be raised if the given *index* is invalid.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.nth_product">
    
  </a>
  <a name="nth_product">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">nth_product</span>(index, *args):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3598">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Equivalent to ``list(product(*args))[index]``.</p>
<p>The products of *args* can be ordered lexicographically. :func:`nth_product` computes the product at sort position *index* without computing the previous products.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>nth_product(8, <span class="py-builtin">range</span>(2), <span class="py-builtin">range</span>(2), <span class="py-builtin">range</span>(2), <span class="py-builtin">range</span>(2))
<span class="py-output">(1, 0, 0, 0)</span>
</pre><p>``IndexError`` will be raised if the given *index* is invalid.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.one">
    
  </a>
  <a name="one">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">one</span>(iterable, too_short=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, too_long=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L513">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the first item from *iterable*, which is expected to contain only that item. Raise an exception if *iterable* is empty or has more than one item.</p>
<p>:func:`one` is useful for ensuring that an iterable contains only one item. For example, it can be used to retrieve the result of a database query that is expected to return a single row.</p>
<p>If *iterable* is empty, ``ValueError`` will be raised. You may specify a different exception with the *too_short* keyword:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>it = []
<span class="py-prompt">&gt;&gt;&gt; </span>one(it)  <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">ValueError: too many items in iterable (expected 1)'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>too_short = <span class="py-builtin">IndexError</span>(<span class="py-string">'too few items'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>one(it, too_short=too_short)  <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">IndexError: too few items</span>
</pre><p>Similarly, if *iterable* contains more than one item, ``ValueError`` will be raised. You may specify a different exception with the *too_long* keyword:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>it = [<span class="py-string">'too'</span>, <span class="py-string">'many'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>one(it)  <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">ValueError: Expected exactly one item in iterable, but got 'too',</span>
<span class="py-except">'many', and perhaps more.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>too_long = <span class="py-builtin">RuntimeError</span>
<span class="py-prompt">&gt;&gt;&gt; </span>one(it, too_long=too_long)  <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">RuntimeError</span>
</pre><p>Note that :func:`one` attempts to advance *iterable* twice to ensure there is only one item. See :func:`spy` or :func:`peekable` to check iterable contents less destructively.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.only">
    
  </a>
  <a name="only">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">only</span>(iterable, default=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, too_long=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3116">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>If *iterable* has only one item, return it. If it has zero items, return *default*. If it has more than one item, raise the exception given by *too_long*, which is ``ValueError`` by default.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>only([], default=<span class="py-string">'missing'</span>)
<span class="py-output">'missing'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>only([1])
<span class="py-output">1</span>
<span class="py-prompt">&gt;&gt;&gt; </span>only([1, 2])  <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">ValueError: Expected exactly one item in iterable, but got 1, 2,</span>
<span class="py-except"> and perhaps more.'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>only([1, 2], too_long=<span class="py-builtin">TypeError</span>)  <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">TypeError</span>
</pre><p>Note that :func:`only` attempts to advance *iterable* twice to ensure there is only one item.  See :func:`spy` or :func:`peekable` to check iterable contents less destructively.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.padded">
    
  </a>
  <a name="padded">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">padded</span>(iterable, fillvalue=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, n=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, next_multiple=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1367">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the elements from *iterable*, followed by *fillvalue*, such that at least *n* items are emitted.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(padded([1, 2, 3], <span class="py-string">'?'</span>, 5))
<span class="py-output">[1, 2, 3, '?', '?']</span>
</pre><p>If *next_multiple* is ``True``, *fillvalue* will be emitted until the number of items emitted is a multiple of *n*:</p>
<pre class="rst-literal-block">
    &gt;&gt;&gt; list(padded([1, 2, 3, 4], n=3, next_multiple=True))
    [1, 2, 3, 4, None, None]
</pre>
<p>If *n* is ``None``, *fillvalue* will be emitted indefinitely.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.partitions">
    
  </a>
  <a name="partitions">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">partitions</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2995">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield all possible order-preserving partitions of *iterable*.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-string">'abc'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> part <span class="py-keyword">in</span> partitions(iterable):
<span class="py-more">... </span>    <span class="py-builtin">print</span>([<span class="py-string">''</span>.join(p) <span class="py-keyword">for</span> p <span class="py-keyword">in</span> part])
<span class="py-output">['abc']</span>
<span class="py-output">['a', 'bc']</span>
<span class="py-output">['ab', 'c']</span>
<span class="py-output">['a', 'b', 'c']</span>
</pre><p>This is unrelated to :func:`partition`.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.permutation_index">
    
  </a>
  <a name="permutation_index">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">permutation_index</span>(element, iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3771">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Equivalent to ``list(permutations(iterable, r)).index(element)```</p>
<p>The subsequences of *iterable* that are of length *r* where order is important can be ordered lexicographically. :func:`permutation_index` computes the index of the first *element* directly, without computing the previous permutations.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>permutation_index([1, 3, 2], <span class="py-builtin">range</span>(5))
<span class="py-output">19</span>
</pre><p>``ValueError`` will be raised if the given *element* isn't one of the permutations of *iterable*.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.product_index">
    
  </a>
  <a name="product_index">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">product_index</span>(element, *args):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3703">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Equivalent to ``list(product(*args)).index(element)``</p>
<p>The products of *args* can be ordered lexicographically. :func:`product_index` computes the first index of *element* without computing the previous products.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>product_index([8, 2], <span class="py-builtin">range</span>(10), <span class="py-builtin">range</span>(5))
<span class="py-output">42</span>
</pre><p>``ValueError`` will be raised if the given *element* isn't in the product of *args*.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.repeat_last">
    
  </a>
  <a name="repeat_last">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">repeat_last</span>(iterable, default=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1399">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>After the *iterable* is exhausted, keep yielding its last element.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(islice(repeat_last(<span class="py-builtin">range</span>(3)), 5))
<span class="py-output">[0, 1, 2, 2, 2]</span>
</pre><p>If the iterable is empty, yield *default* forever:</p>
<pre class="rst-literal-block">
    &gt;&gt;&gt; list(islice(repeat_last(range(0), 42), 5))
    [42, 42, 42, 42, 42]
</pre>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.replace">
    
  </a>
  <a name="replace">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">replace</span>(iterable, pred, substitutes, count=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, window_size=1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2934">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the items from *iterable*, replacing the items for which *pred* returns ``True`` with the items from the iterable *substitutes*.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 1, 0, 1, 1, 0, 1, 1]
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x == 0
<span class="py-prompt">&gt;&gt;&gt; </span>substitutes = (2, 3)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(replace(iterable, pred, substitutes))
<span class="py-output">[1, 1, 2, 3, 1, 1, 2, 3, 1, 1]</span>
</pre><p>If *count* is given, the number of replacements will be limited:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x == 0
<span class="py-prompt">&gt;&gt;&gt; </span>substitutes = [<span class="py-builtin">None</span>]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(replace(iterable, pred, substitutes, count=2))
<span class="py-output">[1, 1, None, 1, 1, None, 1, 1, 0]</span>
</pre><p>Use *window_size* to control the number of items passed as arguments to *pred*. This allows for locating and replacing subsequences.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [0, 1, 2, 5, 0, 1, 2, 5]
<span class="py-prompt">&gt;&gt;&gt; </span>window_size = 3
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> *args: args == (0, 1, 2)  <span class="py-comment"># 3 items passed to pred</span>
<span class="py-prompt">&gt;&gt;&gt; </span>substitutes = [3, 4] <span class="py-comment"># Splice in these items</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(replace(iterable, pred, substitutes, window_size=window_size))
<span class="py-output">[3, 4, 5, 3, 4, 5]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.rlocate">
    
  </a>
  <a name="rlocate">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rlocate</span>(iterable, pred=<a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a>, window_size=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2891">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the index of each item in *iterable* for which *pred* returns ``True``, starting from the right and moving left.</p>
<p>*pred* defaults to :func:`bool`, which will select truthy items:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(rlocate([0, 1, 1, 0, 1, 0, 0]))  <span class="py-comment"># Truthy at 1, 2, and 4</span>
<span class="py-output">[4, 2, 1]</span>
</pre><p>Set *pred* to a custom function to, e.g., find the indexes for a particular item:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-builtin">iter</span>(<span class="py-string">'abcb'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x == <span class="py-string">'b'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(rlocate(iterable, pred))
<span class="py-output">[3, 1]</span>
</pre><p>If *window_size* is given, then the *pred* function will be called with that many items. This enables searching for sub-sequences:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> *args: args == (1, 2, 3)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(rlocate(iterable, pred=pred, window_size=3))
<span class="py-output">[9, 5, 1]</span>
</pre><p>Beware, this function won't return anything for infinite iterables. If *iterable* is reversible, ``rlocate`` will reverse it and search from the right. Otherwise, it will search from the left and return the results in reverse order.</p>
<p>See :func:`locate` to for other example applications.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.rstrip">
    
  </a>
  <a name="rstrip">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rstrip</span>(iterable, pred):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2224">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the items from *iterable*, but strip any from the end for which *pred* returns ``True``.</p>
<p>For example, to remove a set of items from the end of an iterable:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = (<span class="py-builtin">None</span>, <span class="py-builtin">False</span>, <span class="py-builtin">None</span>, 1, 2, <span class="py-builtin">None</span>, 3, <span class="py-builtin">False</span>, <span class="py-builtin">None</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x <span class="py-keyword">in</span> {<span class="py-builtin">None</span>, <span class="py-builtin">False</span>, <span class="py-string">''</span>}
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(rstrip(iterable, pred))
<span class="py-output">[None, False, None, 1, 2, None, 3]</span>
</pre><p>This function is analogous to :func:`str.rstrip`.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.sample">
    
  </a>
  <a name="sample">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">sample</span>(iterable, k, weights=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3340">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a *k*-length list of elements chosen (without replacement) from the *iterable*. Like :func:`random.sample`, but works on iterables of unknown length.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-builtin">range</span>(100)
<span class="py-prompt">&gt;&gt;&gt; </span>sample(iterable, 5)  <span class="py-comment"># doctest: +SKIP</span>
<span class="py-output">[81, 60, 96, 16, 4]</span>
</pre><p>An iterable with *weights* may also be given:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-builtin">range</span>(100)
<span class="py-prompt">&gt;&gt;&gt; </span>weights = (i * i + 1 <span class="py-keyword">for</span> i <span class="py-keyword">in</span> <span class="py-builtin">range</span>(100))
<span class="py-prompt">&gt;&gt;&gt; </span>sampled = sample(iterable, 5, weights=weights)  <span class="py-comment"># doctest: +SKIP</span>
<span class="py-output">[79, 67, 74, 66, 78]</span>
</pre><p>The algorithm can also be used to generate weighted random permutations. The relative weight of each item determines the probability that it appears late in the permutation.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>data = <span class="py-string">"abcdefgh"</span>
<span class="py-prompt">&gt;&gt;&gt; </span>weights = <span class="py-builtin">range</span>(1, <span class="py-builtin">len</span>(data) + 1)
<span class="py-prompt">&gt;&gt;&gt; </span>sample(data, k=<span class="py-builtin">len</span>(data), weights=weights)  <span class="py-comment"># doctest: +SKIP</span>
<span class="py-output">['c', 'a', 'b', 'e', 'g', 'd', 'h', 'f']</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.set_partitions">
    
  </a>
  <a name="set_partitions">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">set_partitions</span>(iterable, k=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3015">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the set partitions of *iterable* into *k* parts. Set partitions are not order-preserving.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-string">'abc'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> part <span class="py-keyword">in</span> set_partitions(iterable, 2):
<span class="py-more">... </span>    <span class="py-builtin">print</span>([<span class="py-string">''</span>.join(p) <span class="py-keyword">for</span> p <span class="py-keyword">in</span> part])
<span class="py-output">['a', 'bc']</span>
<span class="py-output">['ab', 'c']</span>
<span class="py-output">['b', 'ac']</span>
</pre><p>If *k* is not given, every set partition is generated.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-string">'abc'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> part <span class="py-keyword">in</span> set_partitions(iterable):
<span class="py-more">... </span>    <span class="py-builtin">print</span>([<span class="py-string">''</span>.join(p) <span class="py-keyword">for</span> p <span class="py-keyword">in</span> part])
<span class="py-output">['abc']</span>
<span class="py-output">['a', 'bc']</span>
<span class="py-output">['ab', 'c']</span>
<span class="py-output">['b', 'ac']</span>
<span class="py-output">['a', 'b', 'c']</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.side_effect">
    
  </a>
  <a name="side_effect">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">side_effect</span>(func, iterable, chunk_size=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, before=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, after=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1067">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Invoke *func* on each item in *iterable* (or on each *chunk_size* group of items) before yielding the item.</p>
<p>`func` must be a function that takes a single argument. Its return value will be discarded.</p>
<p>*before* and *after* are optional functions that take no arguments. They will be executed before iteration starts and after it ends, respectively.</p>
<p>`side_effect` can be used for logging, updating progress bars, or anything that is not functionally "pure."</p>
<p>Emitting a status message:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> more_itertools <span class="py-keyword">import</span> consume
<span class="py-prompt">&gt;&gt;&gt; </span>func = <span class="py-keyword">lambda</span> item: <span class="py-builtin">print</span>(<span class="py-string">'Received {}'</span>.format(item))
<span class="py-prompt">&gt;&gt;&gt; </span>consume(side_effect(func, <span class="py-builtin">range</span>(2)))
<span class="py-output">Received 0</span>
<span class="py-output">Received 1</span>
</pre><p>Operating on chunks of items:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>pair_sums = []
<span class="py-prompt">&gt;&gt;&gt; </span>func = <span class="py-keyword">lambda</span> chunk: pair_sums.append(<span class="py-builtin">sum</span>(chunk))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(side_effect(func, [0, 1, 2, 3, 4, 5], 2))
<span class="py-output">[0, 1, 2, 3, 4, 5]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(pair_sums)
<span class="py-output">[1, 5, 9]</span>
</pre><p>Writing to a file-like object:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> io <span class="py-keyword">import</span> StringIO
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> more_itertools <span class="py-keyword">import</span> consume
<span class="py-prompt">&gt;&gt;&gt; </span>f = StringIO()
<span class="py-prompt">&gt;&gt;&gt; </span>func = <span class="py-keyword">lambda</span> x: <span class="py-builtin">print</span>(x, file=f)
<span class="py-prompt">&gt;&gt;&gt; </span>before = <span class="py-keyword">lambda</span>: <span class="py-builtin">print</span>(u<span class="py-string">'HEADER'</span>, file=f)
<span class="py-prompt">&gt;&gt;&gt; </span>after = f.close
<span class="py-prompt">&gt;&gt;&gt; </span>it = [u<span class="py-string">'a'</span>, u<span class="py-string">'b'</span>, u<span class="py-string">'c'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>consume(side_effect(func, it, before=before, after=after))
<span class="py-prompt">&gt;&gt;&gt; </span>f.closed
<span class="py-output">True</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.sliced">
    
  </a>
  <a name="sliced">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">sliced</span>(seq, n, strict=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1128">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield slices of length *n* from the sequence *seq*.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(sliced((1, 2, 3, 4, 5, 6), 3))
<span class="py-output">[(1, 2, 3), (4, 5, 6)]</span>
</pre><p>By the default, the last yielded slice will have fewer than *n* elements if the length of *seq* is not divisible by *n*:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))
<span class="py-output">[(1, 2, 3), (4, 5, 6), (7, 8)]</span>
</pre><p>If the length of *seq* is not divisible by *n* and *strict* is ``True``, then ``ValueError`` will be raised before the last slice is yielded.</p>
<p>This function will only work for iterables that support slicing. For non-sliceable iterables, see :func:`chunked`.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.sort_together">
    
  </a>
  <a name="sort_together">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">sort_together</span>(iterables, key_list=(<wbr></wbr>0), key=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, reverse=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1585">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the input iterables sorted together, with *key_list* as the priority for sorting. All iterables are trimmed to the length of the shortest one.</p>
<p>This can be used like the sorting function in a spreadsheet. If each iterable represents a column of data, the key list determines which columns are used for sorting.</p>
<p>By default, all iterables are sorted using the ``0``-th iterable:</p>
<pre class="rst-literal-block">
    &gt;&gt;&gt; iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]
    &gt;&gt;&gt; sort_together(iterables)
    [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]
</pre>
<p>Set a different key list to sort according to another iterable. Specifying multiple keys dictates how ties are broken:</p>
<pre class="rst-literal-block">
    &gt;&gt;&gt; iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]
    &gt;&gt;&gt; sort_together(iterables, key_list=(1, 2))
    [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]
</pre>
<p>To sort by a function of the elements of the iterable, pass a *key* function. Its arguments are the elements of the iterables corresponding to the key list:</p>
<pre class="rst-literal-block">
    &gt;&gt;&gt; names = ('a', 'b', 'c')
    &gt;&gt;&gt; lengths = (1, 2, 3)
    &gt;&gt;&gt; widths = (5, 2, 1)
    &gt;&gt;&gt; def area(length, width):
    ...     return length * width
    &gt;&gt;&gt; sort_together([names, lengths, widths], key_list=(1, 2), key=area)
    [('c', 'b', 'a'), (3, 2, 1), (1, 2, 5)]
</pre>
<p>Set *reverse* to ``True`` to sort in descending order.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>sort_together([(1, 2, 3), (<span class="py-string">'c'</span>, <span class="py-string">'b'</span>, <span class="py-string">'a'</span>)], reverse=<span class="py-builtin">True</span>)
<span class="py-output">[(3, 2, 1), ('a', 'b', 'c')]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.split_after">
    
  </a>
  <a name="split_after">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">split_after</span>(iterable, pred, maxsplit=-1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1241">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield lists of items from *iterable*, where each list ends with an item where callable *pred* returns ``True``:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_after(<span class="py-string">'one1two2'</span>, <span class="py-keyword">lambda</span> s: s.isdigit()))
<span class="py-output">[['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_after(<span class="py-builtin">range</span>(10), <span class="py-keyword">lambda</span> n: n % 3 == 0))
<span class="py-output">[[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]</span>
</pre><p>At most *maxsplit* splits are done. If *maxsplit* is not specified or -1, then there is no limit on the number of splits:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_after(<span class="py-builtin">range</span>(10), <span class="py-keyword">lambda</span> n: n % 3 == 0, maxsplit=2))
<span class="py-output">[[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.split_at">
    
  </a>
  <a name="split_at">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">split_at</span>(iterable, pred, maxsplit=-1, keep_separator=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1162">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield lists of items from *iterable*, where each list is delimited by an item where callable *pred* returns ``True``.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_at(<span class="py-string">'abcdcba'</span>, <span class="py-keyword">lambda</span> x: x == <span class="py-string">'b'</span>))
<span class="py-output">[['a'], ['c', 'd', 'c'], ['a']]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_at(<span class="py-builtin">range</span>(10), <span class="py-keyword">lambda</span> n: n % 2 == 1))
<span class="py-output">[[0], [2], [4], [6], [8], []]</span>
</pre><p>At most *maxsplit* splits are done. If *maxsplit* is not specified or -1, then there is no limit on the number of splits:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_at(<span class="py-builtin">range</span>(10), <span class="py-keyword">lambda</span> n: n % 2 == 1, maxsplit=2))
<span class="py-output">[[0], [2], [4, 5, 6, 7, 8, 9]]</span>
</pre><p>By default, the delimiting items are not included in the output. The include them, set *keep_separator* to ``True``.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_at(<span class="py-string">'abcdcba'</span>, <span class="py-keyword">lambda</span> x: x == <span class="py-string">'b'</span>, keep_separator=<span class="py-builtin">True</span>))
<span class="py-output">[['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a']]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.split_before">
    
  </a>
  <a name="split_before">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">split_before</span>(iterable, pred, maxsplit=-1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1206">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield lists of items from *iterable*, where each list ends just before an item for which callable *pred* returns ``True``:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_before(<span class="py-string">'OneTwo'</span>, <span class="py-keyword">lambda</span> s: s.isupper()))
<span class="py-output">[['O', 'n', 'e'], ['T', 'w', 'o']]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_before(<span class="py-builtin">range</span>(10), <span class="py-keyword">lambda</span> n: n % 3 == 0))
<span class="py-output">[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]</span>
</pre><p>At most *maxsplit* splits are done. If *maxsplit* is not specified or -1, then there is no limit on the number of splits:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_before(<span class="py-builtin">range</span>(10), <span class="py-keyword">lambda</span> n: n % 3 == 0, maxsplit=2))
<span class="py-output">[[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.split_into">
    
  </a>
  <a name="split_into">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">split_into</span>(iterable, sizes):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1322">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield a list of sequential items from *iterable* of length 'n' for each integer 'n' in *sizes*.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_into([1,2,3,4,5,6], [1,2,3]))
<span class="py-output">[[1], [2, 3], [4, 5, 6]]</span>
</pre><p>If the sum of *sizes* is smaller than the length of *iterable*, then the remaining items of *iterable* will not be returned.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_into([1,2,3,4,5,6], [2,3]))
<span class="py-output">[[1, 2], [3, 4, 5]]</span>
</pre><p>If the sum of *sizes* is larger than the length of *iterable*, fewer items will be returned in the iteration that overruns *iterable* and further lists will be empty:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_into([1,2,3,4], [1,2,3,4]))
<span class="py-output">[[1], [2, 3], [4], []]</span>
</pre><p>When a ``None`` object is encountered in *sizes*, the returned list will contain items up to the end of *iterable* the same way that itertools.slice does:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,<span class="py-builtin">None</span>]))
<span class="py-output">[[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]</span>
</pre><p>:func:`split_into` can be useful for grouping a series of items where the sizes of the groups are not uniform. An example would be where in a row from a table, multiple columns represent elements of the same feature (e.g. a point represented by x,y,z) but, the format is not the same for all columns.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.split_when">
    
  </a>
  <a name="split_when">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">split_when</span>(iterable, pred, maxsplit=-1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1277">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Split *iterable* into pieces based on the output of *pred*. *pred* should be a function that takes successive pairs of items and returns ``True`` if the iterable should be split in between them.</p>
<p>For example, to find runs of increasing numbers, split the iterable when element ``i`` is larger than element ``i + 1``:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], <span class="py-keyword">lambda</span> x, y: x &gt; y))
<span class="py-output">[[1, 2, 3, 3], [2, 5], [2, 4], [2]]</span>
</pre><p>At most *maxsplit* splits are done. If *maxsplit* is not specified or -1, then there is no limit on the number of splits:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],
<span class="py-more">... </span>                <span class="py-keyword">lambda</span> x, y: x &gt; y, maxsplit=2))
<span class="py-output">[[1, 2, 3, 3], [2, 5], [2, 4, 2]]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.spy">
    
  </a>
  <a name="spy">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">spy</span>(iterable, n=1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L946">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a 2-tuple with a list containing the first *n* elements of *iterable*, and an iterator with the same items as *iterable*. This allows you to "look ahead" at the items in the iterable without advancing it.</p>
<p>There is one item in the list by default:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-string">'abcdefg'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>head, iterable = spy(iterable)
<span class="py-prompt">&gt;&gt;&gt; </span>head
<span class="py-output">['a']</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(iterable)
<span class="py-output">['a', 'b', 'c', 'd', 'e', 'f', 'g']</span>
</pre><p>You may use unpacking to retrieve items instead of lists:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>(head,), iterable = spy(<span class="py-string">'abcdefg'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>head
<span class="py-output">'a'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>(first, second), iterable = spy(<span class="py-string">'abcdefg'</span>, 2)
<span class="py-prompt">&gt;&gt;&gt; </span>first
<span class="py-output">'a'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>second
<span class="py-output">'b'</span>
</pre><p>The number of items requested can be larger than the number of items in the iterable:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 2, 3, 4, 5]
<span class="py-prompt">&gt;&gt;&gt; </span>head, iterable = spy(iterable, 10)
<span class="py-prompt">&gt;&gt;&gt; </span>head
<span class="py-output">[1, 2, 3, 4, 5]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(iterable)
<span class="py-output">[1, 2, 3, 4, 5]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.stagger">
    
  </a>
  <a name="stagger">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">stagger</span>(iterable, offsets=(<wbr></wbr>-1, <wbr></wbr>0, <wbr></wbr>1), longest=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>, fillvalue=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1453">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield tuples whose elements are offset from *iterable*. The amount by which the `i`-th item in each tuple is offset is given by the `i`-th item in *offsets*.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(stagger([0, 1, 2, 3]))
<span class="py-output">[(None, 0, 1), (0, 1, 2), (1, 2, 3)]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(stagger(<span class="py-builtin">range</span>(8), offsets=(0, 2, 4)))
<span class="py-output">[(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]</span>
</pre><p>By default, the sequence will end when the final element of a tuple is the last item in the iterable. To continue until the first element of a tuple is the last item in the iterable, set *longest* to ``True``:</p>
<pre class="rst-literal-block">
    &gt;&gt;&gt; list(stagger([0, 1, 2, 3], longest=True))
    [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]
</pre>
<p>By default, ``None`` will be used to replace offsets beyond the end of the sequence. Specify *fillvalue* to use some other value.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.strip">
    
  </a>
  <a name="strip">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">strip</span>(iterable, pred):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2250">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the items from *iterable*, but strip any from the beginning and end for which *pred* returns ``True``.</p>
<p>For example, to remove a set of items from both ends of an iterable:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = (<span class="py-builtin">None</span>, <span class="py-builtin">False</span>, <span class="py-builtin">None</span>, 1, 2, <span class="py-builtin">None</span>, 3, <span class="py-builtin">False</span>, <span class="py-builtin">None</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x <span class="py-keyword">in</span> {<span class="py-builtin">None</span>, <span class="py-builtin">False</span>, <span class="py-string">''</span>}
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(strip(iterable, pred))
<span class="py-output">[1, 2, None, 3]</span>
</pre><p>This function is analogous to :func:`str.strip`.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.substrings">
    
  </a>
  <a name="substrings">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">substrings</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L790">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield all of the substrings of *iterable*.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>[<span class="py-string">''</span>.join(s) <span class="py-keyword">for</span> s <span class="py-keyword">in</span> substrings(<span class="py-string">'more'</span>)]
<span class="py-output">['m', 'o', 'r', 'e', 'mo', 'or', 're', 'mor', 'ore', 'more']</span>
</pre><p>Note that non-string iterables can also be subdivided.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(substrings([0, 1, 2]))
<span class="py-output">[(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.substrings_indexes">
    
  </a>
  <a name="substrings_indexes">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">substrings_indexes</span>(seq, reverse=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L816">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield all substrings and their positions in *seq*</p>
<p>The items yielded will be a tuple of the form ``(substr, i, j)``, where ``substr == seq[i:j]``.</p>
<p>This function only works for iterables that support slicing, such as ``str`` objects.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> item <span class="py-keyword">in</span> substrings_indexes(<span class="py-string">'more'</span>):
<span class="py-more">... </span>   <span class="py-builtin">print</span>(item)
<span class="py-output">('m', 0, 1)</span>
<span class="py-output">('o', 1, 2)</span>
<span class="py-output">('r', 2, 3)</span>
<span class="py-output">('e', 3, 4)</span>
<span class="py-output">('mo', 0, 2)</span>
<span class="py-output">('or', 1, 3)</span>
<span class="py-output">('re', 2, 4)</span>
<span class="py-output">('mor', 0, 3)</span>
<span class="py-output">('ore', 1, 4)</span>
<span class="py-output">('more', 0, 4)</span>
</pre><p>Set *reverse* to ``True`` to yield the same items in the opposite order.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.unique_to_each">
    
  </a>
  <a name="unique_to_each">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">unique_to_each</span>(*iterables):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L706">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the elements from each of the input iterables that aren't in the other input iterables.</p>
<p>For example, suppose you have a set of packages, each with a set of dependencies:</p>
<pre class="rst-literal-block">
    {'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}
</pre>
<p>If you remove one package, which dependencies can also be removed?</p>
<p>If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for ``pkg_2``, and ``D`` is only needed for ``pkg_3``:</p>
<pre class="rst-literal-block">
    &gt;&gt;&gt; unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'})
    [['A'], ['C'], ['D']]
</pre>
<p>If there are duplicates in one input iterable that aren't in the others they will be duplicated in the output. Input order is preserved:</p>
<pre class="rst-literal-block">
    &gt;&gt;&gt; unique_to_each("mississippi", "missouri")
    [['p', 'p'], ['o', 'u', 'r']]
</pre>
<p>It is assumed that the elements of each iterable are hashable.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.unzip">
    
  </a>
  <a name="unzip">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">unzip</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1651">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>The inverse of :func:`zip`, this function disaggregates the elements of the zipped *iterable*.</p>
<p>The ``i``-th iterable contains the ``i``-th element from each element of the zipped iterable. The first element is used to to determine the length of the remaining elements.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [(<span class="py-string">'a'</span>, 1), (<span class="py-string">'b'</span>, 2), (<span class="py-string">'c'</span>, 3), (<span class="py-string">'d'</span>, 4)]
<span class="py-prompt">&gt;&gt;&gt; </span>letters, numbers = unzip(iterable)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(letters)
<span class="py-output">['a', 'b', 'c', 'd']</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(numbers)
<span class="py-output">[1, 2, 3, 4]</span>
</pre><p>This is similar to using ``zip(*iterable)``, but it avoids reading *iterable* into memory. Note, however, that this function uses :func:`itertools.tee` and thus may require significant storage.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.value_chain">
    
  </a>
  <a name="value_chain">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">value_chain</span>(*args):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3675">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield all arguments passed to the function in the same order in which they were passed. If an argument itself is iterable then iterate over its values.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(value_chain(1, 2, 3, [4, 5, 6]))
<span class="py-output">[1, 2, 3, 4, 5, 6]</span>
</pre><p>Binary and text strings are not considered iterable and are emitted as-is:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(value_chain(<span class="py-string">'12'</span>, <span class="py-string">'34'</span>, [<span class="py-string">'56'</span>, <span class="py-string">'78'</span>]))
<span class="py-output">['12', '34', '56', '78']</span>
</pre><p>Multiple levels of nesting are not flattened.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.windowed">
    
  </a>
  <a name="windowed">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">windowed</span>(seq, n, fillvalue=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, step=1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L739">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a sliding window of width *n* over the given iterable.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>all_windows = windowed([1, 2, 3, 4, 5], 3)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(all_windows)
<span class="py-output">[(1, 2, 3), (2, 3, 4), (3, 4, 5)]</span>
</pre><p>When the window is larger than the iterable, *fillvalue* is used in place of missing values:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(windowed([1, 2, 3], 4))
<span class="py-output">[(1, 2, 3, None)]</span>
</pre><p>Each window will advance in increments of *step*:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue=<span class="py-string">'!'</span>, step=2))
<span class="py-output">[(1, 2, 3), (3, 4, 5), (5, 6, '!')]</span>
</pre><p>To slide into the iterable's items, use :func:`chain` to add filler items to the left:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 2, 3, 4]
<span class="py-prompt">&gt;&gt;&gt; </span>n = 3
<span class="py-prompt">&gt;&gt;&gt; </span>padding = [<span class="py-builtin">None</span>] * (n - 1)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(windowed(chain(padding, iterable), 3))
<span class="py-output">[(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.windowed_complete">
    
  </a>
  <a name="windowed_complete">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">windowed_complete</span>(iterable, n):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3523">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield ``(beginning, middle, end)`` tuples, where:</p>
<p>* Each ``middle`` has *n* items from *iterable* * Each ``beginning`` has the items before the ones in ``middle`` * Each ``end`` has the items after the ones in ``middle``</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-builtin">range</span>(7)
<span class="py-prompt">&gt;&gt;&gt; </span>n = 3
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> beginning, middle, end <span class="py-keyword">in</span> windowed_complete(iterable, n):
<span class="py-more">... </span>    <span class="py-builtin">print</span>(beginning, middle, end)
<span class="py-output">() (0, 1, 2) (3, 4, 5, 6)</span>
<span class="py-output">(0,) (1, 2, 3) (4, 5, 6)</span>
<span class="py-output">(0, 1) (2, 3, 4) (5, 6)</span>
<span class="py-output">(0, 1, 2) (3, 4, 5) (6,)</span>
<span class="py-output">(0, 1, 2, 3) (4, 5, 6) ()</span>
</pre><p>Note that *n* must be at least 0 and most equal to the length of *iterable*.</p>
<p>This function will exhaust the iterable and may require significant storage.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.with_iter">
    
  </a>
  <a name="with_iter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">with_iter</span>(context_manager):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L498">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Wrap an iterable in a ``with`` statement, so it closes once exhausted.</p>
<p>For example, this will close the file when the iterator is exhausted:</p>
<pre class="rst-literal-block">
    upper_lines = (line.upper() for line in with_iter(open('foo')))
</pre>
<p>Any context manager which returns an iterable is a candidate for ``with_iter``.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.zip_equal">
    
  </a>
  <a name="zip_equal">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">zip_equal</span>(*iterables):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1500">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>``zip`` the input *iterables* together, but raise ``UnequalIterablesError`` if they aren't all the same length.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>it_1 = <span class="py-builtin">range</span>(3)
<span class="py-prompt">&gt;&gt;&gt; </span>it_2 = <span class="py-builtin">iter</span>(<span class="py-string">'abc'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(zip_equal(it_1, it_2))
<span class="py-output">[(0, 'a'), (1, 'b'), (2, 'c')]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>it_1 = <span class="py-builtin">range</span>(3)
<span class="py-prompt">&gt;&gt;&gt; </span>it_2 = <span class="py-builtin">iter</span>(<span class="py-string">'abcd'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(zip_equal(it_1, it_2)) <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">more_itertools.more.UnequalIterablesError: Iterables have different</span>
<span class="py-except">lengths</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.zip_offset">
    
  </a>
  <a name="zip_offset">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">zip_offset</span>(*iterables, offsets, longest=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>, fillvalue=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1546">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>``zip`` the input *iterables* together, but offset the `i`-th iterable by the `i`-th item in *offsets*.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(zip_offset(<span class="py-string">'0123'</span>, <span class="py-string">'abcdef'</span>, offsets=(0, 1)))
<span class="py-output">[('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]</span>
</pre><p>This can be used as a lightweight alternative to SciPy or pandas to analyze data sets in which some series have a lead or lag relationship.</p>
<p>By default, the sequence will end when the shortest iterable is exhausted. To continue until the longest iterable is exhausted, set *longest* to ``True``.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(zip_offset(<span class="py-string">'0123'</span>, <span class="py-string">'abcdef'</span>, offsets=(0, 1), longest=<span class="py-builtin">True</span>))
<span class="py-output">[('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]</span>
</pre><p>By default, ``None`` will be used to replace offsets beyond the end of the sequence. Specify *fillvalue* to use some other value.</p>
</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="setuptools._vendor.more_itertools.more._islice_helper">
    
  </a>
  <a name="_islice_helper">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_islice_helper</span>(it, s):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L2313">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="setuptools._vendor.more_itertools.more._sample_unweighted">
    
  </a>
  <a name="_sample_unweighted">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_sample_unweighted</span>(iterable, k):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3279">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="setuptools._vendor.more_itertools.more._sample_weighted">
    
  </a>
  <a name="_sample_weighted">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_sample_weighted</span>(iterable, k, weights):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L3305">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="setuptools._vendor.more_itertools.more._zip_equal_generator">
    
  </a>
  <a name="_zip_equal_generator">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_zip_equal_generator</span>(iterables):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L1492">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basevariable private">
  
  
  <a name="setuptools._vendor.more_itertools.more._marker">
    
  </a>
  <a name="_marker">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_marker</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-62.1.0//setuptools/_vendor/more_itertools/more.py#L123">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div>
        </div>
      
      </div>
    </div>

    <footer class="navbar navbar-default">

  
  <div class="container">
    <a href="index.html">API Documentation</a> for setuptools,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.4.0.dev0 at 2022-04-11 16:12:39.
  </div>

  <!-- Search related scripts needs to be loaded at the end of HTML 
    parsing not to introduce overhead and display HTML data asap -->
  <script src="ajax.js" type="text/javascript"></script>
  <script src="searchlib.js" type="text/javascript"></script>
  <script src="search.js" type="text/javascript"></script>

</footer>
  
    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>