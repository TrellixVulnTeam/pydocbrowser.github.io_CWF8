<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.databases.oracle</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.databases.html" class="internal-link" title="sqlalchemy.databases">databases</a></code><wbr></wbr>.<code><a href="sqlalchemy.databases.oracle.html" class="internal-link" title="sqlalchemy.databases.oracle">oracle</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><div class="rst-section" id="rst-auto-increment-behavior">
<h2 class="heading">Auto Increment Behavior</h2>
<p>SQLAlchemy Table objects which include integer primary keys are usually
assumed to have "autoincrementing" behavior, meaning they can generate their
own primary key values upon INSERT. For use within Oracle, two options are
available, which are the use of IDENTITY columns (Oracle 12 and above only)
or the association of a SEQUENCE with the column.</p>
<div class="rst-section" id="rst-specifying-generated-as-identity-oracle-12-and-above">
<h3 class="heading">Specifying GENERATED AS IDENTITY (Oracle 12 and above)</h3>
<p>Starting from version 12 Oracle can make use of identity columns using
the <code>_sql.Identity</code> to specify the autoincrementing behavior:</p>
<pre class="rst-literal-block">
t = Table('mytable', metadata,
    Column('id', Integer, Identity(start=3), primary_key=True),
    Column(...), ...
)
</pre>
<p>The CREATE TABLE for the above <code>_schema.Table</code> object would be:</p>
<pre class="rst-code rst-sql rst-literal-block">
CREATE TABLE mytable (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 3),
    ...,
    PRIMARY KEY (id)
)
</pre>
<p>The <code>_schema.Identity</code> object support many options to control the
"autoincrementing" behavior of the column, like the starting value, the
incrementing value, etc.
In addition to the standard options, Oracle supports setting
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`_schema.Identity.always`</span></a> to <tt class="rst-docutils literal">None</tt> to use the default
generated mode, rendering GENERATED AS IDENTITY in the DDL. It also supports
setting <a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`_schema.Identity.on_null`</span></a> to <tt class="rst-docutils literal">True</tt> to specify ON NULL
in conjunction with a 'BY DEFAULT' identity column.</p>
</div>
<div class="rst-section" id="rst-using-a-sequence-all-oracle-versions">
<h3 class="heading">Using a SEQUENCE (all Oracle versions)</h3>
<p>Older version of Oracle had no "autoincrement"
feature, SQLAlchemy relies upon sequences to produce these values.   With the
older Oracle versions, <em>a sequence must always be explicitly specified to
enable autoincrement</em>.  This is divergent with the majority of documentation
examples which assume the usage of an autoincrement-capable database.   To
specify sequences, use the sqlalchemy.schema.Sequence object which is passed
to a Column construct:</p>
<pre class="rst-literal-block">
t = Table('mytable', metadata,
      Column('id', Integer, Sequence('id_seq'), primary_key=True),
      Column(...), ...
)
</pre>
<p>This step is also required when using table reflection, i.e. autoload_with=engine:</p>
<pre class="rst-literal-block">
t = Table('mytable', metadata,
      Column('id', Integer, Sequence('id_seq'), primary_key=True),
      autoload_with=engine
)
</pre>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>Added <code>_schema.Identity</code> construct
in a <code>_schema.Column</code> to specify the option of an autoincrementing
column.</span></div>
</div>
</div>
<div class="rst-section" id="rst-transaction-isolation-level-autocommit">
<span id="rst-oracle-isolation-level"></span><h2 class="heading">Transaction Isolation Level / Autocommit</h2>
<p>The Oracle database supports "READ COMMITTED" and "SERIALIZABLE" modes of
isolation. The AUTOCOMMIT isolation level is also supported by the cx_Oracle
dialect.</p>
<p>To set using per-connection execution options:</p>
<pre class="rst-literal-block">
connection = engine.connect()
connection = connection.execution_options(
    isolation_level="AUTOCOMMIT"
)
</pre>
<p>For <tt class="rst-docutils literal">READ COMMITTED</tt> and <tt class="rst-docutils literal">SERIALIZABLE</tt>, the Oracle dialect sets the
level at the session level using <tt class="rst-docutils literal">ALTER SESSION</tt>, which is reverted back
to its default setting when the connection is returned to the connection
pool.</p>
<p>Valid values for <tt class="rst-docutils literal">isolation_level</tt> include:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">READ COMMITTED</tt></li>
<li><tt class="rst-docutils literal">AUTOCOMMIT</tt></li>
<li><tt class="rst-docutils literal">SERIALIZABLE</tt></li>
</ul>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p>The implementation for the
<code>_engine.Connection.get_isolation_level</code> method as implemented by the
Oracle dialect necessarily forces the start of a transaction using the
Oracle LOCAL_TRANSACTION_ID function; otherwise no level is normally
readable.</p>
<p>Additionally, the <code>_engine.Connection.get_isolation_level</code> method will
raise an exception if the <tt class="rst-docutils literal">v$transaction</tt> view is not available due to
permissions or other reasons, which is a common occurrence in Oracle
installations.</p>
<p class="rst-last">The cx_Oracle dialect attempts to call the
<code>_engine.Connection.get_isolation_level</code> method when the dialect makes
its first connection to the database in order to acquire the
"default"isolation level.  This default level is necessary so that the level
can be reset on a connection after it has been temporarily modified using
<code>_engine.Connection.execution_options</code> method.   In the common event
that the <code>_engine.Connection.get_isolation_level</code> method raises an
exception due to <tt class="rst-docutils literal">v$transaction</tt> not being readable as well as any other
database-related failure, the level is assumed to be "READ COMMITTED".  No
warning is emitted for this initial first-connect condition as it is
expected to be a common restriction on Oracle databases.</p>
</div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.3.16: </span><span>added support for AUTOCOMMIT to the cx_oracle dialect
as well as the notion of a default isolation level</span></div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.3.21: </span><span>Added support for SERIALIZABLE as well as live
reading of the isolation level.</span></div>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.3.22: </span><span>In the event that the default isolation
level cannot be read due to permissions on the v$transaction view as
is common in Oracle installations, the default isolation level is hardcoded
to "READ COMMITTED" which was the behavior prior to 1.3.21.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:ref:`dbapi_autocommit`</span></a></p>
</div>
</div>
<div class="rst-section" id="rst-identifier-casing">
<h2 class="heading">Identifier Casing</h2>
<p>In Oracle, the data dictionary represents all case insensitive identifier
names using UPPERCASE text.   SQLAlchemy on the other hand considers an
all-lower case identifier name to be case insensitive.   The Oracle dialect
converts all case insensitive identifiers to and from those two formats during
schema level communication, such as reflection of tables and indexes.   Using
an UPPERCASE name on the SQLAlchemy side indicates a case sensitive
identifier, and SQLAlchemy will quote the name - this will cause mismatches
against data dictionary data received from Oracle, so unless identifier names
have been truly created as case sensitive (i.e. using quoted names), all
lowercase names should be used on the SQLAlchemy side.</p>
</div>
<div class="rst-section" id="rst-max-identifier-lengths">
<span id="rst-oracle-max-identifier-lengths"></span><h2 class="heading">Max Identifier Lengths</h2>
<p>Oracle has changed the default max identifier length as of Oracle Server
version 12.2.   Prior to this version, the length was 30, and for 12.2 and
greater it is now 128.   This change impacts SQLAlchemy in the area of
generated SQL label names as well as the generation of constraint names,
particularly in the case where the constraint naming convention feature
described at <a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:ref:`constraint_naming_conventions`</span></a> is being used.</p>
<p>To assist with this change and others, Oracle includes the concept of a
"compatibility" version, which is a version number that is independent of the
actual server version in order to assist with migration of Oracle databases,
and may be configured within the Oracle server itself. This compatibility
version is retrieved using the query  <tt class="rst-docutils literal">SELECT value FROM v$parameter WHERE
name = 'compatible';</tt>.   The SQLAlchemy Oracle dialect, when tasked with
determining the default max identifier length, will attempt to use this query
upon first connect in order to determine the effective compatibility version of
the server, which determines what the maximum allowed identifier length is for
the server.  If the table is not available, the  server version information is
used instead.</p>
<p>As of SQLAlchemy 1.4, the default max identifier length for the Oracle dialect
is 128 characters.  Upon first connect, the compatibility version is detected
and if it is less than Oracle version 12.2, the max identifier length is
changed to be 30 characters.  In all cases, setting the
<a href="#system-message-5"><span class="rst-problematic" id="rst-problematic-5">:paramref:`_sa.create_engine.max_identifier_length`</span></a> parameter will bypass this
change and the value given will be used as is:</p>
<pre class="rst-literal-block">
engine = create_engine(
    "oracle+cx_oracle://scott:tiger@oracle122",
    max_identifier_length=30)
</pre>
<p>The maximum identifier length comes into play both when generating anonymized
SQL labels in SELECT statements, but more crucially when generating constraint
names from a naming convention.  It is this area that has created the need for
SQLAlchemy to change this default conservatively.   For example, the following
naming convention produces two very different constraint names based on the
identifier length:</p>
<pre class="rst-literal-block">
from sqlalchemy import Column
from sqlalchemy import Index
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import Table
from sqlalchemy.dialects import oracle
from sqlalchemy.schema import CreateIndex

m = MetaData(naming_convention={"ix": "ix_%(column_0N_name)s"})

t = Table(
    "t",
    m,
    Column("some_column_name_1", Integer),
    Column("some_column_name_2", Integer),
    Column("some_column_name_3", Integer),
)

ix = Index(
    None,
    t.c.some_column_name_1,
    t.c.some_column_name_2,
    t.c.some_column_name_3,
)

oracle_dialect = oracle.dialect(max_identifier_length=30)
print(CreateIndex(ix).compile(dialect=oracle_dialect))
</pre>
<p>With an identifier length of 30, the above CREATE INDEX looks like:</p>
<pre class="rst-literal-block">
CREATE INDEX ix_some_column_name_1s_70cd ON t
(some_column_name_1, some_column_name_2, some_column_name_3)
</pre>
<p>However with length=128, it becomes:</p>
<pre class="rst-literal-block">
CREATE INDEX ix_some_column_name_1some_column_name_2some_column_name_3 ON t
(some_column_name_1, some_column_name_2, some_column_name_3)
</pre>
<p>Applications which have run versions of SQLAlchemy prior to 1.4 on an  Oracle
server version 12.2 or greater are therefore subject to the scenario of a
database migration that wishes to "DROP CONSTRAINT" on a name that was
previously generated with the shorter length.  This migration will fail when
the identifier length is changed without the name of the index or constraint
first being adjusted.  Such applications are strongly advised to make use of
<a href="#system-message-6"><span class="rst-problematic" id="rst-problematic-6">:paramref:`_sa.create_engine.max_identifier_length`</span></a>
in order to maintain control
of the generation of truncated names, and to fully review and test all database
migrations in a staging environment when changing this value to ensure that the
impact of this change has been mitigated.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>the default max_identifier_length for Oracle is 128
characters, which is adjusted down to 30 upon first connect if an older
version of Oracle server (compatibility version &lt; 12.2) is detected.</span></div>
</div>
<div class="rst-section" id="rst-limit-offset-support">
<h2 class="heading">LIMIT/OFFSET Support</h2>
<p>Oracle has no direct support for LIMIT and OFFSET until version 12c.
To achieve this behavior across all widely used versions of Oracle starting
with the 8 series, SQLAlchemy currently makes use of ROWNUM to achieve
LIMIT/OFFSET; the exact methodology is taken from
<a class="rst-reference external" href="https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results" target="_top">https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results</a> .</p>
<p>There is currently a single option to affect its behavior:</p>
<ul class="rst-simple">
<li>the "FIRST_ROWS()" optimization keyword is not used by default.  To enable
the usage of this optimization directive, specify <tt class="rst-docutils literal">optimize_limits=True</tt>
to <code>_sa.create_engine</code>.</li>
</ul>
<div class="rst-versionchanged">
<p><span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>The Oracle dialect renders limit/offset integer values using a "post
compile" scheme which renders the integer directly before passing the
statement to the cursor for execution.   The <tt class="rst-docutils literal">use_binds_for_limits</tt> flag
no longer has an effect.</span></p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-7"><span class="rst-problematic" id="rst-problematic-7">:ref:`change_4808`</span></a>.</p>
</div>
</div>
<p>Support for changing the row number strategy, which would include one that
makes use of the <tt class="rst-docutils literal">row_number()</tt> window function as well as one that makes
use of the Oracle 12c  "FETCH FIRST N ROW / OFFSET N ROWS" keywords may be
added in a future release.</p>
</div>
<div class="rst-section" id="rst-returning-support">
<span id="rst-oracle-returning"></span><h2 class="heading">RETURNING Support</h2>
<p>The Oracle database supports a limited form of RETURNING, in order to retrieve
result sets of matched rows from INSERT, UPDATE and DELETE statements.
Oracle's RETURNING..INTO syntax only supports one row being returned, as it
relies upon OUT parameters in order to function.  In addition, supported
DBAPIs have further limitations (see <a href="#system-message-8"><span class="rst-problematic" id="rst-problematic-8">:ref:`cx_oracle_returning`</span></a>).</p>
<p>SQLAlchemy's "implicit returning" feature, which employs RETURNING within an
INSERT and sometimes an UPDATE statement in order to fetch newly generated
primary key values and other SQL defaults and expressions, is normally enabled
on the Oracle backend.  By default, "implicit returning" typically only
fetches the value of a single <tt class="rst-docutils literal">nextval(some_seq)</tt> expression embedded into
an INSERT in order to increment a sequence within an INSERT statement and get
the value back at the same time. To disable this feature across the board,
specify <tt class="rst-docutils literal">implicit_returning=False</tt> to <code>_sa.create_engine</code>:</p>
<pre class="rst-literal-block">
engine = create_engine("oracle://scott:tiger@dsn",
                       implicit_returning=False)
</pre>
<p>Implicit returning can also be disabled on a table-by-table basis as a table
option:</p>
<pre class="rst-literal-block">
# Core Table
my_table = Table("my_table", metadata, ..., implicit_returning=False)


# declarative
class MyClass(Base):
    __tablename__ = 'my_table'
    __table_args__ = {"implicit_returning": False}
</pre>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-9"><span class="rst-problematic" id="rst-problematic-9">:ref:`cx_oracle_returning`</span></a> - additional cx_oracle-specific restrictions on
implicit returning.</p>
</div>
</div>
<div class="rst-section" id="rst-on-update-cascade">
<h2 class="heading">ON UPDATE CASCADE</h2>
<p>Oracle doesn't have native ON UPDATE CASCADE functionality.  A trigger based
solution is available at
<a class="rst-reference external" href="https://asktom.oracle.com/tkyte/update_cascade/index.html" target="_top">https://asktom.oracle.com/tkyte/update_cascade/index.html</a> .</p>
<p>When using the SQLAlchemy ORM, the ORM has limited ability to manually issue
cascading updates - specify ForeignKey objects using the
"deferrable=True, initially='deferred'" keyword arguments,
and specify "passive_updates=False" on each relationship().</p>
</div>
<div class="rst-section" id="rst-oracle-8-compatibility">
<h2 class="heading">Oracle 8 Compatibility</h2>
<p>When Oracle 8 is detected, the dialect internally configures itself to the
following behaviors:</p>
<ul class="rst-simple">
<li>the use_ansi flag is set to False.  This has the effect of converting all
JOIN phrases into the WHERE clause, and in the case of LEFT OUTER JOIN
makes use of Oracle's (+) operator.</li>
<li>the NVARCHAR2 and NCLOB datatypes are no longer generated as DDL when
the <code>~sqlalchemy.types.Unicode</code> is used - VARCHAR2 and CLOB are
issued instead.   This because these types don't seem to work correctly on
Oracle 8 even though they are available.  The
<code>~sqlalchemy.types.NVARCHAR</code> and
<code>~sqlalchemy.dialects.oracle.NCLOB</code> types will always generate
NVARCHAR2 and NCLOB.</li>
<li>the "native unicode" mode is disabled when using cx_oracle, i.e. SQLAlchemy
encodes all Python unicode objects to "string" before passing in as bind
parameters.</li>
</ul>
</div>
<div class="rst-section" id="rst-synonym-dblink-reflection">
<h2 class="heading">Synonym/DBLINK Reflection</h2>
<p>When using reflection with Table objects, the dialect can optionally search
for tables indicated by synonyms, either in local or remote schemas or
accessed over DBLINK, by passing the flag <tt class="rst-docutils literal">oracle_resolve_synonyms=True</tt> as
a keyword argument to the <code>_schema.Table</code> construct:</p>
<pre class="rst-literal-block">
some_table = Table('some_table', autoload_with=some_engine,
                            oracle_resolve_synonyms=True)
</pre>
<p>When this flag is set, the given name (such as <tt class="rst-docutils literal">some_table</tt> above) will
be searched not just in the <tt class="rst-docutils literal">ALL_TABLES</tt> view, but also within the
<tt class="rst-docutils literal">ALL_SYNONYMS</tt> view to see if this name is actually a synonym to another
name.  If the synonym is located and refers to a DBLINK, the oracle dialect
knows how to locate the table's information using DBLINK syntax(e.g.
<tt class="rst-docutils literal">@dblink</tt>).</p>
<p><tt class="rst-docutils literal">oracle_resolve_synonyms</tt> is accepted wherever reflection arguments are
accepted, including methods such as <code>_schema.MetaData.reflect</code> and
<code>_reflection.Inspector.get_columns</code>.</p>
<p>If synonyms are not in use, this flag should be left disabled.</p>
</div>
<div class="rst-section" id="rst-constraint-reflection">
<span id="rst-oracle-constraint-reflection"></span><h2 class="heading">Constraint Reflection</h2>
<p>The Oracle dialect can return information about foreign key, unique, and
CHECK constraints, as well as indexes on tables.</p>
<p>Raw information regarding these constraints can be acquired using
<code>_reflection.Inspector.get_foreign_keys</code>,
<code>_reflection.Inspector.get_unique_constraints</code>,
<code>_reflection.Inspector.get_check_constraints</code>, and
<code>_reflection.Inspector.get_indexes</code>.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.2: </span><span>The Oracle dialect can now reflect UNIQUE and
CHECK constraints.</span></div>
<p>When using reflection at the <code>_schema.Table</code> level, the
<code>_schema.Table</code>
will also include these constraints.</p>
<p>Note the following caveats:</p>
<ul>
<li><p class="rst-first">When using the <code>_reflection.Inspector.get_check_constraints</code> method,
Oracle
builds a special "IS NOT NULL" constraint for columns that specify
"NOT NULL".  This constraint is <strong>not</strong> returned by default; to include
the "IS NOT NULL" constraints, pass the flag <tt class="rst-docutils literal">include_all=True</tt>:</p>
<pre class="rst-literal-block">
from sqlalchemy import create_engine, inspect

engine = create_engine("oracle+cx_oracle://s:t@dsn")
inspector = inspect(engine)
all_check_constraints = inspector.get_check_constraints(
    "some_table", include_all=True)
</pre>
</li>
<li><p class="rst-first">in most cases, when reflecting a <code>_schema.Table</code>,
a UNIQUE constraint will
<strong>not</strong> be available as a <code>.UniqueConstraint</code> object, as Oracle
mirrors unique constraints with a UNIQUE index in most cases (the exception
seems to be when two or more unique constraints represent the same columns);
the <code>_schema.Table</code> will instead represent these using
<code>.Index</code>
with the <tt class="rst-docutils literal">unique=True</tt> flag set.</p>
</li>
<li><p class="rst-first">Oracle creates an implicit index for the primary key of a table; this index
is <strong>excluded</strong> from all index results.</p>
</li>
<li><p class="rst-first">the list of columns reflected for an index will not include column names
that start with SYS_NC.</p>
</li>
</ul>
</div>
<div class="rst-section" id="rst-table-names-with-system-sysaux-tablespaces">
<h2 class="heading">Table names with SYSTEM/SYSAUX tablespaces</h2>
<p>The <code>_reflection.Inspector.get_table_names</code> and
<code>_reflection.Inspector.get_temp_table_names</code>
methods each return a list of table names for the current engine. These methods
are also part of the reflection which occurs within an operation such as
<code>_schema.MetaData.reflect</code>.  By default,
these operations exclude the <tt class="rst-docutils literal">SYSTEM</tt>
and <tt class="rst-docutils literal">SYSAUX</tt> tablespaces from the operation.   In order to change this, the
default list of tablespaces excluded can be changed at the engine level using
the <tt class="rst-docutils literal">exclude_tablespaces</tt> parameter:</p>
<pre class="rst-literal-block">
# exclude SYSAUX and SOME_TABLESPACE, but not SYSTEM
e = create_engine(
  "oracle://scott:tiger@xe",
  exclude_tablespaces=["SYSAUX", "SOME_TABLESPACE"])
</pre>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.1.</span></div>
</div>
<div class="rst-section" id="rst-datetime-compatibility">
<h2 class="heading">DateTime Compatibility</h2>
<p>Oracle has no datatype known as <tt class="rst-docutils literal">DATETIME</tt>, it instead has only <tt class="rst-docutils literal">DATE</tt>,
which can actually store a date and time value.  For this reason, the Oracle
dialect provides a type <code>_oracle.DATE</code> which is a subclass of
<code>.DateTime</code>.   This type has no special behavior, and is only
present as a "marker" for this type; additionally, when a database column
is reflected and the type is reported as <tt class="rst-docutils literal">DATE</tt>, the time-supporting
<code>_oracle.DATE</code> type is used.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 0.9.4: </span><span>Added <code>_oracle.DATE</code> to subclass
<code>.DateTime</code>.  This is a change as previous versions
would reflect a <tt class="rst-docutils literal">DATE</tt> column as <code>_types.DATE</code>, which subclasses
<code>.Date</code>.   The only significance here is for schemes that are
examining the type of column for use in special Python translations or
for migrating schemas to other database backends.</span></div>
</div>
<div class="rst-section" id="rst-oracle-table-options-1">
<span id="rst-oracle-table-options"></span><h2 class="heading">Oracle Table Options</h2>
<p>The CREATE TABLE phrase supports the following options with Oracle
in conjunction with the <code>_schema.Table</code> construct:</p>
<ul>
<li><p class="rst-first"><tt class="rst-docutils literal">ON COMMIT</tt>:</p>
<pre class="rst-literal-block">
Table(
    "some_table", metadata, ...,
    prefixes=['GLOBAL TEMPORARY'], oracle_on_commit='PRESERVE ROWS')
</pre>
</li>
</ul>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.0.0.</span></div>
<ul>
<li><p class="rst-first"><tt class="rst-docutils literal">COMPRESS</tt>:</p>
<pre class="rst-literal-block">
 Table('mytable', metadata, Column('data', String(32)),
     oracle_compress=True)

 Table('mytable', metadata, Column('data', String(32)),
     oracle_compress=6)

The ``oracle_compress`` parameter accepts either an integer compression
level, or ``True`` to use the default compression level.
</pre>
</li>
</ul>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.0.0.</span></div>
</div>
<div class="rst-section" id="rst-oracle-specific-index-options">
<span id="rst-oracle-index-options"></span><h2 class="heading">Oracle Specific Index Options</h2>
<div class="rst-section" id="rst-bitmap-indexes">
<h3 class="heading">Bitmap Indexes</h3>
<p>You can specify the <tt class="rst-docutils literal">oracle_bitmap</tt> parameter to create a bitmap index
instead of a B-tree index:</p>
<pre class="rst-literal-block">
Index('my_index', my_table.c.data, oracle_bitmap=True)
</pre>
<p>Bitmap indexes cannot be unique and cannot be compressed. SQLAlchemy will not
check for such limitations, only the database will.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.0.0.</span></div>
</div>
<div class="rst-section" id="rst-index-compression">
<h3 class="heading">Index compression</h3>
<p>Oracle has a more efficient storage mode for indexes containing lots of
repeated values. Use the <tt class="rst-docutils literal">oracle_compress</tt> parameter to turn on key
compression:</p>
<pre class="rst-literal-block">
Index('my_index', my_table.c.data, oracle_compress=True)

Index('my_index', my_table.c.data1, my_table.c.data2, unique=True,
       oracle_compress=1)
</pre>
<p>The <tt class="rst-docutils literal">oracle_compress</tt> parameter accepts either an integer specifying the
number of prefix columns to compress, or <tt class="rst-docutils literal">True</tt> to use the default (all
columns for non-unique indexes, all but the last column for unique indexes).</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.0.0.</span></div>
</div>
</div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id14266">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.oracle.OracleCompiler.html" class="internal-link" title="sqlalchemy.databases.oracle.OracleCompiler">​Oracle​Compiler</a></code></td>
    <td>Oracle compiler modifies the lexical structure of Select statements to work under non-ANSI configured Oracle databases, if the use_ansi flag is False.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.oracle.OracleDDLCompiler.html" class="internal-link" title="sqlalchemy.databases.oracle.OracleDDLCompiler">​Oracle​DDLCompiler</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.oracle.OracleDialect.html" class="internal-link" title="sqlalchemy.databases.oracle.OracleDialect">​Oracle​Dialect</a></code></td>
    <td><span class="undocumented">No class docstring; 0/5 property, 0/7 instance variable, 0/20 class variable, 3/30 methods documented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.oracle.OracleExecutionContext.html" class="internal-link" title="sqlalchemy.databases.oracle.OracleExecutionContext">​Oracle​Execution​Context</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.oracle.OracleIdentifierPreparer.html" class="internal-link" title="sqlalchemy.databases.oracle.OracleIdentifierPreparer">​Oracle​Identifier​Preparer</a></code></td>
    <td><span class="undocumented">No class docstring; 0/2 class variable, 1/2 method documented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.oracle.OracleTypeCompiler.html" class="internal-link" title="sqlalchemy.databases.oracle.OracleTypeCompiler">​Oracle​Type​Compiler</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#NO_ARG_FNS" class="internal-link" title="sqlalchemy.databases.oracle.NO_ARG_FNS">NO​_ARG​_FNS</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant">
    
    <td>Constant</td>
    <td><code><a href="#RESERVED_WORDS" class="internal-link" title="sqlalchemy.databases.oracle.RESERVED_WORDS">RESERVED​_WORDS</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><code><a href="#colspecs" class="internal-link" title="sqlalchemy.databases.oracle.colspecs">colspecs</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><code><a href="#ischema_names" class="internal-link" title="sqlalchemy.databases.oracle.ischema_names">ischema​_names</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.oracle._OracleBoolean.html" class="internal-link" title="sqlalchemy.databases.oracle._OracleBoolean">_​Oracle​Boolean</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.databases.oracle._OuterJoinColumn.html" class="internal-link" title="sqlalchemy.databases.oracle._OuterJoinColumn">_​Outer​Join​Column</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.oracle.NO_ARG_FNS">
    
  </a>
  <a name="NO_ARG_FNS">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">NO_ARG_FNS</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>set(<wbr></wbr>"""UID CURRENT_DATE SYSDATE USER CURRENT_TIME CURRENT_TIMESTAMP""".split())</code></pre></td></tr></table>
  </div>
</div><div class="baseconstant">
  
  
  <a name="sqlalchemy.databases.oracle.RESERVED_WORDS">
    
  </a>
  <a name="RESERVED_WORDS">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">RESERVED_WORDS</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>set(<wbr></wbr>"""SHARE RAW DROP BETWEEN FROM DESC OPTION PRIOR LONG THEN DEFAULT ALTER IS <span class="rst-variable-linewrap">↵</span>
INTO MINUS INTEGER NUMBER GRANT IDENTIFIED ALL TO ORDER ON FLOAT DATE HAVING CLU<span class="rst-variable-linewrap">↵</span>
STER NOWAIT RESOURCE ANY TABLE INDEX FOR UPDATE WHERE CHECK SMALLINT WITH DELETE<span class="rst-variable-linewrap">↵</span>
 BY ASC REVOKE LIKE SIZE RENAME NOCOMPRESS NULL GROUP VALUES AS IN VIEW EXCLUSIV<span class="rst-variable-linewrap">↵</span>
E COMPRESS SYNONYM SELECT INSERT EXISTS NOT TRIGGER ELSE CREATE INTERSECT PCTFRE<span class="rst-variable-linewrap">↵</span>
E DISTINCT USER CONNECT SET MODE OF UNIQUE VARCHAR2 VARCHAR LOCK OR CHAR DECIMAL<span class="rst-variable-linewrap">↵</span>
 UNION PUBLIC AND START UID COMMENT CURRENT LEVEL""".split())</code></pre></td></tr></table>
  </div>
</div><div class="basevariable">
  
  
  <a name="sqlalchemy.databases.oracle.colspecs">
    
  </a>
  <a name="colspecs">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">colspecs</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="basevariable">
  
  
  <a name="sqlalchemy.databases.oracle.ischema_names">
    
  </a>
  <a name="ischema_names">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">ischema_names</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 04:41:59.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>