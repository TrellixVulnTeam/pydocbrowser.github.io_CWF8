<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.dialects.oracle.cx_oracle</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    <div id="banner" class="container">    
    <div>
        <a href="https://pydocbrowser.github.io/">Home</a>
        &gt; sqlalchemy-1.4.31 
        <!-- This is an important placeholder and will be 
            replaced by project name and version on building docs -->
        
        <!-- (<a href=""&gt;show all versions</a&gt;) -->
    </div>
</div>

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.dialects.html" class="internal-link" title="sqlalchemy.dialects">dialects</a></code><wbr></wbr>.<code><a href="sqlalchemy.dialects.oracle.html" class="internal-link" title="sqlalchemy.dialects.oracle">oracle</a></code><wbr></wbr>.<code><a href="sqlalchemy.dialects.oracle.cx_oracle.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle">cx_oracle</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        <a href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-1.4.31//lib/sqlalchemy/dialects/oracle/cx_oracle.py" class="sourceLink">(source)</a>
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><div class="rst-section" id="rst-dsn-vs-hostname-connections">
<h2 class="heading">DSN vs. Hostname connections</h2>
<p>cx_Oracle provides several methods of indicating the target database.  The
dialect translates from a series of different URL forms.</p>
<div class="rst-section" id="rst-hostname-connections-with-easy-connect-syntax">
<h3 class="heading">Hostname Connections with Easy Connect Syntax</h3>
<p>Given a hostname, port and service name of the target Oracle Database, for
example from Oracle's <a class="rst-reference external" href="https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#easy-connect-syntax-for-connection-strings" target="_top">Easy Connect syntax</a>,
then connect in SQLAlchemy using the <tt class="rst-docutils literal">service_name</tt> query string parameter:</p>
<pre class="rst-literal-block">
engine = create_engine("oracle+cx_oracle://scott:tiger@hostname:port/?service_name=myservice&amp;encoding=UTF-8&amp;nencoding=UTF-8")
</pre>
<p>The <a class="rst-reference external" href="https://www.oracle.com/pls/topic/lookup?ctx=dblatest&amp;id=GUID-B0437826-43C1-49EC-A94D-B650B6A4A6EE" target="_top">full Easy Connect syntax</a>
is not supported.  Instead, use a <tt class="rst-docutils literal">tnsnames.ora</tt> file and connect using a
DSN.</p>
</div>
<div class="rst-section" id="rst-connections-with-tnsnames-ora-or-oracle-cloud">
<h3 class="heading">Connections with tnsnames.ora or Oracle Cloud</h3>
<p>Alternatively, if no port, database name, or <tt class="rst-docutils literal">service_name</tt> is provided, the
dialect will use an Oracle DSN "connection string".  This takes the "hostname"
portion of the URL as the data source name.  For example, if the
<tt class="rst-docutils literal">tnsnames.ora</tt> file contains a <a class="rst-reference external" href="https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#net-service-names-for-connection-strings" target="_top">Net Service Name</a>
of <tt class="rst-docutils literal">myalias</tt> as below:</p>
<pre class="rst-literal-block">
myalias =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = mymachine.example.com)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orclpdb1)
    )
  )
</pre>
<p>The cx_Oracle dialect connects to this database service when <tt class="rst-docutils literal">myalias</tt> is the
hostname portion of the URL, without specifying a port, database name or
<tt class="rst-docutils literal">service_name</tt>:</p>
<pre class="rst-literal-block">
engine = create_engine("oracle+cx_oracle://scott:tiger@myalias/?encoding=UTF-8&amp;nencoding=UTF-8")
</pre>
<p>Users of Oracle Cloud should use this syntax and also configure the cloud
wallet as shown in cx_Oracle documentation <a class="rst-reference external" href="https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#connecting-to-autononmous-databases" target="_top">Connecting to Autononmous Databases</a>.</p>
</div>
<div class="rst-section" id="rst-sid-connections">
<h3 class="heading">SID Connections</h3>
<p>To use Oracle's obsolete SID connection syntax, the SID can be passed in a
"database name" portion of the URL as below:</p>
<pre class="rst-literal-block">
engine = create_engine("oracle+cx_oracle://scott:tiger@hostname:1521/dbname?encoding=UTF-8&amp;nencoding=UTF-8")
</pre>
<p>Above, the DSN passed to cx_Oracle is created by <tt class="rst-docutils literal">cx_Oracle.makedsn()</tt> as
follows:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; import cx_Oracle
&gt;&gt;&gt; cx_Oracle.makedsn("hostname", 1521, sid="dbname")
'(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=hostname)(PORT=1521))(CONNECT_DATA=(SID=dbname)))'
</pre>
</div>
</div>
<div class="rst-section" id="rst-passing-cx-oracle-connect-arguments">
<h2 class="heading">Passing cx_Oracle connect arguments</h2>
<p>Additional connection arguments can usually be passed via the URL
query string; particular symbols like <tt class="rst-docutils literal">cx_Oracle.SYSDBA</tt> are intercepted
and converted to the correct symbol:</p>
<pre class="rst-literal-block">
e = create_engine(
    "oracle+cx_oracle://user:pass@dsn?encoding=UTF-8&amp;nencoding=UTF-8&amp;mode=SYSDBA&amp;events=true")
</pre>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.3: </span><span>the cx_oracle dialect now accepts all argument names
within the URL string itself, to be passed to the cx_Oracle DBAPI.   As
was the case earlier but not correctly documented, the
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`_sa.create_engine.connect_args`</span></a> parameter also accepts all
cx_Oracle DBAPI connect arguments.</span></div>
<p>To pass arguments directly to <tt class="rst-docutils literal">.connect()</tt> without using the query
string, use the <a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`_sa.create_engine.connect_args`</span></a> dictionary.
Any cx_Oracle parameter value and/or constant may be passed, such as:</p>
<pre class="rst-literal-block">
import cx_Oracle
e = create_engine(
    "oracle+cx_oracle://user:pass@dsn",
    connect_args={
        "encoding": "UTF-8",
        "nencoding": "UTF-8",
        "mode": cx_Oracle.SYSDBA,
        "events": True
    }
)
</pre>
<p>Note that the default value for <tt class="rst-docutils literal">encoding</tt> and <tt class="rst-docutils literal">nencoding</tt> was changed to
"UTF-8" in cx_Oracle 8.0 so these parameters can be omitted when using that
version, or later.</p>
</div>
<div class="rst-section" id="rst-options-consumed-by-the-sqlalchemy-cx-oracle-dialect-outside-of-the-driver">
<h2 class="heading">Options consumed by the SQLAlchemy cx_Oracle dialect outside of the driver</h2>
<p>There are also options that are consumed by the SQLAlchemy cx_oracle dialect
itself.  These options are always passed directly to <code>_sa.create_engine</code>
, such as:</p>
<pre class="rst-literal-block">
e = create_engine(
    "oracle+cx_oracle://user:pass@dsn", coerce_to_unicode=False)
</pre>
<p>The parameters accepted by the cx_oracle dialect are as follows:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">arraysize</tt> - set the cx_oracle.arraysize value on cursors, defaulted
to 50.  This setting is significant with cx_Oracle as the contents of LOB
objects are only readable within a "live" row (e.g. within a batch of
50 rows).</li>
<li><tt class="rst-docutils literal">auto_convert_lobs</tt> - defaults to True; See <a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:ref:`cx_oracle_lob`</span></a>.</li>
<li><tt class="rst-docutils literal">coerce_to_unicode</tt> - see <a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:ref:`cx_oracle_unicode`</span></a> for detail.</li>
<li><tt class="rst-docutils literal">coerce_to_decimal</tt> - see <a href="#system-message-5"><span class="rst-problematic" id="rst-problematic-5">:ref:`cx_oracle_numeric`</span></a> for detail.</li>
<li><tt class="rst-docutils literal">encoding_errors</tt> - see <a href="#system-message-6"><span class="rst-problematic" id="rst-problematic-6">:ref:`cx_oracle_unicode_encoding_errors`</span></a> for detail.</li>
</ul>
</div>
<div class="rst-section" id="rst-using-cx-oracle-sessionpool">
<span id="rst-cx-oracle-sessionpool"></span><h2 class="heading">Using cx_Oracle SessionPool</h2>
<p>The cx_Oracle library provides its own connection pool implementation that may
be used in place of SQLAlchemy's pooling functionality.  This can be achieved
by using the <a href="#system-message-7"><span class="rst-problematic" id="rst-problematic-7">:paramref:`_sa.create_engine.creator`</span></a> parameter to provide a
function that returns a new connection, along with setting
<a href="#system-message-8"><span class="rst-problematic" id="rst-problematic-8">:paramref:`_sa.create_engine.pool_class`</span></a> to <tt class="rst-docutils literal">NullPool</tt> to disable
SQLAlchemy's pooling:</p>
<pre class="rst-literal-block">
import cx_Oracle
from sqlalchemy import create_engine
from sqlalchemy.pool import NullPool

pool = cx_Oracle.SessionPool(
    user="scott", password="tiger", dsn="orclpdb",
    min=2, max=5, increment=1, threaded=True,
    encoding="UTF-8", nencoding="UTF-8"
)

engine = create_engine("oracle://", creator=pool.acquire, poolclass=NullPool)
</pre>
<p>The above engine may then be used normally where cx_Oracle's pool handles
connection pooling:</p>
<pre class="rst-literal-block">
with engine.connect() as conn:
    print(conn.scalar("select 1 FROM dual"))
</pre>
<p>As well as providing a scalable solution for multi-user applications, the
cx_Oracle session pool supports some Oracle features such as DRCP and
<a class="rst-reference external" href="https://cx-oracle.readthedocs.io/en/latest/user_guide/ha.html#application-continuity-ac" target="_top">Application Continuity</a>.</p>
</div>
<div class="rst-section" id="rst-using-oracle-database-resident-connection-pooling-drcp">
<h2 class="heading">Using Oracle Database Resident Connection Pooling (DRCP)</h2>
<p>When using Oracle's <a class="rst-reference external" href="https://www.oracle.com/pls/topic/lookup?ctx=dblatest&amp;id=GUID-015CA8C1-2386-4626-855D-CC546DDC1086" target="_top">DRCP</a>,
the best practice is to pass a connection class and "purity" when acquiring a
connection from the SessionPool.  Refer to the <a class="rst-reference external" href="https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#database-resident-connection-pooling-drcp" target="_top">cx_Oracle DRCP documentation</a>.</p>
<p>This can be achieved by wrapping <tt class="rst-docutils literal">pool.acquire()</tt>:</p>
<pre class="rst-literal-block">
import cx_Oracle
from sqlalchemy import create_engine
from sqlalchemy.pool import NullPool

pool = cx_Oracle.SessionPool(
    user="scott", password="tiger", dsn="orclpdb",
    min=2, max=5, increment=1, threaded=True,
    encoding="UTF-8", nencoding="UTF-8"
)

def creator():
    return pool.acquire(cclass="MYCLASS", purity=cx_Oracle.ATTR_PURITY_SELF)

engine = create_engine("oracle://", creator=creator, poolclass=NullPool)
</pre>
<p>The above engine may then be used normally where cx_Oracle handles session
pooling and Oracle Database additionally uses DRCP:</p>
<pre class="rst-literal-block">
with engine.connect() as conn:
    print(conn.scalar("select 1 FROM dual"))
</pre>
</div>
<div class="rst-section" id="rst-unicode">
<span id="rst-cx-oracle-unicode"></span><h2 class="heading">Unicode</h2>
<p>As is the case for all DBAPIs under Python 3, all strings are inherently
Unicode strings.     Under Python 2, cx_Oracle also supports Python Unicode
objects directly.    In all cases however, the driver requires an explicit
encoding configuration.</p>
<div class="rst-section" id="rst-ensuring-the-correct-client-encoding">
<h3 class="heading">Ensuring the Correct Client Encoding</h3>
<p>The long accepted standard for establishing client encoding for nearly all
Oracle related software is via the <a class="rst-reference external" href="https://www.oracle.com/database/technologies/faq-nls-lang.html" target="_top">NLS_LANG</a>
environment variable.   cx_Oracle like most other Oracle drivers will use
this environment variable as the source of its encoding configuration.  The
format of this variable is idiosyncratic; a typical value would be
<tt class="rst-docutils literal">AMERICAN_AMERICA.AL32UTF8</tt>.</p>
<p>The cx_Oracle driver also supports a programmatic alternative which is to
pass the <tt class="rst-docutils literal">encoding</tt> and <tt class="rst-docutils literal">nencoding</tt> parameters directly to its
<tt class="rst-docutils literal">.connect()</tt> function.  These can be present in the URL as follows:</p>
<pre class="rst-literal-block">
engine = create_engine("oracle+cx_oracle://scott:tiger@orclpdb/?encoding=UTF-8&amp;nencoding=UTF-8")
</pre>
<p>For the meaning of the <tt class="rst-docutils literal">encoding</tt> and <tt class="rst-docutils literal">nencoding</tt> parameters, please
consult
<a class="rst-reference external" href="https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization" target="_top">Characters Sets and National Language Support (NLS)</a>.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a class="rst-reference external" href="https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization" target="_top">Characters Sets and National Language Support (NLS)</a>
- in the cx_Oracle documentation.</p>
</div>
</div>
<div class="rst-section" id="rst-unicode-specific-column-datatypes">
<h3 class="heading">Unicode-specific Column datatypes</h3>
<p>The Core expression language handles unicode data by use of the <code>.Unicode</code>
and <code>.UnicodeText</code>
datatypes.  These types correspond to the  VARCHAR2 and CLOB Oracle datatypes by
default.   When using these datatypes with Unicode data, it is expected that
the Oracle database is configured with a Unicode-aware character set, as well
as that the <tt class="rst-docutils literal">NLS_LANG</tt> environment variable is set appropriately, so that
the VARCHAR2 and CLOB datatypes can accommodate the data.</p>
<p>In the case that the Oracle database is not configured with a Unicode character
set, the two options are to use the <code>_types.NCHAR</code> and
<code>_oracle.NCLOB</code> datatypes explicitly, or to pass the flag
<tt class="rst-docutils literal">use_nchar_for_unicode=True</tt> to <code>_sa.create_engine</code>,
which will cause the
SQLAlchemy dialect to use NCHAR/NCLOB for the <code>.Unicode</code> /
<code>.UnicodeText</code> datatypes instead of VARCHAR/CLOB.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.3: </span><span>The <code>.Unicode</code> and <code>.UnicodeText</code>
datatypes now correspond to the <tt class="rst-docutils literal">VARCHAR2</tt> and <tt class="rst-docutils literal">CLOB</tt> Oracle datatypes
unless the <tt class="rst-docutils literal">use_nchar_for_unicode=True</tt> is passed to the dialect
when <code>_sa.create_engine</code> is called.</span></div>
</div>
<div class="rst-section" id="rst-unicode-coercion-of-result-rows-under-python-2">
<h3 class="heading">Unicode Coercion of result rows under Python 2</h3>
<p>When result sets are fetched that include strings, under Python 3 the cx_Oracle
DBAPI returns all strings as Python Unicode objects, since Python 3 only has a
Unicode string type.  This occurs for data fetched from datatypes such as
VARCHAR2, CHAR, CLOB, NCHAR, NCLOB, etc.  In order to provide cross-
compatibility under Python 2, the SQLAlchemy cx_Oracle dialect will add
Unicode-conversion to string data under Python 2 as well.  Historically, this
made use of converters that were supplied by cx_Oracle but were found to be
non-performant; SQLAlchemy's own converters are used for the string to Unicode
conversion under Python 2.  To disable the Python 2 Unicode conversion for
VARCHAR2, CHAR, and CLOB, the flag <tt class="rst-docutils literal">coerce_to_unicode=False</tt> can be passed to
<code>_sa.create_engine</code>.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.3: </span><span>Unicode conversion is applied to all string values
by default under python 2.  The <tt class="rst-docutils literal">coerce_to_unicode</tt> now defaults to True
and can be set to False to disable the Unicode coercion of strings that are
delivered as VARCHAR2/CHAR/CLOB data.</span></div>
</div>
<div class="rst-section" id="rst-encoding-errors">
<span id="rst-cx-oracle-unicode-encoding-errors"></span><h3 class="heading">Encoding Errors</h3>
<p>For the unusual case that data in the Oracle database is present with a broken
encoding, the dialect accepts a parameter <tt class="rst-docutils literal">encoding_errors</tt> which will be
passed to Unicode decoding functions in order to affect how decoding errors are
handled.  The value is ultimately consumed by the Python <a class="rst-reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes.decode" target="_top">decode</a> function, and
is passed both via cx_Oracle's <tt class="rst-docutils literal">encodingErrors</tt> parameter consumed by
<tt class="rst-docutils literal">Cursor.var()</tt>, as well as SQLAlchemy's own decoding function, as the
cx_Oracle dialect makes use of both under different circumstances.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.3.11.</span></div>
</div>
</div>
<div class="rst-section" id="rst-fine-grained-control-over-cx-oracle-data-binding-performance-with-setinputsizes">
<span id="rst-cx-oracle-setinputsizes"></span><h2 class="heading">Fine grained control over cx_Oracle data binding performance with setinputsizes</h2>
<p>The cx_Oracle DBAPI has a deep and fundamental reliance upon the usage of the
DBAPI <tt class="rst-docutils literal">setinputsizes()</tt> call.   The purpose of this call is to establish the
datatypes that are bound to a SQL statement for Python values being passed as
parameters.  While virtually no other DBAPI assigns any use to the
<tt class="rst-docutils literal">setinputsizes()</tt> call, the cx_Oracle DBAPI relies upon it heavily in its
interactions with the Oracle client interface, and in some scenarios it is  not
possible for SQLAlchemy to know exactly how data should be bound, as some
settings can cause profoundly different performance characteristics, while
altering the type coercion behavior at the same time.</p>
<p>Users of the cx_Oracle dialect are <strong>strongly encouraged</strong> to read through
cx_Oracle's list of built-in datatype symbols at
<a class="rst-reference external" href="https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types" target="_top">https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types</a>.
Note that in some cases, significant performance degradation can occur when
using these types vs. not, in particular when specifying <tt class="rst-docutils literal">cx_Oracle.CLOB</tt>.</p>
<p>On the SQLAlchemy side, the <code>.DialectEvents.do_setinputsizes</code> event can
be used both for runtime visibility (e.g. logging) of the setinputsizes step as
well as to fully control how <tt class="rst-docutils literal">setinputsizes()</tt> is used on a per-statement
basis.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.2.9: </span><span>Added <code>.DialectEvents.setinputsizes</code></span></div>
<div class="rst-section" id="rst-example-1-logging-all-setinputsizes-calls">
<h3 class="heading">Example 1 - logging all setinputsizes calls</h3>
<p>The following example illustrates how to log the intermediary values from a
SQLAlchemy perspective before they are converted to the raw <tt class="rst-docutils literal">setinputsizes()</tt>
parameter dictionary.  The keys of the dictionary are <code>.BindParameter</code>
objects which have a <tt class="rst-docutils literal">.key</tt> and a <tt class="rst-docutils literal">.type</tt> attribute:</p>
<pre class="rst-literal-block">
from sqlalchemy import create_engine, event

engine = create_engine("oracle+cx_oracle://scott:tiger@host/xe")

@event.listens_for(engine, "do_setinputsizes")
def _log_setinputsizes(inputsizes, cursor, statement, parameters, context):
    for bindparam, dbapitype in inputsizes.items():
            log.info(
                "Bound parameter name: %s  SQLAlchemy type: %r  "
                "DBAPI object: %s",
                bindparam.key, bindparam.type, dbapitype)
</pre>
</div>
<div class="rst-section" id="rst-example-2-remove-all-bindings-to-clob">
<h3 class="heading">Example 2 - remove all bindings to CLOB</h3>
<p>The <tt class="rst-docutils literal">CLOB</tt> datatype in cx_Oracle incurs a significant performance overhead,
however is set by default for the <tt class="rst-docutils literal">Text</tt> type within the SQLAlchemy 1.2
series.   This setting can be modified as follows:</p>
<pre class="rst-literal-block">
from sqlalchemy import create_engine, event
from cx_Oracle import CLOB

engine = create_engine("oracle+cx_oracle://scott:tiger@host/xe")

@event.listens_for(engine, "do_setinputsizes")
def _remove_clob(inputsizes, cursor, statement, parameters, context):
    for bindparam, dbapitype in list(inputsizes.items()):
        if dbapitype is CLOB:
            del inputsizes[bindparam]
</pre>
</div>
</div>
<div class="rst-section" id="rst-returning-support">
<span id="rst-cx-oracle-returning"></span><h2 class="heading">RETURNING Support</h2>
<p>The cx_Oracle dialect implements RETURNING using OUT parameters.
The dialect supports RETURNING fully, however cx_Oracle 6 is recommended
for complete support.</p>
</div>
<div class="rst-section" id="rst-lob-objects">
<span id="rst-cx-oracle-lob"></span><h2 class="heading">LOB Objects</h2>
<p>cx_oracle returns oracle LOBs using the cx_oracle.LOB object.  SQLAlchemy
converts these to strings so that the interface of the Binary type is
consistent with that of other backends, which takes place within a cx_Oracle
outputtypehandler.</p>
<p>cx_Oracle prior to version 6 would require that LOB objects be read before
a new batch of rows would be read, as determined by the <tt class="rst-docutils literal">cursor.arraysize</tt>.
As of the 6 series, this limitation has been lifted.  Nevertheless, because
SQLAlchemy pre-reads these LOBs up front, this issue is avoided in any case.</p>
<p>To disable the auto "read()" feature of the dialect, the flag
<tt class="rst-docutils literal">auto_convert_lobs=False</tt> may be passed to <code>_sa.create_engine</code>.  Under
the cx_Oracle 5 series, having this flag turned off means there is the chance
of reading from a stale LOB object if not read as it is fetched.   With
cx_Oracle 6, this issue is resolved.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.2: </span><span>the LOB handling system has been greatly simplified
internally to make use of outputtypehandlers, and no longer makes use
of alternate "buffered" result set objects.</span></div>
</div>
<div class="rst-section" id="rst-two-phase-transactions-not-supported">
<h2 class="heading">Two Phase Transactions Not Supported</h2>
<p>Two phase transactions are <strong>not supported</strong> under cx_Oracle due to poor
driver support.   As of cx_Oracle 6.0b1, the interface for
two phase transactions has been changed to be more of a direct pass-through
to the underlying OCI layer with less automation.  The additional logic
to support this system is not implemented in SQLAlchemy.</p>
</div>
<div class="rst-section" id="rst-precision-numerics">
<span id="rst-cx-oracle-numeric"></span><h2 class="heading">Precision Numerics</h2>
<p>SQLAlchemy's numeric types can handle receiving and returning values as Python
<tt class="rst-docutils literal">Decimal</tt> objects or float objects.  When a <code>.Numeric</code> object, or a
subclass such as <code>.Float</code>, <code>_oracle.DOUBLE_PRECISION</code> etc. is in
use, the <a href="#system-message-9"><span class="rst-problematic" id="rst-problematic-9">:paramref:`.Numeric.asdecimal`</span></a> flag determines if values should be
coerced to <tt class="rst-docutils literal">Decimal</tt> upon return, or returned as float objects.   To make
matters more complicated under Oracle, Oracle's <tt class="rst-docutils literal">NUMBER</tt> type can also
represent integer values if the "scale" is zero, so the Oracle-specific
<code>_oracle.NUMBER</code> type takes this into account as well.</p>
<p>The cx_Oracle dialect makes extensive use of connection- and cursor-level
"outputtypehandler" callables in order to coerce numeric values as requested.
These callables are specific to the specific flavor of <code>.Numeric</code> in
use, as well as if no SQLAlchemy typing objects are present.   There are
observed scenarios where Oracle may sends incomplete or ambiguous information
about the numeric types being returned, such as a query where the numeric types
are buried under multiple levels of subquery.  The type handlers do their best
to make the right decision in all cases, deferring to the underlying cx_Oracle
DBAPI for all those cases where the driver can make the best decision.</p>
<p>When no typing objects are present, as when executing plain SQL strings, a
default "outputtypehandler" is present which will generally return numeric
values which specify precision and scale as Python <tt class="rst-docutils literal">Decimal</tt> objects.  To
disable this coercion to decimal for performance reasons, pass the flag
<tt class="rst-docutils literal">coerce_to_decimal=False</tt> to <code>_sa.create_engine</code>:</p>
<pre class="rst-literal-block">
engine = create_engine("oracle+cx_oracle://dsn", coerce_to_decimal=False)
</pre>
<p>The <tt class="rst-docutils literal">coerce_to_decimal</tt> flag only impacts the results of plain string
SQL statements that are not otherwise associated with a <code>.Numeric</code>
SQLAlchemy type (or a subclass of such).</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.2: </span><span>The numeric handling system for cx_Oracle has been
reworked to take advantage of newer cx_Oracle features as well
as better integration of outputtypehandlers.</span></div>
</div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id19117">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle.OracleCompiler_cx_oracle.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle.OracleCompiler_cx_oracle">​Oracle​Compiler_cx_oracle</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle.OracleDialect_cx_oracle.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle.OracleDialect_cx_oracle">​Oracle​Dialect_cx_oracle</a></code></td>
    <td><span class="undocumented">No class docstring; 0/1 property, 0/13 instance variable, 0/6 class variable, 2/20 methods, 0/1 class method documented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle.OracleExecutionContext_cx_oracle.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle.OracleExecutionContext_cx_oracle">​Oracle​Execution​Context_cx_oracle</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleBinary.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleBinary">_​Oracle​Binary</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleBINARY_DOUBLE.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleBINARY_DOUBLE">_​Oracle​BINARY_​DOUBLE</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleBINARY_FLOAT.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleBINARY_FLOAT">_​Oracle​BINARY_​FLOAT</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleBinaryFloat.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleBinaryFloat">_​Oracle​Binary​Float</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleChar.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleChar">_​Oracle​Char</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleDate.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleDate">_​Oracle​Date</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleEnum.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleEnum">_​Oracle​Enum</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleInteger.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleInteger">_​Oracle​Integer</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleInterval.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleInterval">_​Oracle​Interval</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleLong.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleLong">_​Oracle​Long</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleNChar.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleNChar">_​Oracle​NChar</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleNUMBER.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleNUMBER">_​Oracle​NUMBER</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleNumeric.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleNumeric">_​Oracle​Numeric</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleRaw.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleRaw">_​Oracle​Raw</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleRowid.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleRowid">_​Oracle​Rowid</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleString.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleString">_​Oracle​String</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleText.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleText">_​Oracle​Text</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleUnicodeStringCHAR.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleUnicodeStringCHAR">_​Oracle​Unicode​String​CHAR</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleUnicodeStringNCHAR.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleUnicodeStringNCHAR">_​Oracle​Unicode​String​NCHAR</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleUnicodeTextCLOB.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleUnicodeTextCLOB">_​Oracle​Unicode​Text​CLOB</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.oracle.cx_oracle._OracleUnicodeTextNCLOB.html" class="internal-link" title="sqlalchemy.dialects.oracle.cx_oracle._OracleUnicodeTextNCLOB">_​Oracle​Unicode​Text​NCLOB</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 08:22:50.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>