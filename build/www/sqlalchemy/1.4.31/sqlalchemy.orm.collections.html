<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.orm.collections</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.orm.html" class="internal-link" title="sqlalchemy.orm">orm</a></code><wbr></wbr>.<code><a href="sqlalchemy.orm.collections.html" class="internal-link" title="sqlalchemy.orm.collections">collections</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p>Support for collections of mapped entities.</p>
<p>The collections package supplies the machinery used to inform the ORM of
collection membership changes.  An instrumentation via decoration approach is
used, allowing arbitrary types (including built-ins) to be used as entity
collections without requiring inheritance from a base class.</p>
<p>Instrumentation decoration relays membership change events to the
<code>.CollectionAttributeImpl</code> that is currently managing the collection.
The decorators observe function call arguments and return values, tracking
entities entering or leaving the collection.  Two decorator approaches are
provided.  One is a bundle of generic decorators that map function arguments
and return values to events:</p>
<pre class="rst-literal-block">
from sqlalchemy.orm.collections import collection
class MyClass(object):
    # ...

    @collection.adds(1)
    def store(self, item):
        self.data.append(item)

    @collection.removes_return()
    def pop(self):
        return self.data.pop()
</pre>
<p>The second approach is a bundle of targeted decorators that wrap appropriate
append and remove notifiers around the mutation methods present in the
standard Python <tt class="rst-docutils literal">list</tt>, <tt class="rst-docutils literal">set</tt> and <tt class="rst-docutils literal">dict</tt> interfaces.  These could be
specified in terms of generic decorator recipes, but are instead hand-tooled
for increased efficiency.  The targeted decorators occasionally implement
adapter-like behavior, such as mapping bulk-set methods (<tt class="rst-docutils literal">extend</tt>,
<tt class="rst-docutils literal">update</tt>, <tt class="rst-docutils literal">__setslice__</tt>, etc.) into the series of atomic mutation events
that the ORM requires.</p>
<p>The targeted decorators are used internally for automatic instrumentation of
entity collection classes.  Every collection class goes through a
transformation process roughly like so:</p>
<ol class="rst-arabic simple">
<li>If the class is a built-in, substitute a trivial sub-class</li>
<li>Is this class already instrumented?</li>
<li>Add in generic decorators</li>
<li>Sniff out the collection interface through duck-typing</li>
<li>Add targeted decoration to any undecorated interface method</li>
</ol>
<p>This process modifies the class at runtime, decorating methods and adding some
bookkeeping properties.  This isn't possible (or desirable) for built-in
classes like <tt class="rst-docutils literal">list</tt>, so trivial sub-classes are substituted to hold
decoration:</p>
<pre class="rst-literal-block">
class InstrumentedList(list):
    pass
</pre>
<p>Collection classes can be specified in <tt class="rst-docutils literal">relationship(collection_class=)</tt> as
types or a function that returns an instance.  Collection classes are
inspected and instrumented during the mapper compilation phase.  The
collection_class callable will be executed once to produce a specimen
instance, and the type of that specimen will be instrumented.  Functions that
return built-in types like <tt class="rst-docutils literal">lists</tt> will be adapted to produce instrumented
instances.</p>
<p>When extending a known type like <tt class="rst-docutils literal">list</tt>, additional decorations are not
generally not needed.  Odds are, the extension method will delegate to a
method that's already instrumented.  For example:</p>
<pre class="rst-literal-block">
class QueueIsh(list):
   def push(self, item):
       self.append(item)
   def shift(self):
       return self.pop(0)
</pre>
<p>There's no need to decorate these methods.  <tt class="rst-docutils literal">append</tt> and <tt class="rst-docutils literal">pop</tt> are already
instrumented as part of the <tt class="rst-docutils literal">list</tt> interface.  Decorating them would fire
duplicate events, which should be avoided.</p>
<p>The targeted decoration tries not to rely on other methods in the underlying
collection class, but some are unavoidable.  Many depend on 'read' methods
being present to properly instrument a 'write', for example, <tt class="rst-docutils literal">__setitem__</tt>
needs <tt class="rst-docutils literal">__getitem__</tt>.  "Bulk" methods like <tt class="rst-docutils literal">update</tt> and <tt class="rst-docutils literal">extend</tt> may also
reimplemented in terms of atomic appends and removes, so the <tt class="rst-docutils literal">extend</tt>
decoration will actually perform many <tt class="rst-docutils literal">append</tt> operations and not call the
underlying method at all.</p>
<p>Tight control over bulk operation and the firing of events is also possible by
implementing the instrumentation internally in your methods.  The basic
instrumentation package works under the general assumption that collection
mutation will not raise unusual exceptions.  If you want to closely
orchestrate append and remove events with exception management, internal
instrumentation may be the answer.  Within your method,
<tt class="rst-docutils literal">collection_adapter(self)</tt> will retrieve an object that you can use for
explicit control over triggering append and remove events.</p>
<p>The owning object and <code>.CollectionAttributeImpl</code> are also reachable
through the adapter, allowing for some very sophisticated behavior.</p>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id16738">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.orm.collections.collection.html" class="internal-link" title="sqlalchemy.orm.collections.collection">collection</a></code></td>
    <td>Decorators for entity collection classes.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.orm.collections.CollectionAdapter.html" class="internal-link" title="sqlalchemy.orm.collections.CollectionAdapter">​Collection​Adapter</a></code></td>
    <td>Bridges between the ORM and arbitrary Python collections.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.orm.collections.InstrumentedDict.html" class="internal-link" title="sqlalchemy.orm.collections.InstrumentedDict">​Instrumented​Dict</a></code></td>
    <td>An instrumented version of the built-in dict.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.orm.collections.InstrumentedList.html" class="internal-link" title="sqlalchemy.orm.collections.InstrumentedList">​Instrumented​List</a></code></td>
    <td>An instrumented version of the built-in list.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.orm.collections.InstrumentedSet.html" class="internal-link" title="sqlalchemy.orm.collections.InstrumentedSet">​Instrumented​Set</a></code></td>
    <td>An instrumented version of the built-in set.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.orm.collections.MappedCollection.html" class="internal-link" title="sqlalchemy.orm.collections.MappedCollection">​Mapped​Collection</a></code></td>
    <td>A basic dictionary-based collection class.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#attribute_mapped_collection" class="internal-link" title="sqlalchemy.orm.collections.attribute_mapped_collection">attribute​_mapped​_collection</a></code></td>
    <td>A dictionary-based collection type with attribute-based keying.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#bulk_replace" class="internal-link" title="sqlalchemy.orm.collections.bulk_replace">bulk​_replace</a></code></td>
    <td>Load a new collection, firing events based on prior like membership.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#column_mapped_collection" class="internal-link" title="sqlalchemy.orm.collections.column_mapped_collection">column​_mapped​_collection</a></code></td>
    <td>A dictionary-based collection type with column-based keying.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#mapped_collection" class="internal-link" title="sqlalchemy.orm.collections.mapped_collection">mapped​_collection</a></code></td>
    <td>A dictionary-based collection type with arbitrary keying.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#prepare_instrumentation" class="internal-link" title="sqlalchemy.orm.collections.prepare_instrumentation">prepare​_instrumentation</a></code></td>
    <td>Prepare a callable for future use as a collection class factory.</td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><code><a href="#collection_adapter" class="internal-link" title="sqlalchemy.orm.collections.collection_adapter">collection​_adapter</a></code></td>
    <td>Fetch the <code>.CollectionAdapter</code> for a collection.</td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.orm.collections._PlainColumnGetter.html" class="internal-link" title="sqlalchemy.orm.collections._PlainColumnGetter">_​Plain​Column​Getter</a></code></td>
    <td>Plain column getter, stores collection of Column objects directly.</td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.orm.collections._SerializableAttrGetter.html" class="internal-link" title="sqlalchemy.orm.collections._SerializableAttrGetter">_​Serializable​Attr​Getter</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.orm.collections._SerializableColumnGetter.html" class="internal-link" title="sqlalchemy.orm.collections._SerializableColumnGetter">_​Serializable​Column​Getter</a></code></td>
    <td>Column-based getter used in version 0.7.6 only.</td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.orm.collections._SerializableColumnGetterV2.html" class="internal-link" title="sqlalchemy.orm.collections._SerializableColumnGetterV2">_​Serializable​Column​Getter​V2</a></code></td>
    <td>Updated serializable getter which deals with multi-table mapped classes.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#__before_pop" class="internal-link" title="sqlalchemy.orm.collections.__before_pop">__before​_pop</a></code></td>
    <td>An event which occurs on a before a pop() operation occurs.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#__converting_factory" class="internal-link" title="sqlalchemy.orm.collections.__converting_factory">__converting​_factory</a></code></td>
    <td>Return a wrapper that converts a "canned" collection like set, dict, list into the Instrumented* version.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#__del" class="internal-link" title="sqlalchemy.orm.collections.__del">__del</a></code></td>
    <td>Run del events.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#__set" class="internal-link" title="sqlalchemy.orm.collections.__set">__set</a></code></td>
    <td>Run set events.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#__set_wo_mutation" class="internal-link" title="sqlalchemy.orm.collections.__set_wo_mutation">__set​_wo​_mutation</a></code></td>
    <td>Run set wo mutation events.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_assert_required_roles" class="internal-link" title="sqlalchemy.orm.collections._assert_required_roles">​_assert​_required​_roles</a></code></td>
    <td>ensure all roles are present, and apply implicit instrumentation if needed</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_dict_decorators" class="internal-link" title="sqlalchemy.orm.collections._dict_decorators">​_dict​_decorators</a></code></td>
    <td>Tailored instrumentation wrappers for any dict-like mapping class.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_instrument_class" class="internal-link" title="sqlalchemy.orm.collections._instrument_class">​_instrument​_class</a></code></td>
    <td>Modify methods in a class and install instrumentation.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_instrument_membership_mutator" class="internal-link" title="sqlalchemy.orm.collections._instrument_membership_mutator">​_instrument​_membership​_mutator</a></code></td>
    <td>Route method args and/or return value through the collection adapter.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_list_decorators" class="internal-link" title="sqlalchemy.orm.collections._list_decorators">​_list​_decorators</a></code></td>
    <td>Tailored instrumentation wrappers for any list-like class.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_locate_roles_and_methods" class="internal-link" title="sqlalchemy.orm.collections._locate_roles_and_methods">​_locate​_roles​_and​_methods</a></code></td>
    <td>search for _sa_instrument_role-decorated methods in method resolution order, assign to roles.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_set_binops_check_loose" class="internal-link" title="sqlalchemy.orm.collections._set_binops_check_loose">​_set​_binops​_check​_loose</a></code></td>
    <td>Allow anything set-like to participate in set binops.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_set_binops_check_strict" class="internal-link" title="sqlalchemy.orm.collections._set_binops_check_strict">​_set​_binops​_check​_strict</a></code></td>
    <td>Allow only set, frozenset and self.__class__-derived objects in binops.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_set_collection_attributes" class="internal-link" title="sqlalchemy.orm.collections._set_collection_attributes">​_set​_collection​_attributes</a></code></td>
    <td>apply ad-hoc instrumentation from decorators, class-level defaults and implicit role declarations</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_set_decorators" class="internal-link" title="sqlalchemy.orm.collections._set_decorators">​_set​_decorators</a></code></td>
    <td>Tailored instrumentation wrappers for any set-like class.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_setup_canned_roles" class="internal-link" title="sqlalchemy.orm.collections._setup_canned_roles">​_setup​_canned​_roles</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#__canned_instrumentation" class="internal-link" title="sqlalchemy.orm.collections.__canned_instrumentation">__canned​_instrumentation</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#__instrumentation_mutex" class="internal-link" title="sqlalchemy.orm.collections.__instrumentation_mutex">__instrumentation​_mutex</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#__interfaces" class="internal-link" title="sqlalchemy.orm.collections.__interfaces">__interfaces</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#_set_binop_bases" class="internal-link" title="sqlalchemy.orm.collections._set_binop_bases">​_set​_binop​_bases</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basefunction">
  
  
  <a name="sqlalchemy.orm.collections.attribute_mapped_collection">
    
  </a>
  <a name="attribute_mapped_collection">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">attribute_mapped_collection</span>(attr_name):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>A dictionary-based collection type with attribute-based keying.</p>
<p>Returns a <code>.MappedCollection</code> factory with a keying based on the
'attr_name' attribute of entities in the collection, where <tt class="rst-docutils literal">attr_name</tt>
is the string name of the attribute.</p>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p class="rst-last">the key value must be assigned to its final value
<strong>before</strong> it is accessed by the attribute mapped collection.
Additionally, changes to the key attribute are <strong>not tracked</strong>
automatically, which means the key in the dictionary is not
automatically synchronized with the key value on the target object
itself.  See the section <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`key_collections_mutations`</span></a>
for an example.</p>
</div>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="sqlalchemy.orm.collections.bulk_replace">
    
  </a>
  <a name="bulk_replace">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bulk_replace</span>(values, existing_adapter, new_adapter, initiator=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Load a new collection, firing events based on prior like membership.</p>
<p>Appends instances in <tt class="rst-docutils literal">values</tt> onto the <tt class="rst-docutils literal">new_adapter</tt>. Events will be
fired for any instance not present in the <tt class="rst-docutils literal">existing_adapter</tt>.  Any
instances in <tt class="rst-docutils literal">existing_adapter</tt> not present in <tt class="rst-docutils literal">values</tt> will have
remove events fired upon them.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">values</span></td><td class="fieldArgDesc">An iterable of collection member instances</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">existing​_adapter</span></td><td class="fieldArgDesc">A <code>.CollectionAdapter</code> of
instances to be replaced</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">new​_adapter</span></td><td class="fieldArgDesc">An empty <code>.CollectionAdapter</code>
to load with <tt class="rst-docutils literal">values</tt></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">initiator</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="sqlalchemy.orm.collections.column_mapped_collection">
    
  </a>
  <a name="column_mapped_collection">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">column_mapped_collection</span>(mapping_spec):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>A dictionary-based collection type with column-based keying.</p>
<p>Returns a <code>.MappedCollection</code> factory with a keying function
generated from mapping_spec, which may be a Column or a sequence
of Columns.</p>
<p>The key value must be immutable for the lifetime of the object.  You
can not, for example, map on foreign key values if those key values will
change during the session, i.e. from None to a database-assigned integer
after a session flush.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="sqlalchemy.orm.collections.mapped_collection">
    
  </a>
  <a name="mapped_collection">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">mapped_collection</span>(keyfunc):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>A dictionary-based collection type with arbitrary keying.</p>
<p>Returns a <code>.MappedCollection</code> factory with a keying function
generated from keyfunc, a callable that takes an entity and returns a
key value.</p>
<p>The key value must be immutable for the lifetime of the object.  You
can not, for example, map on foreign key values if those key values will
change during the session, i.e. from None to a database-assigned integer
after a session flush.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="sqlalchemy.orm.collections.prepare_instrumentation">
    
  </a>
  <a name="prepare_instrumentation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">prepare_instrumentation</span>(factory):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Prepare a callable for future use as a collection class factory.</p>
<p>Given a collection class factory (either a type or no-arg callable),
return another factory that will produce compatible instances when
called.</p>
<p>This function is responsible for converting collection_class=list
into the run-time behavior of collection_class=InstrumentedList.</p>
</div>
  </div>
</div><div class="basevariable">
  
  
  <a name="sqlalchemy.orm.collections.collection_adapter">
    
  </a>
  <a name="collection_adapter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">collection_adapter</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>Fetch the <code>.CollectionAdapter</code> for a collection.</div>
    
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections.__before_pop">
    
  </a>
  <a name="__before_pop">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__before_pop</span>(collection, _sa_initiator=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>An event which occurs on a before a pop() operation occurs.</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections.__converting_factory">
    
  </a>
  <a name="__converting_factory">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__converting_factory</span>(specimen_cls, original_factory):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Return a wrapper that converts a "canned" collection like
set, dict, list into the Instrumented* version.</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections.__del">
    
  </a>
  <a name="__del">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__del</span>(collection, item, _sa_initiator=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Run del events.</p>
<p>This event occurs before the collection is actually mutated, <em>except</em>
in the case of a pop operation, in which case it occurs afterwards.
For pop operations, the __before_pop hook is called before the
operation occurs.</p>
</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections.__set">
    
  </a>
  <a name="__set">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__set</span>(collection, item, _sa_initiator=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Run set events.</p>
<p>This event always occurs before the collection is actually mutated.</p>
</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections.__set_wo_mutation">
    
  </a>
  <a name="__set_wo_mutation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__set_wo_mutation</span>(collection, item, _sa_initiator=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Run set wo mutation events.</p>
<p>The collection is not mutated.</p>
</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections._assert_required_roles">
    
  </a>
  <a name="_assert_required_roles">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_assert_required_roles</span>(cls, roles, methods):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>ensure all roles are present, and apply implicit instrumentation if
needed</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections._dict_decorators">
    
  </a>
  <a name="_dict_decorators">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_dict_decorators</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Tailored instrumentation wrappers for any dict-like mapping class.</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections._instrument_class">
    
  </a>
  <a name="_instrument_class">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_instrument_class</span>(cls):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Modify methods in a class and install instrumentation.</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections._instrument_membership_mutator">
    
  </a>
  <a name="_instrument_membership_mutator">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_instrument_membership_mutator</span>(method, before, argument, after):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Route method args and/or return value through the collection
adapter.</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections._list_decorators">
    
  </a>
  <a name="_list_decorators">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_list_decorators</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Tailored instrumentation wrappers for any list-like class.</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections._locate_roles_and_methods">
    
  </a>
  <a name="_locate_roles_and_methods">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_locate_roles_and_methods</span>(cls):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>search for _sa_instrument_role-decorated methods in
method resolution order, assign to roles.</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections._set_binops_check_loose">
    
  </a>
  <a name="_set_binops_check_loose">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_set_binops_check_loose</span>(self, obj):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Allow anything set-like to participate in set binops.</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections._set_binops_check_strict">
    
  </a>
  <a name="_set_binops_check_strict">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_set_binops_check_strict</span>(self, obj):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Allow only set, frozenset and self.__class__-derived
objects in binops.</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections._set_collection_attributes">
    
  </a>
  <a name="_set_collection_attributes">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_set_collection_attributes</span>(cls, roles, methods):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>apply ad-hoc instrumentation from decorators, class-level defaults
and implicit role declarations</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections._set_decorators">
    
  </a>
  <a name="_set_decorators">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_set_decorators</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Tailored instrumentation wrappers for any set-like class.</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="sqlalchemy.orm.collections._setup_canned_roles">
    
  </a>
  <a name="_setup_canned_roles">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_setup_canned_roles</span>(cls, roles, methods):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>see if this class has "canned" roles based on a known
collection type (dict, set, list).  Apply those roles
as needed to the "roles" dictionary, and also
prepare "decorator" methods</div>
  </div>
</div><div class="basevariable private">
  
  
  <a name="sqlalchemy.orm.collections.__canned_instrumentation">
    
  </a>
  <a name="__canned_instrumentation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">__canned_instrumentation</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="basevariable private">
  
  
  <a name="sqlalchemy.orm.collections.__instrumentation_mutex">
    
  </a>
  <a name="__instrumentation_mutex">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">__instrumentation_mutex</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="basevariable private">
  
  
  <a name="sqlalchemy.orm.collections.__interfaces">
    
  </a>
  <a name="__interfaces">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">__interfaces</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="basevariable private">
  
  
  <a name="sqlalchemy.orm.collections._set_binop_bases">
    
  </a>
  <a name="_set_binop_bases">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_set_binop_bases</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 04:41:59.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>