<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.orm.session.Session</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.orm.html" class="internal-link" title="sqlalchemy.orm">orm</a></code><wbr></wbr>.<code><a href="sqlalchemy.orm.session.html" class="internal-link" title="sqlalchemy.orm.session">session</a></code><wbr></wbr>.<code><a href="sqlalchemy.orm.session.Session.html" class="internal-link" title="sqlalchemy.orm.session.Session">Session</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> <span class="py-defname">Session</span>(<a href="sqlalchemy.orm.session._SessionClassMethods.html" class="internal-link" title="sqlalchemy.orm.session._SessionClassMethods">_SessionClassMethods</a>):</code></p><p>Known subclasses: <code><a href="sqlalchemy.ext.horizontal_shard.ShardedSession.html" class="internal-link">sqlalchemy.ext.horizontal_shard.ShardedSession</a></code></p>
        <p><a href="classIndex.html#sqlalchemy.orm.session.Session">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p>Manages persistence operations for ORM-mapped objects.</p>
<p>The Session's usage paradigm is described at <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:doc:`/orm/session`</span></a>.</p>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id17165">
  
  
  <tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__contains__" class="internal-link" title="sqlalchemy.orm.session.Session.__contains__">__contains__</a></code></td>
    <td>Return True if the instance is associated with this session.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__enter__" class="internal-link" title="sqlalchemy.orm.session.Session.__enter__">__enter__</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__exit__" class="internal-link" title="sqlalchemy.orm.session.Session.__exit__">__exit__</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__init__" class="internal-link" title="sqlalchemy.orm.session.Session.__init__">__init__</a></code></td>
    <td>Construct a new Session.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__iter__" class="internal-link" title="sqlalchemy.orm.session.Session.__iter__">__iter__</a></code></td>
    <td>Iterate over all pending or persistent instances within this Session.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add" class="internal-link" title="sqlalchemy.orm.session.Session.add">add</a></code></td>
    <td>Place an object in the <tt class="rst-docutils literal">Session</tt>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add_all" class="internal-link" title="sqlalchemy.orm.session.Session.add_all">add​_all</a></code></td>
    <td>Add the given collection of instances to this <tt class="rst-docutils literal">Session</tt>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#begin" class="internal-link" title="sqlalchemy.orm.session.Session.begin">begin</a></code></td>
    <td>Begin a transaction, or nested transaction, on this <code>.Session</code>, if one is not already begun.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#begin_nested" class="internal-link" title="sqlalchemy.orm.session.Session.begin_nested">begin​_nested</a></code></td>
    <td>Begin a "nested" transaction on this Session, e.g. SAVEPOINT.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bind_mapper" class="internal-link" title="sqlalchemy.orm.session.Session.bind_mapper">bind​_mapper</a></code></td>
    <td>Associate a <code>_orm.Mapper</code> or arbitrary Python class with a "bind", e.g. an <code>_engine.Engine</code> or <code>_engine.Connection</code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bind_table" class="internal-link" title="sqlalchemy.orm.session.Session.bind_table">bind​_table</a></code></td>
    <td>Associate a <code>_schema.Table</code> with a "bind", e.g. an <code>_engine.Engine</code> or <code>_engine.Connection</code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bulk_insert_mappings" class="internal-link" title="sqlalchemy.orm.session.Session.bulk_insert_mappings">bulk​_insert​_mappings</a></code></td>
    <td>Perform a bulk insert of the given list of mapping dictionaries.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bulk_save_objects" class="internal-link" title="sqlalchemy.orm.session.Session.bulk_save_objects">bulk​_save​_objects</a></code></td>
    <td>Perform a bulk save of the given list of objects.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bulk_update_mappings" class="internal-link" title="sqlalchemy.orm.session.Session.bulk_update_mappings">bulk​_update​_mappings</a></code></td>
    <td>Perform a bulk update of the given list of mapping dictionaries.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#close" class="internal-link" title="sqlalchemy.orm.session.Session.close">close</a></code></td>
    <td>Close out the transactional resources and ORM objects used by this <code>_orm.Session</code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#commit" class="internal-link" title="sqlalchemy.orm.session.Session.commit">commit</a></code></td>
    <td>Flush pending changes and commit the current transaction.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#connection" class="internal-link" title="sqlalchemy.orm.session.Session.connection">connection</a></code></td>
    <td>Return a <code>_engine.Connection</code> object corresponding to this <code>.Session</code> object's transactional state.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#delete" class="internal-link" title="sqlalchemy.orm.session.Session.delete">delete</a></code></td>
    <td>Mark an instance as deleted.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#enable_relationship_loading" class="internal-link" title="sqlalchemy.orm.session.Session.enable_relationship_loading">enable​_relationship​_loading</a></code></td>
    <td>Associate an object with this <code>.Session</code> for related object loading.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#execute" class="internal-link" title="sqlalchemy.orm.session.Session.execute">execute</a></code></td>
    <td>Execute a SQL expression construct.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#expire" class="internal-link" title="sqlalchemy.orm.session.Session.expire">expire</a></code></td>
    <td>Expire the attributes on an instance.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#expire_all" class="internal-link" title="sqlalchemy.orm.session.Session.expire_all">expire​_all</a></code></td>
    <td>Expires all persistent instances within this Session.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#expunge" class="internal-link" title="sqlalchemy.orm.session.Session.expunge">expunge</a></code></td>
    <td>Remove the <code>instance</code> from this <tt class="rst-docutils literal">Session</tt>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#expunge_all" class="internal-link" title="sqlalchemy.orm.session.Session.expunge_all">expunge​_all</a></code></td>
    <td>Remove all object instances from this <tt class="rst-docutils literal">Session</tt>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#flush" class="internal-link" title="sqlalchemy.orm.session.Session.flush">flush</a></code></td>
    <td>Flush all the object changes to the database.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get" class="internal-link" title="sqlalchemy.orm.session.Session.get">get</a></code></td>
    <td>Return an instance based on the given primary key identifier, or <tt class="rst-docutils literal">None</tt> if not found.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_bind" class="internal-link" title="sqlalchemy.orm.session.Session.get_bind">get​_bind</a></code></td>
    <td>Return a "bind" to which this <code>.Session</code> is bound.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_nested_transaction" class="internal-link" title="sqlalchemy.orm.session.Session.get_nested_transaction">get​_nested​_transaction</a></code></td>
    <td>Return the current nested transaction in progress, if any.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_transaction" class="internal-link" title="sqlalchemy.orm.session.Session.get_transaction">get​_transaction</a></code></td>
    <td>Return the current root transaction in progress, if any.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#in_nested_transaction" class="internal-link" title="sqlalchemy.orm.session.Session.in_nested_transaction">in​_nested​_transaction</a></code></td>
    <td>Return True if this <code>_orm.Session</code> has begun a nested transaction, e.g. SAVEPOINT.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#in_transaction" class="internal-link" title="sqlalchemy.orm.session.Session.in_transaction">in​_transaction</a></code></td>
    <td>Return True if this <code>_orm.Session</code> has begun a transaction.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#invalidate" class="internal-link" title="sqlalchemy.orm.session.Session.invalidate">invalidate</a></code></td>
    <td>Close this Session, using connection invalidation.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_modified" class="internal-link" title="sqlalchemy.orm.session.Session.is_modified">is​_modified</a></code></td>
    <td>Return <tt class="rst-docutils literal">True</tt> if the given instance has locally modified attributes.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#merge" class="internal-link" title="sqlalchemy.orm.session.Session.merge">merge</a></code></td>
    <td>Copy the state of a given instance into a corresponding instance within this <code>.Session</code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#prepare" class="internal-link" title="sqlalchemy.orm.session.Session.prepare">prepare</a></code></td>
    <td>Prepare the current transaction in progress for two phase commit.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#query" class="internal-link" title="sqlalchemy.orm.session.Session.query">query</a></code></td>
    <td>Return a new <code>_query.Query</code> object corresponding to this <code>_orm.Session</code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#refresh" class="internal-link" title="sqlalchemy.orm.session.Session.refresh">refresh</a></code></td>
    <td>Expire and refresh attributes on the given instance.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#rollback" class="internal-link" title="sqlalchemy.orm.session.Session.rollback">rollback</a></code></td>
    <td>Rollback the current transaction in progress.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#scalar" class="internal-link" title="sqlalchemy.orm.session.Session.scalar">scalar</a></code></td>
    <td>Execute a statement and return a scalar result.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#scalars" class="internal-link" title="sqlalchemy.orm.session.Session.scalars">scalars</a></code></td>
    <td>Execute a statement and return the results as scalars.</td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><code><a href="#connection_callable" class="internal-link" title="sqlalchemy.orm.session.Session.connection_callable">connection​_callable</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#autocommit" class="internal-link" title="sqlalchemy.orm.session.Session.autocommit">autocommit</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#autoflush" class="internal-link" title="sqlalchemy.orm.session.Session.autoflush">autoflush</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#bind" class="internal-link" title="sqlalchemy.orm.session.Session.bind">bind</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#enable_baked_queries" class="internal-link" title="sqlalchemy.orm.session.Session.enable_baked_queries">enable​_baked​_queries</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#expire_on_commit" class="internal-link" title="sqlalchemy.orm.session.Session.expire_on_commit">expire​_on​_commit</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#future" class="internal-link" title="sqlalchemy.orm.session.Session.future">future</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#hash_key" class="internal-link" title="sqlalchemy.orm.session.Session.hash_key">hash​_key</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#identity_map" class="internal-link" title="sqlalchemy.orm.session.Session.identity_map">identity​_map</a></code></td>
    <td>A mapping of object identities to objects themselves.</td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#twophase" class="internal-link" title="sqlalchemy.orm.session.Session.twophase">twophase</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="property">
    
    <td>Property</td>
    <td><code><a href="#deleted" class="internal-link" title="sqlalchemy.orm.session.Session.deleted">deleted</a></code></td>
    <td>The set of all instances marked as 'deleted' within this <tt class="rst-docutils literal">Session</tt></td>
  </tr><tr class="property">
    
    <td>Property</td>
    <td><code><a href="#dirty" class="internal-link" title="sqlalchemy.orm.session.Session.dirty">dirty</a></code></td>
    <td>The set of all persistent instances considered dirty.</td>
  </tr><tr class="property">
    
    <td>Property</td>
    <td><code><a href="#info" class="internal-link" title="sqlalchemy.orm.session.Session.info">info</a></code></td>
    <td>A user-modifiable dictionary.</td>
  </tr><tr class="property">
    
    <td>Property</td>
    <td><code><a href="#is_active" class="internal-link" title="sqlalchemy.orm.session.Session.is_active">is​_active</a></code></td>
    <td>True if this <code>.Session</code> not in "partial rollback" state.</td>
  </tr><tr class="property">
    
    <td>Property</td>
    <td><code><a href="#new" class="internal-link" title="sqlalchemy.orm.session.Session.new">new</a></code></td>
    <td>The set of all instances marked as 'new' within this <tt class="rst-docutils literal">Session</tt>.</td>
  </tr><tr class="property">
    
    <td>Property</td>
    <td><code><a href="#no_autoflush" class="internal-link" title="sqlalchemy.orm.session.Session.no_autoflush">no​_autoflush</a></code></td>
    <td>Return a context manager that disables autoflush.</td>
  </tr><tr class="property">
    
    <td>Property</td>
    <td><code><a href="#transaction" class="internal-link" title="sqlalchemy.orm.session.Session.transaction">transaction</a></code></td>
    <td>The current active or inactive <code>.SessionTransaction</code>.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_add_bind" class="internal-link" title="sqlalchemy.orm.session.Session._add_bind">​_add​_bind</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_after_attach" class="internal-link" title="sqlalchemy.orm.session.Session._after_attach">​_after​_attach</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_autobegin" class="internal-link" title="sqlalchemy.orm.session.Session._autobegin">​_autobegin</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_autoflush" class="internal-link" title="sqlalchemy.orm.session.Session._autoflush">​_autoflush</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_before_attach" class="internal-link" title="sqlalchemy.orm.session.Session._before_attach">​_before​_attach</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_bulk_save_mappings" class="internal-link" title="sqlalchemy.orm.session.Session._bulk_save_mappings">​_bulk​_save​_mappings</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_close_impl" class="internal-link" title="sqlalchemy.orm.session.Session._close_impl">​_close​_impl</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_conditional_expire" class="internal-link" title="sqlalchemy.orm.session.Session._conditional_expire">​_conditional​_expire</a></code></td>
    <td>Expire a state if persistent, else expunge if pending</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_connection_for_bind" class="internal-link" title="sqlalchemy.orm.session.Session._connection_for_bind">​_connection​_for​_bind</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_contains_state" class="internal-link" title="sqlalchemy.orm.session.Session._contains_state">​_contains​_state</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_delete_impl" class="internal-link" title="sqlalchemy.orm.session.Session._delete_impl">​_delete​_impl</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_expire_state" class="internal-link" title="sqlalchemy.orm.session.Session._expire_state">​_expire​_state</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_expunge_states" class="internal-link" title="sqlalchemy.orm.session.Session._expunge_states">​_expunge​_states</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_flush" class="internal-link" title="sqlalchemy.orm.session.Session._flush">​_flush</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_flush_warning" class="internal-link" title="sqlalchemy.orm.session.Session._flush_warning">​_flush​_warning</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_get_impl" class="internal-link" title="sqlalchemy.orm.session.Session._get_impl">​_get​_impl</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_identity_lookup" class="internal-link" title="sqlalchemy.orm.session.Session._identity_lookup">​_identity​_lookup</a></code></td>
    <td>Locate an object in the identity map.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_is_clean" class="internal-link" title="sqlalchemy.orm.session.Session._is_clean">​_is​_clean</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_legacy_transaction" class="internal-link" title="sqlalchemy.orm.session.Session._legacy_transaction">​_legacy​_transaction</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_maker_context_manager" class="internal-link" title="sqlalchemy.orm.session.Session._maker_context_manager">​_maker​_context​_manager</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_merge" class="internal-link" title="sqlalchemy.orm.session.Session._merge">​_merge</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_register_altered" class="internal-link" title="sqlalchemy.orm.session.Session._register_altered">​_register​_altered</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_register_persistent" class="internal-link" title="sqlalchemy.orm.session.Session._register_persistent">​_register​_persistent</a></code></td>
    <td>Register all persistent objects from a flush.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_remove_newly_deleted" class="internal-link" title="sqlalchemy.orm.session.Session._remove_newly_deleted">​_remove​_newly​_deleted</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_save_impl" class="internal-link" title="sqlalchemy.orm.session.Session._save_impl">​_save​_impl</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_save_or_update_impl" class="internal-link" title="sqlalchemy.orm.session.Session._save_or_update_impl">​_save​_or​_update​_impl</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_save_or_update_state" class="internal-link" title="sqlalchemy.orm.session.Session._save_or_update_state">​_save​_or​_update​_state</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_update_impl" class="internal-link" title="sqlalchemy.orm.session.Session._update_impl">​_update​_impl</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_validate_persistent" class="internal-link" title="sqlalchemy.orm.session.Session._validate_persistent">​_validate​_persistent</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable private">
    
    <td>Class Variable</td>
    <td><code><a href="#_is_asyncio" class="internal-link" title="sqlalchemy.orm.session.Session._is_asyncio">​_is​_asyncio</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable private">
    
    <td>Class Variable</td>
    <td><code><a href="#_trans_context_manager" class="internal-link" title="sqlalchemy.orm.session.Session._trans_context_manager">​_trans​_context​_manager</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#__binds" class="internal-link" title="sqlalchemy.orm.session.Session.__binds">__binds</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_deleted" class="internal-link" title="sqlalchemy.orm.session.Session._deleted">​_deleted</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_flushing" class="internal-link" title="sqlalchemy.orm.session.Session._flushing">​_flushing</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_nested_transaction" class="internal-link" title="sqlalchemy.orm.session.Session._nested_transaction">​_nested​_transaction</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_new" class="internal-link" title="sqlalchemy.orm.session.Session._new">​_new</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_query_cls" class="internal-link" title="sqlalchemy.orm.session.Session._query_cls">​_query​_cls</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_transaction" class="internal-link" title="sqlalchemy.orm.session.Session._transaction">​_transaction</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_warn_on_events" class="internal-link" title="sqlalchemy.orm.session.Session._warn_on_events">​_warn​_on​_events</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="property private">
    
    <td>Property</td>
    <td><code><a href="#_dirty_states" class="internal-link" title="sqlalchemy.orm.session.Session._dirty_states">​_dirty​_states</a></code></td>
    <td>The set of all persistent states considered dirty.</td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <code><a href="sqlalchemy.orm.session._SessionClassMethods.html" class="internal-link" title="sqlalchemy.orm.session._SessionClassMethods">_SessionClassMethods</a></code>:
          </p>
          <table class="children sortable" id="id17166">
  
  
  <tr class="baseclassmethod">
    
    <td>Class Method</td>
    <td><code><a href="sqlalchemy.orm.session._SessionClassMethods.html#close_all" class="internal-link" title="sqlalchemy.orm.session._SessionClassMethods.close_all">close​_all</a></code></td>
    <td>Close <em>all</em> sessions in memory.</td>
  </tr><tr class="baseclassmethod">
    
    <td>Class Method</td>
    <td><code><a href="sqlalchemy.orm.session._SessionClassMethods.html#identity_key" class="internal-link" title="sqlalchemy.orm.session._SessionClassMethods.identity_key">identity​_key</a></code></td>
    <td>Return an identity key.</td>
  </tr><tr class="baseclassmethod">
    
    <td>Class Method</td>
    <td><code><a href="sqlalchemy.orm.session._SessionClassMethods.html#object_session" class="internal-link" title="sqlalchemy.orm.session._SessionClassMethods.object_session">object​_session</a></code></td>
    <td>Return the <code>.Session</code> to which an object belongs.</td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.__contains__">
    
  </a>
  <a name="__contains__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__contains__</span>(self, instance):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return True if the instance is associated with this session.</p>
<p>The instance may be pending or persistent within the Session for a
result of True.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.__enter__">
    
  </a>
  <a name="__enter__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__enter__</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.__exit__">
    
  </a>
  <a name="__exit__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__exit__</span>(self, type_, value, traceback):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    @<a href="sqlalchemy.util.deprecations.html#deprecated_params" class="internal-link" title="sqlalchemy.util.deprecations.deprecated_params">util.deprecated_params</a>(<wbr></wbr>autocommit=(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">2.0</span><span class="rst-variable-quote">'</span>, <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">The :paramref:`.Session.autocommit` parameter is deprecated and will be removed in SQLAlchemy version 2.0.  The :class:`_orm.Session` now features "autobegin" behavior such that the :meth:`.Session.begin` method may be called if a transaction has not yet been started yet.  See the section :ref:`session_explicit_begin` for background.</span><span class="rst-variable-quote">'</span>))<br />
    <span class="py-keyword">def</span> <span class="py-defname">__init__</span>(self, bind=None, autoflush=True, future=False, expire_on_commit=True, autocommit=False, twophase=False, binds=None, enable_baked_queries=True, info=None, query_cls=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="sqlalchemy.ext.horizontal_shard.ShardedSession.html" class="internal-link">sqlalchemy.ext.horizontal_shard.ShardedSession</a></code></div>
    
    <div><p>Construct a new Session.</p>
<p>See also the <code>.sessionmaker</code> function which is used to
generate a <code>.Session</code>-producing callable with a given
set of arguments.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">bind</span></td><td class="fieldArgDesc">An optional <code>_engine.Engine</code> or
<code>_engine.Connection</code> to
which this <tt class="rst-docutils literal">Session</tt> should be bound. When specified, all SQL
operations performed by this session will execute via this
connectable.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">autoflush</span></td><td class="fieldArgDesc">When <tt class="rst-docutils literal">True</tt>, all query operations will issue a
<code>~.Session.flush</code> call to this <tt class="rst-docutils literal">Session</tt> before proceeding.
This is a convenience feature so that <code>~.Session.flush</code> need
not be called repeatedly in order for database queries to retrieve
results. It's typical that <tt class="rst-docutils literal">autoflush</tt> is used in conjunction
with <tt class="rst-docutils literal">autocommit=False</tt>. In this scenario, explicit calls to
<code>~.Session.flush</code> are rarely needed; you usually only need to
call <code>~.Session.commit</code> (which flushes) to finalize changes.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">future</span></td><td class="fieldArgDesc"><p>if True, use 2.0 style transactional and engine
behavior.  Future mode includes the following behaviors:</p>
<ul class="rst-simple">
<li>The <code>_orm.Session</code> will not use "bound" metadata in order
to locate an <code>_engine.Engine</code>; the engine or engines in use
must be specified to the constructor of <code>_orm.Session</code> or
otherwise be configured against the <code>_orm.sessionmaker</code>
in use</li>
<li>The "subtransactions" feature of <code>_orm.Session.begin</code> is
removed in version 2.0 and is disabled when the future flag is
set.</li>
<li>The behavior of the <a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:paramref:`_orm.relationship.cascade_backrefs`</span></a>
flag on a <code>_orm.relationship</code> will always assume
"False" behavior.</li>
</ul>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:ref:`migration_20_toplevel`</span></a></p>
</div>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">expire​_on​_commit</span></td><td class="fieldArgDesc"><p>Defaults to <tt class="rst-docutils literal">True</tt>. When <tt class="rst-docutils literal">True</tt>, all
instances will be fully expired after each <code>~.commit</code>,
so that all attribute/object access subsequent to a completed
transaction will load from the most recent database state.</p>
<blockquote>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`session_committing`</span></a></p>
</div>
</blockquote>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">autocommit</span></td><td class="fieldArgDesc">Defaults to <tt class="rst-docutils literal">False</tt>. When <tt class="rst-docutils literal">True</tt>, the
<code>.Session</code> does not automatically begin transactions for
individual statement executions, will acquire connections from the
engine on an as-needed basis, releasing to the connection pool
after each statement. Flushes will begin and commit (or possibly
rollback) their own transaction if no transaction is present.
When using this mode, the
<code>.Session.begin</code> method may be used to explicitly start
transactions, but the usual "autobegin" behavior is not present.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">twophase</span></td><td class="fieldArgDesc">When <tt class="rst-docutils literal">True</tt>, all transactions will be started as
a "two phase" transaction, i.e. using the "two phase" semantics
of the database in use along with an XID.  During a
<code>~.commit</code>, after <code>~.flush</code> has been issued for all
attached databases, the <code>~.TwoPhaseTransaction.prepare</code>
method on each database's <code>.TwoPhaseTransaction</code> will be
called. This allows each database to roll back the entire
transaction, before each transaction is committed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">binds</span></td><td class="fieldArgDesc"><p>A dictionary which may specify any number of
<code>_engine.Engine</code> or <code>_engine.Connection</code>
objects as the source of
connectivity for SQL operations on a per-entity basis.   The keys
of the dictionary consist of any series of mapped classes,
arbitrary Python classes that are bases for mapped classes,
<code>_schema.Table</code> objects and <code>_orm.Mapper</code> objects.
The
values of the dictionary are then instances of
<code>_engine.Engine</code>
or less commonly <code>_engine.Connection</code> objects.
Operations which
proceed relative to a particular mapped class will consult this
dictionary for the closest matching entity in order to determine
which <code>_engine.Engine</code> should be used for a particular SQL
operation.    The complete heuristics for resolution are
described at <code>.Session.get_bind</code>.  Usage looks like:</p>
<pre class="rst-literal-block">
Session = sessionmaker(binds={
    SomeMappedClass: create_engine('postgresql://engine1'),
    SomeDeclarativeBase: create_engine('postgresql://engine2'),
    some_mapper: create_engine('postgresql://engine3'),
    some_table: create_engine('postgresql://engine4'),
    })
</pre>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`session_partitioning`</span></a></p>
<p><code>.Session.bind_mapper</code></p>
<p><code>.Session.bind_table</code></p>
<p class="rst-last"><code>.Session.get_bind</code></p>
</div>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">enable​_baked​_queries</span></td><td class="fieldArgDesc"><p>defaults to <tt class="rst-docutils literal">True</tt>.  A flag consumed
by the <code><a href="sqlalchemy.ext.baked.html" class="internal-link">sqlalchemy.ext.baked</a></code> extension to determine if
"baked queries" should be cached, as is the normal operation
of this extension.  When set to <tt class="rst-docutils literal">False</tt>, caching as used by
this particular extension is disabled.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>The <tt class="rst-docutils literal">sqlalchemy.ext.baked</tt> extension is
legacy and is not used by any of SQLAlchemy's internals. This
flag therefore only affects applications that are making explicit
use of this extension within their own code.</span></div>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">info</span></td><td class="fieldArgDesc">optional dictionary of arbitrary data to be associated
with this <code>.Session</code>.  Is available via the
<code>.Session.info</code> attribute.  Note the dictionary is copied at
construction time so that modifications to the per-
<code>.Session</code> dictionary will be local to that
<code>.Session</code>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">query​_cls</span></td><td class="fieldArgDesc">Class which should be used to create new Query
objects, as returned by the <code>~.Session.query</code> method.
Defaults to <code>_query.Query</code>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">class​_</span></td><td class="fieldArgDesc">Specify an alternate class other than
<tt class="rst-docutils literal">sqlalchemy.orm.session.Session</tt> which should be used by the
returned class. This is the only argument that is local to the
<code>.sessionmaker</code> function, and is not sent directly to the
constructor for <tt class="rst-docutils literal">Session</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.__iter__">
    
  </a>
  <a name="__iter__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__iter__</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Iterate over all pending or persistent instances within this
Session.</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.add">
    
  </a>
  <a name="add">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">add</span>(self, instance, _warn=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Place an object in the <tt class="rst-docutils literal">Session</tt>.</p>
<p>Its state will be persisted to the database on the next flush
operation.</p>
<p>Repeated calls to <tt class="rst-docutils literal">add()</tt> will be ignored. The opposite of <tt class="rst-docutils literal">add()</tt>
is <tt class="rst-docutils literal">expunge()</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.add_all">
    
  </a>
  <a name="add_all">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">add_all</span>(self, instances):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Add the given collection of instances to this <tt class="rst-docutils literal">Session</tt>.</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.begin">
    
  </a>
  <a name="begin">
    
  </a>
  <div class="functionHeader">
    @<a href="sqlalchemy.util.deprecations.html#deprecated_params" class="internal-link" title="sqlalchemy.util.deprecations.deprecated_params">util.deprecated_params</a>(<wbr></wbr>subtransactions=(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">2.0</span><span class="rst-variable-quote">'</span>, <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">The :paramref:`_orm.Session.begin.subtransactions` flag is deprecated and will be removed in SQLAlchemy version 2.0.  See the documentation at :ref:`session_subtransactions` for background on a compatible alternative pattern.</span><span class="rst-variable-quote">'</span>))<br />
    <span class="py-keyword">def</span> <span class="py-defname">begin</span>(self, subtransactions=False, nested=False, _subtrans=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Begin a transaction, or nested transaction,
on this <code>.Session</code>, if one is not already begun.</p>
<p>The <code>_orm.Session</code> object features <strong>autobegin</strong> behavior,
so that normally it is not necessary to call the
<code>_orm.Session.begin</code>
method explicitly. However, it may be used in order to control
the scope of when the transactional state is begun.</p>
<p>When used to begin the outermost transaction, an error is raised
if this <code>.Session</code> is already inside of a transaction.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:ref:`session_autobegin`</span></a></p>
<p><a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:ref:`unitofwork_transaction`</span></a></p>
<p class="rst-last"><code>.Session.begin_nested</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">subtransactions</span></td><td class="fieldArgDesc">if True, indicates that this
<code>~.Session.begin</code> can create a "subtransaction".</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">nested</span></td><td class="fieldArgDesc">if True, begins a SAVEPOINT transaction and is
equivalent to calling <code>~.Session.begin_nested</code>. For
documentation on SAVEPOINT transactions, please see
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`session_begin_nested`</span></a>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">​_subtrans</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the <code>.SessionTransaction</code> object.  Note that
<code>.SessionTransaction</code>
acts as a Python context manager, allowing <code>.Session.begin</code>
to be used in a "with" block.  See <a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`session_autocommit`</span></a> for
an example.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.begin_nested">
    
  </a>
  <a name="begin_nested">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">begin_nested</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Begin a "nested" transaction on this Session, e.g. SAVEPOINT.</p>
<p>The target database(s) and associated drivers must support SQL
SAVEPOINT for this method to function correctly.</p>
<p>For documentation on SAVEPOINT
transactions, please see <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`session_begin_nested`</span></a>.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:ref:`session_begin_nested`</span></a></p>
<p class="rst-last"><a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:ref:`pysqlite_serializable`</span></a> - special workarounds required
with the SQLite driver in order for SAVEPOINT to work
correctly.</p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the <code>.SessionTransaction</code> object.  Note that
<code>.SessionTransaction</code> acts as a context manager, allowing
<code>.Session.begin_nested</code> to be used in a "with" block.
See <a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`session_begin_nested`</span></a> for a usage example.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.bind_mapper">
    
  </a>
  <a name="bind_mapper">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bind_mapper</span>(self, mapper, bind):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Associate a <code>_orm.Mapper</code> or arbitrary Python class with a
"bind", e.g. an <code>_engine.Engine</code> or
<code>_engine.Connection</code>.</p>
<p>The given entity is added to a lookup used by the
<code>.Session.get_bind</code> method.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`session_partitioning`</span></a></p>
<p><a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`.Session.binds`</span></a></p>
<p class="rst-last"><code>.Session.bind_table</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mapper</span></td><td class="fieldArgDesc">a <code>_orm.Mapper</code> object,
or an instance of a mapped
class, or any Python class that is the base of a set of mapped
classes.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">bind</span></td><td class="fieldArgDesc">an <code>_engine.Engine</code> or <code>_engine.Connection</code>
object.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.bind_table">
    
  </a>
  <a name="bind_table">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bind_table</span>(self, table, bind):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Associate a <code>_schema.Table</code> with a "bind", e.g. an
<code>_engine.Engine</code>
or <code>_engine.Connection</code>.</p>
<p>The given <code>_schema.Table</code> is added to a lookup used by the
<code>.Session.get_bind</code> method.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`session_partitioning`</span></a></p>
<p><a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`.Session.binds`</span></a></p>
<p class="rst-last"><code>.Session.bind_mapper</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">table</span></td><td class="fieldArgDesc">a <code>_schema.Table</code> object,
which is typically the target
of an ORM mapping, or is present within a selectable that is
mapped.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">bind</span></td><td class="fieldArgDesc">an <code>_engine.Engine</code> or <code>_engine.Connection</code>
object.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.bulk_insert_mappings">
    
  </a>
  <a name="bulk_insert_mappings">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bulk_insert_mappings</span>(self, mapper, mappings, return_defaults=False, render_nulls=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Perform a bulk insert of the given list of mapping dictionaries.</p>
<p>The bulk insert feature allows plain Python dictionaries to be used as
the source of simple INSERT operations which can be more easily
grouped together into higher performing "executemany"
operations.  Using dictionaries, there is no "history" or session
state management features in use, reducing latency when inserting
large numbers of simple rows.</p>
<p>The values within the dictionaries as given are typically passed
without modification into Core <code>_expression.Insert</code> constructs,
after
organizing the values within them across the tables to which
the given mapper is mapped.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.0.0.</span></div>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p>The bulk insert feature allows for a lower-latency INSERT
of rows at the expense of most other unit-of-work features.
Features such as object management, relationship handling,
and SQL clause support are <strong>silently omitted</strong> in favor of raw
INSERT of records.</p>
<p>Please note that newer versions of SQLAlchemy are <strong>greatly
improving the efficiency</strong> of the standard flush process. It is
<strong>strongly recommended</strong> to not use the bulk methods as they
represent a forking of SQLAlchemy's functionality and are slowly
being moved into legacy status.  New features such as
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`orm_dml_returning_objects`</span></a> are both more efficient than
the "bulk" methods and provide more predictable functionality.</p>
<p class="rst-last"><strong>Please read the list of caveats at</strong>
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`bulk_operations_caveats`</span></a> <strong>before using this method, and
fully test and confirm the functionality of all code developed
using these systems.</strong></p>
</div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:ref:`bulk_operations`</span></a></p>
<p><code>.Session.bulk_save_objects</code></p>
<p class="rst-last"><code>.Session.bulk_update_mappings</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mapper</span></td><td class="fieldArgDesc">a mapped class, or the actual <code>_orm.Mapper</code>
object,
representing the single kind of object represented within the mapping
list.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mappings</span></td><td class="fieldArgDesc">a sequence of dictionaries, each one containing the
state of the mapped row to be inserted, in terms of the attribute
names on the mapped class.   If the mapping refers to multiple tables,
such as a joined-inheritance mapping, each dictionary must contain all
keys to be populated into all tables.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return​_defaults</span></td><td class="fieldArgDesc">when True, rows that are missing values which
generate defaults, namely integer primary key defaults and sequences,
will be inserted <strong>one at a time</strong>, so that the primary key value
is available.  In particular this will allow joined-inheritance
and other multi-table mappings to insert correctly without the need
to provide primary
key values ahead of time; however,
<a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:paramref:`.Session.bulk_insert_mappings.return_defaults`</span></a>
<strong>greatly reduces the performance gains</strong> of the method overall.
If the rows
to be inserted only refer to a single table, then there is no
reason this flag should be set as the returned default information
is not used.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">render​_nulls</span></td><td class="fieldArgDesc"><p>When True, a value of <tt class="rst-docutils literal">None</tt> will result
in a NULL value being included in the INSERT statement, rather
than the column being omitted from the INSERT.   This allows all
the rows being INSERTed to have the identical set of columns which
allows the full set of rows to be batched to the DBAPI.  Normally,
each column-set that contains a different combination of NULL values
than the previous row must omit a different series of columns from
the rendered INSERT statement, which means it must be emitted as a
separate statement.   By passing this flag, the full set of rows
are guaranteed to be batchable into one batch; the cost however is
that server-side defaults which are invoked by an omitted column will
be skipped, so care must be taken to ensure that these are not
necessary.</p>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p class="rst-last">When this flag is set, <strong>server side default SQL values will
not be invoked</strong> for those columns that are inserted as NULL;
the NULL value will be sent explicitly.   Care must be taken
to ensure that no server-side default functions need to be
invoked for the operation as a whole.</p>
</div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.1.</span></div>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.bulk_save_objects">
    
  </a>
  <a name="bulk_save_objects">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bulk_save_objects</span>(self, objects, return_defaults=False, update_changed_only=True, preserve_order=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Perform a bulk save of the given list of objects.</p>
<p>The bulk save feature allows mapped objects to be used as the
source of simple INSERT and UPDATE operations which can be more easily
grouped together into higher performing "executemany"
operations; the extraction of data from the objects is also performed
using a lower-latency process that ignores whether or not attributes
have actually been modified in the case of UPDATEs, and also ignores
SQL expressions.</p>
<p>The objects as given are not added to the session and no additional
state is established on them. If the
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`_orm.Session.bulk_save_objects.return_defaults`</span></a> flag is set,
then server-generated primary key values will be assigned to the
returned objects, but <strong>not server side defaults</strong>; this is a
limitation in the implementation. If stateful objects are desired,
please use the standard <code>_orm.Session.add_all</code> approach or
as an alternative newer mass-insert features such as
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`orm_dml_returning_objects`</span></a>.</p>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p>The bulk save feature allows for a lower-latency INSERT/UPDATE
of rows at the expense of most other unit-of-work features.
Features such as object management, relationship handling,
and SQL clause support are <strong>silently omitted</strong> in favor of raw
INSERT/UPDATES of records.</p>
<p>Please note that newer versions of SQLAlchemy are <strong>greatly
improving the efficiency</strong> of the standard flush process. It is
<strong>strongly recommended</strong> to not use the bulk methods as they
represent a forking of SQLAlchemy's functionality and are slowly
being moved into legacy status.  New features such as
<a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:ref:`orm_dml_returning_objects`</span></a> are both more efficient than
the "bulk" methods and provide more predictable functionality.</p>
<p class="rst-last"><strong>Please read the list of caveats at</strong>
<a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:ref:`bulk_operations_caveats`</span></a> <strong>before using this method, and
fully test and confirm the functionality of all code developed
using these systems.</strong></p>
</div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-6"><span class="rst-problematic" id="rst-problematic-6">:ref:`bulk_operations`</span></a></p>
<p><code>.Session.bulk_insert_mappings</code></p>
<p class="rst-last"><code>.Session.bulk_update_mappings</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">objects</span></td><td class="fieldArgDesc"><p>a sequence of mapped object instances.  The mapped
objects are persisted as is, and are <strong>not</strong> associated with the
<code>.Session</code> afterwards.</p>
<p>For each object, whether the object is sent as an INSERT or an
UPDATE is dependent on the same rules used by the <code>.Session</code>
in traditional operation; if the object has the
<code>.InstanceState.key</code>
attribute set, then the object is assumed to be "detached" and
will result in an UPDATE.  Otherwise, an INSERT is used.</p>
<p>In the case of an UPDATE, statements are grouped based on which
attributes have changed, and are thus to be the subject of each
SET clause.  If <tt class="rst-docutils literal">update_changed_only</tt> is False, then all
attributes present within each object are applied to the UPDATE
statement, which may help in allowing the statements to be grouped
together into a larger executemany(), and will also reduce the
overhead of checking history on attributes.</p>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return​_defaults</span></td><td class="fieldArgDesc">when True, rows that are missing values which
generate defaults, namely integer primary key defaults and sequences,
will be inserted <strong>one at a time</strong>, so that the primary key value
is available.  In particular this will allow joined-inheritance
and other multi-table mappings to insert correctly without the need
to provide primary key values ahead of time; however,
<a href="#system-message-5"><span class="rst-problematic" id="rst-problematic-5">:paramref:`.Session.bulk_save_objects.return_defaults`</span></a> <strong>greatly
reduces the performance gains</strong> of the method overall.  It is strongly
advised to please use the standard <code>_orm.Session.add_all</code>
approach.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">update​_changed​_only</span></td><td class="fieldArgDesc">when True, UPDATE statements are rendered
based on those attributes in each state that have logged changes.
When False, all attributes present are rendered into the SET clause
with the exception of primary key attributes.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">preserve​_order</span></td><td class="fieldArgDesc"><p>when True, the order of inserts and updates
matches exactly the order in which the objects are given.   When
False, common types of objects are grouped into inserts
and updates, to allow for more batching opportunities.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.3.</span></div>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.bulk_update_mappings">
    
  </a>
  <a name="bulk_update_mappings">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bulk_update_mappings</span>(self, mapper, mappings):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Perform a bulk update of the given list of mapping dictionaries.</p>
<p>The bulk update feature allows plain Python dictionaries to be used as
the source of simple UPDATE operations which can be more easily
grouped together into higher performing "executemany"
operations.  Using dictionaries, there is no "history" or session
state management features in use, reducing latency when updating
large numbers of simple rows.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.0.0.</span></div>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p>The bulk update feature allows for a lower-latency UPDATE
of rows at the expense of most other unit-of-work features.
Features such as object management, relationship handling,
and SQL clause support are <strong>silently omitted</strong> in favor of raw
UPDATES of records.</p>
<p>Please note that newer versions of SQLAlchemy are <strong>greatly
improving the efficiency</strong> of the standard flush process. It is
<strong>strongly recommended</strong> to not use the bulk methods as they
represent a forking of SQLAlchemy's functionality and are slowly
being moved into legacy status.  New features such as
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`orm_dml_returning_objects`</span></a> are both more efficient than
the "bulk" methods and provide more predictable functionality.</p>
<p class="rst-last"><strong>Please read the list of caveats at</strong>
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`bulk_operations_caveats`</span></a> <strong>before using this method, and
fully test and confirm the functionality of all code developed
using these systems.</strong></p>
</div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:ref:`bulk_operations`</span></a></p>
<p><code>.Session.bulk_insert_mappings</code></p>
<p class="rst-last"><code>.Session.bulk_save_objects</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mapper</span></td><td class="fieldArgDesc">a mapped class, or the actual <code>_orm.Mapper</code>
object,
representing the single kind of object represented within the mapping
list.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mappings</span></td><td class="fieldArgDesc">a sequence of dictionaries, each one containing the
state of the mapped row to be updated, in terms of the attribute names
on the mapped class.   If the mapping refers to multiple tables, such
as a joined-inheritance mapping, each dictionary may contain keys
corresponding to all tables.   All those keys which are present and
are not part of the primary key are applied to the SET clause of the
UPDATE statement; the primary key values, which are required, are
applied to the WHERE clause.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.close">
    
  </a>
  <a name="close">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">close</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Close out the transactional resources and ORM objects used by this
<code>_orm.Session</code>.</p>
<p>This expunges all ORM objects associated with this
<code>_orm.Session</code>, ends any transaction in progress and
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:term:`releases`</span></a> any <code>_engine.Connection</code> objects which this
<code>_orm.Session</code> itself has checked out from associated
<code>_engine.Engine</code> objects. The operation then leaves the
<code>_orm.Session</code> in a state which it may be used again.</p>
<div class="rst-admonition tip">
<p class="rst-first rst-admonition-title">Tip</p>
<p class="rst-last">The <code>_orm.Session.close</code> method <strong>does not prevent the
Session from being used again</strong>.   The <code>_orm.Session</code> itself
does not actually have a distinct "closed" state; it merely means
the <code>_orm.Session</code> will release all database connections
and ORM objects.</p>
</div>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>The <code>.Session.close</code> method does not
immediately create a new <code>.SessionTransaction</code> object;
instead, the new <code>.SessionTransaction</code> is created only if
the <code>.Session</code> is used again for a database operation.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`session_closing`</span></a> - detail on the semantics of
<code>_orm.Session.close</code></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.commit">
    
  </a>
  <a name="commit">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">commit</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Flush pending changes and commit the current transaction.</p>
<p>If no transaction is in progress, the method will first
"autobegin" a new transaction and commit.</p>
<p>If <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:term:`1.x-style`</span></a> use is in effect and there are currently
SAVEPOINTs in progress via <code>_orm.Session.begin_nested</code>,
the operation will release the current SAVEPOINT but not commit
the outermost database transaction.</p>
<p>If <a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:term:`2.0-style`</span></a> use is in effect via the
<a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:paramref:`_orm.Session.future`</span></a> flag, the outermost database
transaction is committed unconditionally, automatically releasing any
SAVEPOINTs in effect.</p>
<p>When using legacy "autocommit" mode, this method is only
valid to call if a transaction is actually in progress, else
an error is raised.   Similarly, when using legacy "subtransactions",
the method will instead close out the current "subtransaction",
rather than the actual database transaction, if a transaction
is in progress.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:ref:`session_committing`</span></a></p>
<p class="rst-last"><a href="#system-message-5"><span class="rst-problematic" id="rst-problematic-5">:ref:`unitofwork_transaction`</span></a></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.connection">
    
  </a>
  <a name="connection">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">connection</span>(self, bind_arguments=None, close_with_result=False, execution_options=None, **kw):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a <code>_engine.Connection</code> object corresponding to this
<code>.Session</code> object's transactional state.</p>
<p>If this <code>.Session</code> is configured with <tt class="rst-docutils literal">autocommit=False</tt>,
either the <code>_engine.Connection</code> corresponding to the current
transaction is returned, or if no transaction is in progress, a new
one is begun and the <code>_engine.Connection</code>
returned (note that no
transactional state is established with the DBAPI until the first
SQL statement is emitted).</p>
<p>Alternatively, if this <code>.Session</code> is configured with
<tt class="rst-docutils literal">autocommit=True</tt>, an ad-hoc <code>_engine.Connection</code> is returned
using <code>_engine.Engine.connect</code> on the underlying
<code>_engine.Engine</code>.</p>
<p>Ambiguity in multi-bind or unbound <code>.Session</code> objects can be
resolved through any of the optional keyword arguments.   This
ultimately makes usage of the <code>.get_bind</code> method for resolution.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">bind​_arguments</span></td><td class="fieldArgDesc">dictionary of bind arguments.  May include
"mapper", "bind", "clause", other custom arguments that are passed
to <code>.Session.get_bind</code>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">close​_with​_result</span></td><td class="fieldArgDesc"><p>Passed to <code>_engine.Engine.connect</code>,
indicating the <code>_engine.Connection</code> should be considered
"single use", automatically closing when the first result set is
closed.  This flag only has an effect if this <code>.Session</code> is
configured with <tt class="rst-docutils literal">autocommit=True</tt> and does not already have a
transaction in progress.</p>
<div class="rst-deprecated">
<span class="rst-versionmodified rst-deprecated">Deprecated since version 1.4: </span><span>this parameter is deprecated and will be removed
in SQLAlchemy 2.0</span></div>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">execution​_options</span></td><td class="fieldArgDesc"><p>a dictionary of execution options that will
be passed to <code>_engine.Connection.execution_options</code>, <strong>when the
connection is first procured only</strong>.   If the connection is already
present within the <code>.Session</code>, a warning is emitted and
the arguments are ignored.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`session_transaction_isolation`</span></a></p>
</div>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kw</span></td><td class="fieldArgDesc">deprecated; use bind_arguments</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">bind</span></td><td class="fieldArgDesc">deprecated; use bind_arguments</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mapper</span></td><td class="fieldArgDesc">deprecated; use bind_arguments</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">clause</span></td><td class="fieldArgDesc">deprecated; use bind_arguments</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.delete">
    
  </a>
  <a name="delete">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">delete</span>(self, instance):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Mark an instance as deleted.</p>
<p>The database delete operation occurs upon <tt class="rst-docutils literal">flush()</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.enable_relationship_loading">
    
  </a>
  <a name="enable_relationship_loading">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">enable_relationship_loading</span>(self, obj):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Associate an object with this <code>.Session</code> for related
object loading.</p>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p class="rst-last"><code>.enable_relationship_loading</code> exists to serve special
use cases and is not recommended for general use.</p>
</div>
<p>Accesses of attributes mapped with <code>_orm.relationship</code>
will attempt to load a value from the database using this
<code>.Session</code> as the source of connectivity.  The values
will be loaded based on foreign key and primary key values
present on this object - if not present, then those relationships
will be unavailable.</p>
<p>The object will be attached to this session, but will
<strong>not</strong> participate in any persistence operations; its state
for almost all purposes will remain either "transient" or
"detached", except for the case of relationship loading.</p>
<p>Also note that backrefs will often not work as expected.
Altering a relationship-bound attribute on the target object
may not fire off a backref event, if the effective value
is what was already loaded from a foreign-key-holding value.</p>
<p>The <code>.Session.enable_relationship_loading</code> method is
similar to the <tt class="rst-docutils literal">load_on_pending</tt> flag on <code>_orm.relationship</code>.
Unlike that flag, <code>.Session.enable_relationship_loading</code> allows
an object to remain transient while still being able to load
related items.</p>
<p>To make a transient object associated with a <code>.Session</code>
via <code>.Session.enable_relationship_loading</code> pending, add
it to the <code>.Session</code> using <code>.Session.add</code> normally.
If the object instead represents an existing identity in the database,
it should be merged using <code>.Session.merge</code>.</p>
<p><code>.Session.enable_relationship_loading</code> does not improve
behavior when the ORM is used normally - object references should be
constructed at the object level, not at the foreign key level, so
that they are present in an ordinary way before flush()
proceeds.  This method is not intended for general use.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`_orm.relationship.load_on_pending`</span></a> - this flag
allows per-relationship loading of many-to-ones on items that
are pending.</p>
<p class="rst-last"><code>.make_transient_to_detached</code> - allows for an object to
be added to a <code>.Session</code> without SQL emitted, which then
will unexpire attributes on access.</p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.execute">
    
  </a>
  <a name="execute">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">execute</span>(self, statement, params=None, execution_options=<a href="sqlalchemy.util._collections.html#EMPTY_DICT" class="internal-link" title="sqlalchemy.util._collections.EMPTY_DICT">util.EMPTY_DICT</a>, bind_arguments=None, _parent_execute_state=None, _add_event=None, **kw):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Execute a SQL expression construct.</p>
<p>Returns a <code>_engine.Result</code> object representing
results of the statement execution.</p>
<p>E.g.:</p>
<pre class="rst-literal-block">
from sqlalchemy import select
result = session.execute(
    select(User).where(User.id == 5)
)
</pre>
<p>The API contract of <code>_orm.Session.execute</code> is similar to that
of <code>_future.Connection.execute</code>, the <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:term:`2.0 style`</span></a> version
of <code>_future.Connection</code>.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>the <code>_orm.Session.execute</code> method is
now the primary point of ORM statement execution when using
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:term:`2.0 style`</span></a> ORM usage.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">statement</span></td><td class="fieldArgDesc">An executable statement (i.e. an <code>.Executable</code> expression
such as <code>_expression.select</code>).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">params</span></td><td class="fieldArgDesc">Optional dictionary, or list of dictionaries, containing
bound parameter values.   If a single dictionary, single-row
execution occurs; if a list of dictionaries, an
"executemany" will be invoked.  The keys in each dictionary
must correspond to parameter names present in the statement.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">execution​_options</span></td><td class="fieldArgDesc">optional dictionary of execution options,
which will be associated with the statement execution.  This
dictionary can provide a subset of the options that are accepted
by <code>_engine.Connection.execution_options</code>, and may also
provide additional options understood only in an ORM context.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">bind​_arguments</span></td><td class="fieldArgDesc">dictionary of additional arguments to determine
the bind.  May include "mapper", "bind", or other custom arguments.
Contents of this dictionary are passed to the
<code>.Session.get_bind</code> method.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">​_parent​_execute​_state</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">​_add​_event</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kw</span></td><td class="fieldArgDesc">deprecated; use the bind_arguments dictionary</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mapper</span></td><td class="fieldArgDesc">deprecated; use the bind_arguments dictionary</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">bind</span></td><td class="fieldArgDesc">deprecated; use the bind_arguments dictionary</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code>_engine.Result</code> object.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.expire">
    
  </a>
  <a name="expire">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">expire</span>(self, instance, attribute_names=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Expire the attributes on an instance.</p>
<p>Marks the attributes of an instance as out of date. When an expired
attribute is next accessed, a query will be issued to the
<code>.Session</code> object's current transactional context in order to
load all expired attributes for the given instance.   Note that
a highly isolated transaction will return the same values as were
previously read in that same transaction, regardless of changes
in database state outside of that transaction.</p>
<p>To expire all objects in the <code>.Session</code> simultaneously,
use <code><a href="#expire_all" class="internal-link" title="sqlalchemy.orm.session.Session.expire_all">Session.expire_all</a></code>.</p>
<p>The <code>.Session</code> object's default behavior is to
expire all state whenever the <code><a href="#rollback" class="internal-link" title="sqlalchemy.orm.session.Session.rollback">Session.rollback</a></code>
or <code><a href="#commit" class="internal-link" title="sqlalchemy.orm.session.Session.commit">Session.commit</a></code> methods are called, so that new
state can be loaded for the new transaction.   For this reason,
calling <code><a href="#expire" class="internal-link" title="sqlalchemy.orm.session.Session.expire">Session.expire</a></code> only makes sense for the specific
case that a non-ORM SQL statement was emitted in the current
transaction.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`session_expire`</span></a> - introductory material</p>
<p><code>.Session.expire</code></p>
<p><code>.Session.refresh</code></p>
<p class="rst-last"><code>_orm.Query.populate_existing</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">instance</span></td><td class="fieldArgDesc">The instance to be refreshed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">attribute​_names</span></td><td class="fieldArgDesc">optional list of string attribute names
indicating a subset of attributes to be expired.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.expire_all">
    
  </a>
  <a name="expire_all">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">expire_all</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Expires all persistent instances within this Session.</p>
<p>When any attributes on a persistent instance is next accessed,
a query will be issued using the
<code>.Session</code> object's current transactional context in order to
load all expired attributes for the given instance.   Note that
a highly isolated transaction will return the same values as were
previously read in that same transaction, regardless of changes
in database state outside of that transaction.</p>
<p>To expire individual objects and individual attributes
on those objects, use <code><a href="#expire" class="internal-link" title="sqlalchemy.orm.session.Session.expire">Session.expire</a></code>.</p>
<p>The <code>.Session</code> object's default behavior is to
expire all state whenever the <code><a href="#rollback" class="internal-link" title="sqlalchemy.orm.session.Session.rollback">Session.rollback</a></code>
or <code><a href="#commit" class="internal-link" title="sqlalchemy.orm.session.Session.commit">Session.commit</a></code> methods are called, so that new
state can be loaded for the new transaction.   For this reason,
calling <code><a href="#expire_all" class="internal-link" title="sqlalchemy.orm.session.Session.expire_all">Session.expire_all</a></code> should not be needed when
autocommit is <tt class="rst-docutils literal">False</tt>, assuming the transaction is isolated.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`session_expire`</span></a> - introductory material</p>
<p><code>.Session.expire</code></p>
<p><code>.Session.refresh</code></p>
<p class="rst-last"><code>_orm.Query.populate_existing</code></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.expunge">
    
  </a>
  <a name="expunge">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">expunge</span>(self, instance):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Remove the <code>instance</code> from this <tt class="rst-docutils literal">Session</tt>.</p>
<p>This will free all internal references to the instance.  Cascading
will be applied according to the <em>expunge</em> cascade rule.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.expunge_all">
    
  </a>
  <a name="expunge_all">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">expunge_all</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Remove all object instances from this <tt class="rst-docutils literal">Session</tt>.</p>
<p>This is equivalent to calling <tt class="rst-docutils literal">expunge(obj)</tt> on all objects in this
<tt class="rst-docutils literal">Session</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.flush">
    
  </a>
  <a name="flush">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">flush</span>(self, objects=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Flush all the object changes to the database.</p>
<p>Writes out all pending object creations, deletions and modifications
to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
automatically ordered by the Session's unit of work dependency
solver.</p>
<p>Database operations will be issued in the current transactional
context and do not affect the state of the transaction, unless an
error occurs, in which case the entire transaction is rolled back.
You may flush() as often as you like within a transaction to move
changes from Python to the database's transaction buffer.</p>
<p>For <tt class="rst-docutils literal">autocommit</tt> Sessions with no active manual transaction, flush()
will create a transaction on the fly that surrounds the entire set of
operations into the flush.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">objects</span></td><td class="fieldArgDesc"><p>Optional; restricts the flush operation to operate
only on elements that are in the given collection.</p>
<p>This feature is for an extremely narrow set of use cases where
particular objects may need to be operated upon before the
full flush() occurs.  It is not intended for general use.</p>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.get">
    
  </a>
  <a name="get">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get</span>(self, entity, ident, options=None, populate_existing=False, with_for_update=None, identity_token=None, execution_options=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return an instance based on the given primary key identifier,
or <tt class="rst-docutils literal">None</tt> if not found.</p>
<p>E.g.:</p>
<pre class="rst-literal-block">
my_user = session.get(User, 5)

some_object = session.get(VersionedFoo, (5, 10))

some_object = session.get(
    VersionedFoo,
    {"id": 5, "version_id": 10}
)
</pre>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4: </span><span>Added <code>_orm.Session.get</code>, which is moved
from the now deprecated <code>_orm.Query.get</code> method.</span></div>
<p><code>_orm.Session.get</code> is special in that it provides direct
access to the identity map of the <code>.Session</code>.
If the given primary key identifier is present
in the local identity map, the object is returned
directly from this collection and no SQL is emitted,
unless the object has been marked fully expired.
If not present,
a SELECT is performed in order to locate the object.</p>
<p><code>_orm.Session.get</code> also will perform a check if
the object is present in the identity map and
marked as expired - a SELECT
is emitted to refresh the object as well as to
ensure that the row is still present.
If not, <code>~sqlalchemy.orm.exc.ObjectDeletedError</code> is raised.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">entity</span></td><td class="fieldArgDesc">a mapped class or <code>.Mapper</code> indicating the
type of entity to be loaded.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ident</span></td><td class="fieldArgDesc"><p>A scalar, tuple, or dictionary representing the
primary key.  For a composite (e.g. multiple column) primary key,
a tuple or dictionary should be passed.</p>
<p>For a single-column primary key, the scalar calling form is typically
the most expedient.  If the primary key of a row is the value "5",
the call looks like:</p>
<pre class="rst-literal-block">
my_object = session.get(SomeClass, 5)
</pre>
<p>The tuple form contains primary key values typically in
the order in which they correspond to the mapped
<code>_schema.Table</code>
object's primary key columns, or if the
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`_orm.Mapper.primary_key`</span></a> configuration parameter were
used, in
the order used for that parameter. For example, if the primary key
of a row is represented by the integer
digits "5, 10" the call would look like:</p>
<pre class="rst-literal-block">
my_object = session.get(SomeClass, (5, 10))
</pre>
<p>The dictionary form should include as keys the mapped attribute names
corresponding to each element of the primary key.  If the mapped class
has the attributes <tt class="rst-docutils literal">id</tt>, <tt class="rst-docutils literal">version_id</tt> as the attributes which
store the object's primary key value, the call would look like:</p>
<pre class="rst-literal-block">
my_object = session.get(SomeClass, {"id": 5, "version_id": 10})
</pre>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">options</span></td><td class="fieldArgDesc">optional sequence of loader options which will be
applied to the query, if one is emitted.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">populate​_existing</span></td><td class="fieldArgDesc">causes the method to unconditionally emit
a SQL query and refresh the object with the newly loaded data,
regardless of whether or not the object is already present.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">with​_for​_update</span></td><td class="fieldArgDesc">optional boolean <tt class="rst-docutils literal">True</tt> indicating FOR UPDATE
should be used, or may be a dictionary containing flags to
indicate a more specific set of FOR UPDATE flags for the SELECT;
flags should match the parameters of
<code>_query.Query.with_for_update</code>.
Supersedes the <a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`.Session.refresh.lockmode`</span></a> parameter.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">identity​_token</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">execution​_options</span></td><td class="fieldArgDesc"><p>optional dictionary of execution options,
which will be associated with the query execution if one is emitted.
This dictionary can provide a subset of the options that are
accepted by <code>_engine.Connection.execution_options</code>, and may
also provide additional options understood only in an ORM context.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.29.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:ref:`orm_queryguide_execution_options`</span></a> - ORM-specific execution
options</p>
</div>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">The object instance, or <tt class="rst-docutils literal">None</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.get_bind">
    
  </a>
  <a name="get_bind">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_bind</span>(self, mapper=None, clause=None, bind=None, _sa_skip_events=None, _sa_skip_for_implicit_returning=False):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="sqlalchemy.ext.horizontal_shard.ShardedSession.html" class="internal-link">sqlalchemy.ext.horizontal_shard.ShardedSession</a></code></div>
    
    <div><p>Return a "bind" to which this <code>.Session</code> is bound.</p>
<p>The "bind" is usually an instance of <code>_engine.Engine</code>,
except in the case where the <code>.Session</code> has been
explicitly bound directly to a <code>_engine.Connection</code>.</p>
<p>For a multiply-bound or unbound <code>.Session</code>, the
<tt class="rst-docutils literal">mapper</tt> or <tt class="rst-docutils literal">clause</tt> arguments are used to determine the
appropriate bind to return.</p>
<p>Note that the "mapper" argument is usually present
when <code>.Session.get_bind</code> is called via an ORM
operation such as a <code>.Session.query</code>, each
individual INSERT/UPDATE/DELETE operation within a
<code>.Session.flush</code>, call, etc.</p>
<p>The order of resolution is:</p>
<ol class="rst-arabic simple">
<li>if mapper given and <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:paramref:`.Session.binds`</span></a> is present,
locate a bind based first on the mapper in use, then
on the mapped class in use, then on any base classes that are
present in the <tt class="rst-docutils literal">__mro__</tt> of the mapped class, from more specific
superclasses to more general.</li>
<li>if clause given and <tt class="rst-docutils literal">Session.binds</tt> is present,
locate a bind based on <code>_schema.Table</code> objects
found in the given clause present in <tt class="rst-docutils literal">Session.binds</tt>.</li>
<li>if <tt class="rst-docutils literal">Session.binds</tt> is present, return that.</li>
<li>if clause given, attempt to return a bind
linked to the <code>_schema.MetaData</code> ultimately
associated with the clause.</li>
<li>if mapper given, attempt to return a bind
linked to the <code>_schema.MetaData</code> ultimately
associated with the <code>_schema.Table</code> or other
selectable to which the mapper is mapped.</li>
<li>No bind can be found, <code>~sqlalchemy.exc.UnboundExecutionError</code>
is raised.</li>
</ol>
<p>Note that the <code>.Session.get_bind</code> method can be overridden on
a user-defined subclass of <code>.Session</code> to provide any kind
of bind resolution scheme.  See the example at
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`session_custom_partitioning`</span></a>.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:ref:`session_partitioning`</span></a></p>
<p><a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:paramref:`.Session.binds`</span></a></p>
<p><code>.Session.bind_mapper</code></p>
<p class="rst-last"><code>.Session.bind_table</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mapper</span></td><td class="fieldArgDesc">Optional <code>.mapper</code> mapped class or instance of
<code>_orm.Mapper</code>.   The bind can be derived from a
<code>_orm.Mapper</code>
first by consulting the "binds" map associated with this
<code>.Session</code>, and secondly by consulting the
<code>_schema.MetaData</code>
associated with the <code>_schema.Table</code> to which the
<code>_orm.Mapper</code>
is mapped for a bind.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">clause</span></td><td class="fieldArgDesc">A <code>_expression.ClauseElement</code> (i.e.
<code>_expression.select</code>,
<code>_expression.text</code>,
etc.).  If the <tt class="rst-docutils literal">mapper</tt> argument is not present or could not
produce a bind, the given expression construct will be searched
for a bound element, typically a <code>_schema.Table</code>
associated with
bound <code>_schema.MetaData</code>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">bind</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">​_sa​_skip​_events</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">​_sa​_skip​_for​_implicit​_returning</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.get_nested_transaction">
    
  </a>
  <a name="get_nested_transaction">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_nested_transaction</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the current nested transaction in progress, if any.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.</span></div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.get_transaction">
    
  </a>
  <a name="get_transaction">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_transaction</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the current root transaction in progress, if any.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.</span></div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.in_nested_transaction">
    
  </a>
  <a name="in_nested_transaction">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">in_nested_transaction</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return True if this <code>_orm.Session</code> has begun a nested
transaction, e.g. SAVEPOINT.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.</span></div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.in_transaction">
    
  </a>
  <a name="in_transaction">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">in_transaction</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return True if this <code>_orm.Session</code> has begun a transaction.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>_orm.Session.is_active</code></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.invalidate">
    
  </a>
  <a name="invalidate">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">invalidate</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Close this Session, using connection invalidation.</p>
<p>This is a variant of <code>.Session.close</code> that will additionally
ensure that the <code>_engine.Connection.invalidate</code>
method will be called on each <code>_engine.Connection</code> object
that is currently in use for a transaction (typically there is only
one connection unless the <code>_orm.Session</code> is used with
multiple engines).</p>
<p>This can be called when the database is known to be in a state where
the connections are no longer safe to be used.</p>
<p>Below illustrates a scenario when using <a class="rst-reference external" href="https://www.gevent.org/" target="_top">gevent</a>, which can produce <tt class="rst-docutils literal">Timeout</tt> exceptions
that may mean the underlying connection should be discarded:</p>
<pre class="rst-literal-block">
import gevent

try:
    sess = Session()
    sess.add(User())
    sess.commit()
except gevent.Timeout:
    sess.invalidate()
    raise
except:
    sess.rollback()
    raise
</pre>
<p>The method additionally does everything that <code>_orm.Session.close</code>
does, including that all ORM objects are expunged.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.is_modified">
    
  </a>
  <a name="is_modified">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_modified</span>(self, instance, include_collections=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return <tt class="rst-docutils literal">True</tt> if the given instance has locally
modified attributes.</p>
<p>This method retrieves the history for each instrumented
attribute on the instance and performs a comparison of the current
value to its previously committed value, if any.</p>
<p>It is in effect a more expensive and accurate
version of checking for the given instance in the
<code>.Session.dirty</code> collection; a full test for
each attribute's net "dirty" status is performed.</p>
<p>E.g.:</p>
<pre class="rst-literal-block">
return session.is_modified(someobject)
</pre>
<p>A few caveats to this method apply:</p>
<ul>
<li><p class="rst-first">Instances present in the <code>.Session.dirty</code> collection may
report <tt class="rst-docutils literal">False</tt> when tested with this method.  This is because
the object may have received change events via attribute mutation,
thus placing it in <code>.Session.dirty</code>, but ultimately the state
is the same as that loaded from the database, resulting in no net
change here.</p>
</li>
<li><p class="rst-first">Scalar attributes may not have recorded the previously set
value when a new value was applied, if the attribute was not loaded,
or was expired, at the time the new value was received - in these
cases, the attribute is assumed to have a change, even if there is
ultimately no net change against its database value. SQLAlchemy in
most cases does not need the "old" value when a set event occurs, so
it skips the expense of a SQL call if the old value isn't present,
based on the assumption that an UPDATE of the scalar value is
usually needed, and in those few cases where it isn't, is less
expensive on average than issuing a defensive SELECT.</p>
<p>The "old" value is fetched unconditionally upon set only if the
attribute container has the <tt class="rst-docutils literal">active_history</tt> flag set to <tt class="rst-docutils literal">True</tt>.
This flag is set typically for primary key attributes and scalar
object references that are not a simple many-to-one.  To set this
flag for any arbitrary mapped column, use the <tt class="rst-docutils literal">active_history</tt>
argument with <code>.column_property</code>.</p>
</li>
</ul>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">instance</span></td><td class="fieldArgDesc">mapped instance to be tested for pending changes.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">include​_collections</span></td><td class="fieldArgDesc">Indicates if multivalued collections
should be included in the operation.  Setting this to <tt class="rst-docutils literal">False</tt> is a
way to detect only local-column based properties (i.e. scalar columns
or many-to-one foreign keys) that would result in an UPDATE for this
instance upon flush.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.merge">
    
  </a>
  <a name="merge">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">merge</span>(self, instance, load=True, options=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Copy the state of a given instance into a corresponding instance
within this <code>.Session</code>.</p>
<p><code>.Session.merge</code> examines the primary key attributes of the
source instance, and attempts to reconcile it with an instance of the
same primary key in the session.   If not found locally, it attempts
to load the object from the database based on primary key, and if
none can be located, creates a new instance.  The state of each
attribute on the source instance is then copied to the target
instance.  The resulting target instance is then returned by the
method; the original source instance is left unmodified, and
un-associated with the <code>.Session</code> if not already.</p>
<p>This operation cascades to associated instances if the association is
mapped with <tt class="rst-docutils literal"><span class="pre">cascade="merge"</span></tt>.</p>
<p>See <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`unitofwork_merging`</span></a> for a detailed discussion of merging.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.1: </span><span>- <code>.Session.merge</code> will now reconcile
pending objects with overlapping primary keys in the same way
as persistent.  See <a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`change_3601`</span></a> for discussion.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>.make_transient_to_detached</code> - provides for an alternative
means of "merging" a single object into the <code>.Session</code></p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">instance</span></td><td class="fieldArgDesc">Instance to be merged.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">load</span></td><td class="fieldArgDesc"><p>Boolean, when False, <code>.merge</code> switches into
a "high performance" mode which causes it to forego emitting history
events as well as all database access.  This flag is used for
cases such as transferring graphs of objects into a <code>.Session</code>
from a second level cache, or to transfer just-loaded objects
into the <code>.Session</code> owned by a worker thread or process
without re-querying the database.</p>
<p>The <tt class="rst-docutils literal">load=False</tt> use case adds the caveat that the given
object has to be in a "clean" state, that is, has no pending changes
to be flushed - even if the incoming object is detached from any
<code>.Session</code>.   This is so that when
the merge operation populates local attributes and
cascades to related objects and
collections, the values can be "stamped" onto the
target object as is, without generating any history or attribute
events, and without the need to reconcile the incoming data with
any existing related objects or collections that might not
be loaded.  The resulting objects from <tt class="rst-docutils literal">load=False</tt> are always
produced as "clean", so it is only appropriate that the given objects
should be "clean" as well, else this suggests a mis-use of the
method.</p>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">options</span></td><td class="fieldArgDesc"><p>optional sequence of loader options which will be
applied to the <code>_orm.Session.get</code> method when the merge
operation loads the existing version of the object from the database.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.24.</span></div>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.prepare">
    
  </a>
  <a name="prepare">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">prepare</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Prepare the current transaction in progress for two phase commit.</p>
<p>If no transaction is in progress, this method raises an
<code>~sqlalchemy.exc.InvalidRequestError</code>.</p>
<p>Only root transactions of two phase sessions can be prepared. If the
current transaction is not such, an
<code>~sqlalchemy.exc.InvalidRequestError</code> is raised.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.query">
    
  </a>
  <a name="query">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">query</span>(self, *entities, **kwargs):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Return a new <code>_query.Query</code> object corresponding to this
<code>_orm.Session</code>.</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.refresh">
    
  </a>
  <a name="refresh">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">refresh</span>(self, instance, attribute_names=None, with_for_update=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Expire and refresh attributes on the given instance.</p>
<p>The selected attributes will first be expired as they would when using
<code>_orm.Session.expire</code>; then a SELECT statement will be issued to
the database to refresh column-oriented attributes with the current
value available in the current transaction.</p>
<p><code>_orm.relationship</code> oriented attributes will also be immediately
loaded if they were already eagerly loaded on the object, using the
same eager loading strategy that they were loaded with originally.
Unloaded relationship attributes will remain unloaded, as will
relationship attributes that were originally lazy loaded.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4: </span><span>- the <code>_orm.Session.refresh</code> method
can also refresh eagerly loaded attributes.</span></div>
<div class="rst-admonition tip">
<p class="rst-first rst-admonition-title">Tip</p>
<p class="rst-last">While the <code>_orm.Session.refresh</code> method is capable of
refreshing both column and relationship oriented attributes, its
primary focus is on refreshing of local column-oriented attributes
on a single instance. For more open ended "refresh" functionality,
including the ability to refresh the attributes on many objects at
once while having explicit control over relationship loader
strategies, use the
<a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`populate existing &lt;orm_queryguide_populate_existing&gt;`</span></a> feature
instead.</p>
</div>
<p>Note that a highly isolated transaction will return the same values as
were previously read in that same transaction, regardless of changes
in database state outside of that transaction.   Refreshing
attributes usually only makes sense at the start of a transaction
where database rows have not yet been accessed.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:ref:`session_expire`</span></a> - introductory material</p>
<p><code>.Session.expire</code></p>
<p><code>.Session.expire_all</code></p>
<p class="rst-last"><a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:ref:`orm_queryguide_populate_existing`</span></a> - allows any ORM query
to refresh objects as they would be loaded normally.</p>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">instance</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">attribute​_names</span></td><td class="fieldArgDesc">optional.  An iterable collection of
string attribute names indicating a subset of attributes to
be refreshed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">with​_for​_update</span></td><td class="fieldArgDesc">optional boolean <tt class="rst-docutils literal">True</tt> indicating FOR UPDATE
should be used, or may be a dictionary containing flags to
indicate a more specific set of FOR UPDATE flags for the SELECT;
flags should match the parameters of
<code>_query.Query.with_for_update</code>.
Supersedes the <a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:paramref:`.Session.refresh.lockmode`</span></a> parameter.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.rollback">
    
  </a>
  <a name="rollback">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rollback</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Rollback the current transaction in progress.</p>
<p>If no transaction is in progress, this method is a pass-through.</p>
<p>In <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:term:`1.x-style`</span></a> use, this method rolls back the topmost
database transaction if no nested transactions are in effect, or
to the current nested transaction if one is in effect.</p>
<p>When
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:term:`2.0-style`</span></a> use is in effect via the
<a href="#system-message-3"><span class="rst-problematic" id="rst-problematic-3">:paramref:`_orm.Session.future`</span></a> flag, the method always rolls back
the topmost database transaction, discarding any nested
transactions that may be in progress.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-4"><span class="rst-problematic" id="rst-problematic-4">:ref:`session_rollback`</span></a></p>
<p class="rst-last"><a href="#system-message-5"><span class="rst-problematic" id="rst-problematic-5">:ref:`unitofwork_transaction`</span></a></p>
</div>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.scalar">
    
  </a>
  <a name="scalar">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">scalar</span>(self, statement, params=None, execution_options=<a href="sqlalchemy.util._collections.html#EMPTY_DICT" class="internal-link" title="sqlalchemy.util._collections.EMPTY_DICT">util.EMPTY_DICT</a>, bind_arguments=None, **kw):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Execute a statement and return a scalar result.</p>
<p>Usage and parameters are the same as that of
<code>_orm.Session.execute</code>; the return result is a scalar Python
value.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="sqlalchemy.orm.session.Session.scalars">
    
  </a>
  <a name="scalars">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">scalars</span>(self, statement, params=None, execution_options=<a href="sqlalchemy.util._collections.html#EMPTY_DICT" class="internal-link" title="sqlalchemy.util._collections.EMPTY_DICT">util.EMPTY_DICT</a>, bind_arguments=None, **kw):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Execute a statement and return the results as scalars.</p>
<p>Usage and parameters are the same as that of
<code>_orm.Session.execute</code>; the return result is a
<code>_result.ScalarResult</code> filtering object which
will return single elements rather than <code>_row.Row</code> objects.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.4.24.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code>_result.ScalarResult</code> object</td></tr></table></div>
  </div>
</div><div class="baseclassvariable">
  
  
  <a name="sqlalchemy.orm.session.Session.connection_callable">
    
  </a>
  <a name="connection_callable">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">connection_callable</span> =
    
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overridden in <code><a href="sqlalchemy.ext.horizontal_shard.ShardedSession.html" class="internal-link">sqlalchemy.ext.horizontal_shard.ShardedSession</a></code></div>
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable">
  
  
  <a name="sqlalchemy.orm.session.Session.autocommit">
    
  </a>
  <a name="autocommit">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">autocommit</span>: <code>bool</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable">
  
  
  <a name="sqlalchemy.orm.session.Session.autoflush">
    
  </a>
  <a name="autoflush">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">autoflush</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable">
  
  
  <a name="sqlalchemy.orm.session.Session.bind">
    
  </a>
  <a name="bind">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">bind</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable">
  
  
  <a name="sqlalchemy.orm.session.Session.enable_baked_queries">
    
  </a>
  <a name="enable_baked_queries">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">enable_baked_queries</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable">
  
  
  <a name="sqlalchemy.orm.session.Session.expire_on_commit">
    
  </a>
  <a name="expire_on_commit">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">expire_on_commit</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable">
  
  
  <a name="sqlalchemy.orm.session.Session.future">
    
  </a>
  <a name="future">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">future</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable">
  
  
  <a name="sqlalchemy.orm.session.Session.hash_key">
    
  </a>
  <a name="hash_key">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">hash_key</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable">
  
  
  <a name="sqlalchemy.orm.session.Session.identity_map">
    
  </a>
  <a name="identity_map">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">identity_map</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p>A mapping of object identities to objects themselves.</p>
<p>Iterating through <tt class="rst-docutils literal">Session.identity_map.values()</tt> provides
access to the full set of persistent objects (i.e., those
that have row identity) currently in the session.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>.identity_key</code> - helper function to produce the keys used
in this dictionary.</p>
</div>
</div>
    
  </div>
</div><div class="baseinstancevariable">
  
  
  <a name="sqlalchemy.orm.session.Session.twophase">
    
  </a>
  <a name="twophase">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">twophase</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseproperty">
  
  
  <a name="sqlalchemy.orm.session.Session.deleted">
    
  </a>
  <a name="deleted">
    
  </a>
  <div class="functionHeader">
    @property<br />
    <span class="py-defname">deleted</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>The set of all instances marked as 'deleted' within this <tt class="rst-docutils literal">Session</tt></div>
    
  </div>
</div><div class="baseproperty">
  
  
  <a name="sqlalchemy.orm.session.Session.dirty">
    
  </a>
  <a name="dirty">
    
  </a>
  <div class="functionHeader">
    @property<br />
    <span class="py-defname">dirty</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p>The set of all persistent instances considered dirty.</p>
<p>E.g.:</p>
<pre class="rst-literal-block">
some_mapped_object in session.dirty
</pre>
<p>Instances are considered dirty when they were modified but not
deleted.</p>
<p>Note that this 'dirty' calculation is 'optimistic'; most
attribute-setting or collection modification operations will
mark an instance as 'dirty' and place it in this set, even if
there is no net change to the attribute's value.  At flush
time, the value of each attribute is compared to its
previously saved value, and if there's no net change, no SQL
operation will occur (this is a more expensive operation so
it's only done at flush time).</p>
<p>To check if an instance has actionable net changes to its
attributes, use the <code>.Session.is_modified</code> method.</p>
</div>
    
  </div>
</div><div class="baseproperty">
  
  
  <a name="sqlalchemy.orm.session.Session.info">
    
  </a>
  <a name="info">
    
  </a>
  <div class="functionHeader">
    @<a href="sqlalchemy.util.langhelpers.memoized_property.html" class="internal-link" title="sqlalchemy.util.langhelpers.memoized_property">util.memoized_property</a><br />
    <span class="py-defname">info</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p>A user-modifiable dictionary.</p>
<p>The initial value of this dictionary can be populated using the
<tt class="rst-docutils literal">info</tt> argument to the <code>.Session</code> constructor or
<code>.sessionmaker</code> constructor or factory methods.  The dictionary
here is always local to this <code>.Session</code> and can be modified
independently of all other <code>.Session</code> objects.</p>
</div>
    
  </div>
</div><div class="baseproperty">
  
  
  <a name="sqlalchemy.orm.session.Session.is_active">
    
  </a>
  <a name="is_active">
    
  </a>
  <div class="functionHeader">
    @property<br />
    <span class="py-defname">is_active</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p>True if this <code>.Session</code> not in "partial rollback" state.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>The <code>_orm.Session</code> no longer begins
a new transaction immediately, so this attribute will be False
when the <code>_orm.Session</code> is first instantiated.</span></div>
<p>"partial rollback" state typically indicates that the flush process
of the <code>_orm.Session</code> has failed, and that the
<code>_orm.Session.rollback</code> method must be emitted in order to
fully roll back the transaction.</p>
<p>If this <code>_orm.Session</code> is not in a transaction at all, the
<code>_orm.Session</code> will autobegin when it is first used, so in this
case <code>_orm.Session.is_active</code> will return True.</p>
<p>Otherwise, if this <code>_orm.Session</code> is within a transaction,
and that transaction has not been rolled back internally, the
<code>_orm.Session.is_active</code> will also return True.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p><a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`faq_session_rollback`</span></a></p>
<p class="rst-last"><code>_orm.Session.in_transaction</code></p>
</div>
</div>
    
  </div>
</div><div class="baseproperty">
  
  
  <a name="sqlalchemy.orm.session.Session.new">
    
  </a>
  <a name="new">
    
  </a>
  <div class="functionHeader">
    @property<br />
    <span class="py-defname">new</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>The set of all instances marked as 'new' within this <tt class="rst-docutils literal">Session</tt>.</div>
    
  </div>
</div><div class="baseproperty">
  
  
  <a name="sqlalchemy.orm.session.Session.no_autoflush">
    
  </a>
  <a name="no_autoflush">
    
  </a>
  <div class="functionHeader">
    @property<br />@util.contextmanager<br />
    <span class="py-defname">no_autoflush</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p>Return a context manager that disables autoflush.</p>
<p>e.g.:</p>
<pre class="rst-literal-block">
with session.no_autoflush:

    some_object = SomeClass()
    session.add(some_object)
    # won't autoflush
    some_object.related_thing = session.query(SomeRelated).first()
</pre>
<p>Operations that proceed within the <tt class="rst-docutils literal">with:</tt> block
will not be subject to flushes occurring upon query
access.  This is useful when initializing a series
of objects which involve existing database queries,
where the uncompleted object should not yet be flushed.</p>
</div>
    
  </div>
</div><div class="baseproperty">
  
  
  <a name="sqlalchemy.orm.session.Session.transaction">
    
  </a>
  <a name="transaction">
    
  </a>
  <div class="functionHeader">
    @property<br />@<a href="sqlalchemy.util.deprecations.html#deprecated_20" class="internal-link" title="sqlalchemy.util.deprecations.deprecated_20">util.deprecated_20</a>(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">:attr:`_orm.Session.transaction`</span><span class="rst-variable-quote">'</span>, <wbr></wbr>alternative=<span class="rst-variable-quote">'</span><span class="rst-variable-string">For context manager use, use :meth:`_orm.Session.begin`.  To access the current root transaction, use :meth:`_orm.Session.get_transaction`.</span><span class="rst-variable-quote">'</span>, <wbr></wbr>warn_on_attribute_access=True)<br />
    <span class="py-defname">transaction</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p>The current active or inactive <code>.SessionTransaction</code>.</p>
<p>May be None if no transaction has begun yet.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4: </span><span>the <code>.Session.transaction</code> attribute
is now a read-only descriptor that also may return None if no
transaction has begun yet.</span></div>
</div>
    
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._add_bind">
    
  </a>
  <a name="_add_bind">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_add_bind</span>(self, key, bind):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._after_attach">
    
  </a>
  <a name="_after_attach">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_after_attach</span>(self, state, obj):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._autobegin">
    
  </a>
  <a name="_autobegin">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_autobegin</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._autoflush">
    
  </a>
  <a name="_autoflush">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_autoflush</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._before_attach">
    
  </a>
  <a name="_before_attach">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_before_attach</span>(self, state, obj):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._bulk_save_mappings">
    
  </a>
  <a name="_bulk_save_mappings">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_bulk_save_mappings</span>(self, mapper, mappings, isupdate, isstates, return_defaults, update_changed_only, render_nulls):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._close_impl">
    
  </a>
  <a name="_close_impl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_close_impl</span>(self, invalidate):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._conditional_expire">
    
  </a>
  <a name="_conditional_expire">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_conditional_expire</span>(self, state, autoflush=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Expire a state if persistent, else expunge if pending</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._connection_for_bind">
    
  </a>
  <a name="_connection_for_bind">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_connection_for_bind</span>(self, engine, execution_options=None, **kw):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._contains_state">
    
  </a>
  <a name="_contains_state">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_contains_state</span>(self, state):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._delete_impl">
    
  </a>
  <a name="_delete_impl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_delete_impl</span>(self, state, obj, head):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._expire_state">
    
  </a>
  <a name="_expire_state">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_expire_state</span>(self, state, attribute_names):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._expunge_states">
    
  </a>
  <a name="_expunge_states">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_expunge_states</span>(self, states, to_transient=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._flush">
    
  </a>
  <a name="_flush">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_flush</span>(self, objects=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._flush_warning">
    
  </a>
  <a name="_flush_warning">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_flush_warning</span>(self, method):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._get_impl">
    
  </a>
  <a name="_get_impl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_get_impl</span>(self, entity, primary_key_identity, db_load_fn, options=None, populate_existing=False, with_for_update=None, identity_token=None, execution_options=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._identity_lookup">
    
  </a>
  <a name="_identity_lookup">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_identity_lookup</span>(self, mapper, primary_key_identity, identity_token=None, passive=<a href="sqlalchemy.orm.base.html#PASSIVE_OFF" class="internal-link" title="sqlalchemy.orm.base.PASSIVE_OFF">attributes.PASSIVE_OFF</a>, lazy_loaded_from=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="sqlalchemy.ext.horizontal_shard.ShardedSession.html" class="internal-link">sqlalchemy.ext.horizontal_shard.ShardedSession</a></code></div>
    
    <div><p>Locate an object in the identity map.</p>
<p>Given a primary key identity, constructs an identity key and then
looks in the session's identity map.  If present, the object may
be run through unexpiration rules (e.g. load unloaded attributes,
check if was deleted).</p>
<p>e.g.:</p>
<pre class="rst-literal-block">
obj = session._identity_lookup(inspect(SomeClass), (1, ))
</pre>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4.0: </span><span>- the <code>.Session._identity_lookup</code>
method was moved from <code>_query.Query</code> to
<code>.Session</code>, to avoid having to instantiate the
<code>_query.Query</code> object.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mapper</span></td><td class="fieldArgDesc">mapper in use</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">primary​_key​_identity</span></td><td class="fieldArgDesc">the primary key we are searching for, as
a tuple.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">identity​_token</span></td><td class="fieldArgDesc">identity token that should be used to create
the identity key.  Used as is, however overriding subclasses can
repurpose this in order to interpret the value in a special way,
such as if None then look among multiple target tokens.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">passive</span></td><td class="fieldArgDesc">passive load flag passed to
<code>.loading.get_from_identity</code>, which impacts the behavior if
the object is found; the object may be validated and/or unexpired
if the flag allows for SQL to be emitted.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">lazy​_loaded​_from</span></td><td class="fieldArgDesc">an <code>.InstanceState</code> that is
specifically asking for this identity as a related identity.  Used
for sharding schemes where there is a correspondence between an object
and a related object being lazy-loaded (or otherwise
relationship-loaded).</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">None if the object is not found in the identity map, <em>or</em>
if the object was unexpired and found to have been deleted.
if passive flags disallow SQL and the object is expired, returns
PASSIVE_NO_RESULT.   In all other cases the instance is returned.</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._is_clean">
    
  </a>
  <a name="_is_clean">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_is_clean</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._legacy_transaction">
    
  </a>
  <a name="_legacy_transaction">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_legacy_transaction</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._maker_context_manager">
    
  </a>
  <a name="_maker_context_manager">
    
  </a>
  <div class="functionHeader">
    @util.contextmanager<br />
    <span class="py-keyword">def</span> <span class="py-defname">_maker_context_manager</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._merge">
    
  </a>
  <a name="_merge">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_merge</span>(self, state, state_dict, load=True, options=None, _recursive=None, _resolve_conflict_map=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._register_altered">
    
  </a>
  <a name="_register_altered">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_register_altered</span>(self, states):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._register_persistent">
    
  </a>
  <a name="_register_persistent">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_register_persistent</span>(self, states):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Register all persistent objects from a flush.</p>
<p>This is used both for pending objects moving to the persistent
state as well as already persistent objects.</p>
</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._remove_newly_deleted">
    
  </a>
  <a name="_remove_newly_deleted">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_remove_newly_deleted</span>(self, states):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._save_impl">
    
  </a>
  <a name="_save_impl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_save_impl</span>(self, state):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._save_or_update_impl">
    
  </a>
  <a name="_save_or_update_impl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_save_or_update_impl</span>(self, state):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._save_or_update_state">
    
  </a>
  <a name="_save_or_update_state">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_save_or_update_state</span>(self, state):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._update_impl">
    
  </a>
  <a name="_update_impl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_update_impl</span>(self, state, revert_deletion=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="sqlalchemy.orm.session.Session._validate_persistent">
    
  </a>
  <a name="_validate_persistent">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_validate_persistent</span>(self, state):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="baseclassvariable private">
  
  
  <a name="sqlalchemy.orm.session.Session._is_asyncio">
    
  </a>
  <a name="_is_asyncio">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_is_asyncio</span>: <code>bool</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseclassvariable private">
  
  
  <a name="sqlalchemy.orm.session.Session._trans_context_manager">
    
  </a>
  <a name="_trans_context_manager">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_trans_context_manager</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="sqlalchemy.orm.session.Session.__binds">
    
  </a>
  <a name="__binds">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">__binds</span>: <code>dict</code> =
    
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overridden in <code><a href="sqlalchemy.ext.horizontal_shard.ShardedSession.html" class="internal-link">sqlalchemy.ext.horizontal_shard.ShardedSession</a></code></div>
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="sqlalchemy.orm.session.Session._deleted">
    
  </a>
  <a name="_deleted">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_deleted</span>: <code>dict</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="sqlalchemy.orm.session.Session._flushing">
    
  </a>
  <a name="_flushing">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_flushing</span>: <code>bool</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="sqlalchemy.orm.session.Session._nested_transaction">
    
  </a>
  <a name="_nested_transaction">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_nested_transaction</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="sqlalchemy.orm.session.Session._new">
    
  </a>
  <a name="_new">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_new</span>: <code>dict</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="sqlalchemy.orm.session.Session._query_cls">
    
  </a>
  <a name="_query_cls">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_query_cls</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="sqlalchemy.orm.session.Session._transaction">
    
  </a>
  <a name="_transaction">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_transaction</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="sqlalchemy.orm.session.Session._warn_on_events">
    
  </a>
  <a name="_warn_on_events">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_warn_on_events</span>: <code>bool</code> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseproperty private">
  
  
  <a name="sqlalchemy.orm.session.Session._dirty_states">
    
  </a>
  <a name="_dirty_states">
    
  </a>
  <div class="functionHeader">
    @property<br />
    <span class="py-defname">_dirty_states</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p>The set of all persistent states considered dirty.</p>
<p>This method returns all states that were modified including
those that were possibly deleted.</p>
</div>
    
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 04:41:59.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>