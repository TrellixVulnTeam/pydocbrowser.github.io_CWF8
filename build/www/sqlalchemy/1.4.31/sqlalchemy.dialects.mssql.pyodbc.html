<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.dialects.mssql.pyodbc</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            sqlalchemy <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.dialects.html" class="internal-link" title="sqlalchemy.dialects">dialects</a></code><wbr></wbr>.<code><a href="sqlalchemy.dialects.mssql.html" class="internal-link" title="sqlalchemy.dialects.mssql">mssql</a></code><wbr></wbr>.<code><a href="sqlalchemy.dialects.mssql.pyodbc.html" class="internal-link" title="sqlalchemy.dialects.mssql.pyodbc">pyodbc</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><div class="rst-section" id="rst-connecting-to-pyodbc">
<h2 class="heading">Connecting to PyODBC</h2>
<p>The URL here is to be translated to PyODBC connection strings, as
detailed in <a class="rst-reference external" href="https://code.google.com/p/pyodbc/wiki/ConnectionStrings" target="_top">ConnectionStrings</a>.</p>
<div class="rst-section" id="rst-dsn-connections">
<h3 class="heading">DSN Connections</h3>
<p>A DSN connection in ODBC means that a pre-existing ODBC datasource is
configured on the client machine.   The application then specifies the name
of this datasource, which encompasses details such as the specific ODBC driver
in use as well as the network address of the database.   Assuming a datasource
is configured on the client, a basic DSN-based connection looks like:</p>
<pre class="rst-literal-block">
engine = create_engine("mssql+pyodbc://scott:tiger@some_dsn")
</pre>
<p>Which above, will pass the following connection string to PyODBC:</p>
<pre class="rst-literal-block">
DSN=some_dsn;UID=scott;PWD=tiger
</pre>
<p>If the username and password are omitted, the DSN form will also add
the <tt class="rst-docutils literal">Trusted_Connection=yes</tt> directive to the ODBC string.</p>
</div>
<div class="rst-section" id="rst-hostname-connections">
<h3 class="heading">Hostname Connections</h3>
<p>Hostname-based connections are also supported by pyodbc.  These are often
easier to use than a DSN and have the additional advantage that the specific
database name to connect towards may be specified locally in the URL, rather
than it being fixed as part of a datasource configuration.</p>
<p>When using a hostname connection, the driver name must also be specified in the
query parameters of the URL.  As these names usually have spaces in them, the
name must be URL encoded which means using plus signs for spaces:</p>
<pre class="rst-literal-block">
engine = create_engine("mssql+pyodbc://scott:tiger@myhost:port/databasename?driver=ODBC+Driver+17+for+SQL+Server")
</pre>
<p>Other keywords interpreted by the Pyodbc dialect to be passed to
<tt class="rst-docutils literal">pyodbc.connect()</tt> in both the DSN and hostname cases include:
<tt class="rst-docutils literal">odbc_autotranslate</tt>, <tt class="rst-docutils literal">ansi</tt>, <tt class="rst-docutils literal">unicode_results</tt>, <tt class="rst-docutils literal">autocommit</tt>,
<tt class="rst-docutils literal">authentication</tt>.
Note that in order for the dialect to recognize these keywords
(including the <tt class="rst-docutils literal">driver</tt> keyword above) they must be all lowercase.
Multiple additional keyword arguments must be separated by an
ampersand (<tt class="rst-docutils literal">&amp;</tt>), not a semicolon:</p>
<pre class="rst-literal-block">
engine = create_engine(
    "mssql+pyodbc://scott:tiger@myhost:49242/databasename"
    "?driver=ODBC+Driver+17+for+SQL+Server"
    "&amp;authentication=ActiveDirectoryIntegrated"
)
</pre>
<p>The equivalent URL can be constructed using <code>_sa.engine.URL</code>:</p>
<pre class="rst-literal-block">
from sqlalchemy.engine import URL
connection_url = URL.create(
    "mssql+pyodbc",
    username="scott",
    password="tiger",
    host="myhost",
    port=49242,
    database="databasename",
    query={
        "driver": "ODBC Driver 17 for SQL Server",
        "authentication": "ActiveDirectoryIntegrated",
    },
)
</pre>
</div>
<div class="rst-section" id="rst-pass-through-exact-pyodbc-string">
<h3 class="heading">Pass through exact Pyodbc string</h3>
<p>A PyODBC connection string can also be sent in pyodbc's format directly, as
specified in <a class="rst-reference external" href="https://github.com/mkleehammer/pyodbc/wiki/Connecting-to-databases" target="_top">the PyODBC documentation</a>,
using the parameter <tt class="rst-docutils literal">odbc_connect</tt>.  A <code>_sa.engine.URL</code> object
can help make this easier:</p>
<pre class="rst-literal-block">
from sqlalchemy.engine import URL
connection_string = "DRIVER={SQL Server Native Client 10.0};SERVER=dagger;DATABASE=test;UID=user;PWD=password"
connection_url = URL.create("mssql+pyodbc", query={"odbc_connect": connection_string})

engine = create_engine(connection_url)
</pre>
</div>
<div class="rst-section" id="rst-connecting-to-databases-with-access-tokens">
<span id="rst-mssql-pyodbc-access-tokens"></span><h3 class="heading">Connecting to databases with access tokens</h3>
<p>Some database servers are set up to only accept access tokens for login. For
example, SQL Server allows the use of Azure Active Directory tokens to connect
to databases. This requires creating a credential object using the
<tt class="rst-docutils literal"><span class="pre">azure-identity</span></tt> library. More information about the authentication step can be
found in <a class="rst-reference external" href="https://docs.microsoft.com/en-us/azure/developer/python/azure-sdk-authenticate?tabs=bash" target="_top">Microsoft's documentation</a>.</p>
<p>After getting an engine, the credentials need to be sent to <tt class="rst-docutils literal">pyodbc.connect</tt>
each time a connection is requested. One way to do this is to set up an event
listener on the engine that adds the credential token to the dialect's connect
call. This is discussed more generally in <a href="#system-message-1"><span class="rst-problematic" id="rst-problematic-1">:ref:`engines_dynamic_tokens`</span></a>. For
SQL Server in particular, this is passed as an ODBC connection attribute with
a data structure <a class="rst-reference external" href="https://docs.microsoft.com/en-us/sql/connect/odbc/using-azure-active-directory#authenticating-with-an-access-token" target="_top">described by Microsoft</a>.</p>
<p>The following code snippet will create an engine that connects to an Azure SQL
database using Azure credentials:</p>
<pre class="rst-literal-block">
import struct
from sqlalchemy import create_engine, event
from sqlalchemy.engine.url import URL
from azure import identity

SQL_COPT_SS_ACCESS_TOKEN = 1256  # Connection option for access tokens, as defined in msodbcsql.h
TOKEN_URL = "https://database.windows.net/"  # The token URL for any Azure SQL database

connection_string = "mssql+pyodbc://@my-server.database.windows.net/myDb?driver=ODBC+Driver+17+for+SQL+Server"

engine = create_engine(connection_string)

azure_credentials = identity.DefaultAzureCredential()

@event.listens_for(engine, "do_connect")
def provide_token(dialect, conn_rec, cargs, cparams):
    # remove the "Trusted_Connection" parameter that SQLAlchemy adds
    cargs[0] = cargs[0].replace(";Trusted_Connection=Yes", "")

    # create token credential
    raw_token = azure_credentials.get_token(TOKEN_URL).token.encode("utf-16-le")
    token_struct = struct.pack(f"&lt;I{len(raw_token)}s", len(raw_token), raw_token)

    # apply it to keyword arguments
    cparams["attrs_before"] = {SQL_COPT_SS_ACCESS_TOKEN: token_struct}
</pre>
<div class="rst-admonition tip">
<p class="rst-first rst-admonition-title">Tip</p>
<p class="rst-last">The <tt class="rst-docutils literal">Trusted_Connection</tt> token is currently added by the SQLAlchemy
pyodbc dialect when no username or password is present.  This needs
to be removed per Microsoft's
<a class="rst-reference external" href="https://docs.microsoft.com/en-us/sql/connect/odbc/using-azure-active-directory#authenticating-with-an-access-token" target="_top">documentation for Azure access tokens</a>,
stating that a connection string when using an access token must not contain
<tt class="rst-docutils literal">UID</tt>, <tt class="rst-docutils literal">PWD</tt>, <tt class="rst-docutils literal">Authentication</tt> or <tt class="rst-docutils literal">Trusted_Connection</tt> parameters.</p>
</div>
</div>
<div class="rst-section" id="rst-enable-autocommit-for-azure-sql-data-warehouse-dw-connections">
<h3 class="heading">Enable autocommit for Azure SQL Data Warehouse (DW) connections</h3>
<p>Azure SQL Data Warehouse does not support transactions,
and that can cause problems with SQLAlchemy's "autobegin" (and implicit
commit/rollback) behavior. We can avoid these problems by enabling autocommit
at both the pyodbc and engine levels:</p>
<pre class="rst-literal-block">
connection_url = sa.engine.URL.create(
    "mssql+pyodbc",
    username="scott",
    password="tiger",
    host="dw.azure.example.com",
    database="mydb",
    query={
        "driver": "ODBC Driver 17 for SQL Server",
        "autocommit": "True",
    },
)

engine = create_engine(connection_url).execution_options(
    isolation_level="AUTOCOMMIT"
)
</pre>
</div>
</div>
<div class="rst-section" id="rst-pyodbc-pooling-connection-close-behavior">
<h2 class="heading">Pyodbc Pooling / connection close behavior</h2>
<p>PyODBC uses internal <a class="rst-reference external" href="https://github.com/mkleehammer/pyodbc/wiki/The-pyodbc-Module#pooling" target="_top">pooling</a> by
default, which means connections will be longer lived than they are within
SQLAlchemy itself.  As SQLAlchemy has its own pooling behavior, it is often
preferable to disable this behavior.  This behavior can only be disabled
globally at the PyODBC module level, <strong>before</strong> any connections are made:</p>
<pre class="rst-literal-block">
import pyodbc

pyodbc.pooling = False

# don't use the engine before pooling is set to False
engine = create_engine("mssql+pyodbc://user:pass@dsn")
</pre>
<p>If this variable is left at its default value of <tt class="rst-docutils literal">True</tt>, <strong>the application
will continue to maintain active database connections</strong>, even when the
SQLAlchemy engine itself fully discards a connection or if the engine is
disposed.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a class="rst-reference external" href="https://github.com/mkleehammer/pyodbc/wiki/The-pyodbc-Module#pooling" target="_top">pooling</a> -
in the PyODBC documentation.</p>
</div>
</div>
<div class="rst-section" id="rst-driver-unicode-support">
<h2 class="heading">Driver / Unicode Support</h2>
<p>PyODBC works best with Microsoft ODBC drivers, particularly in the area
of Unicode support on both Python 2 and Python 3.</p>
<p>Using the FreeTDS ODBC drivers on Linux or OSX with PyODBC is <strong>not</strong>
recommended; there have been historically many Unicode-related issues
in this area, including before Microsoft offered ODBC drivers for Linux
and OSX.   Now that Microsoft offers drivers for all platforms, for
PyODBC support these are recommended.  FreeTDS remains relevant for
non-ODBC drivers such as pymssql where it works very well.</p>
</div>
<div class="rst-section" id="rst-rowcount-support">
<h2 class="heading">Rowcount Support</h2>
<p>Pyodbc only has partial support for rowcount.  See the notes at
<a href="#system-message-2"><span class="rst-problematic" id="rst-problematic-2">:ref:`mssql_rowcount_versioning`</span></a> for important notes when using ORM
versioning.</p>
</div>
<div class="rst-section" id="rst-fast-executemany-mode">
<span id="rst-mssql-pyodbc-fastexecutemany"></span><h2 class="heading">Fast Executemany Mode</h2>
<p>The Pyodbc driver has added support for a "fast executemany" mode of execution
which greatly reduces round trips for a DBAPI <tt class="rst-docutils literal">executemany()</tt> call when using
Microsoft ODBC drivers, for <strong>limited size batches that fit in memory</strong>.  The
feature is enabled by setting the flag <tt class="rst-docutils literal">.fast_executemany</tt> on the DBAPI
cursor when an executemany call is to be used.   The SQLAlchemy pyodbc SQL
Server dialect supports setting this flag automatically when the
<tt class="rst-docutils literal">.fast_executemany</tt> flag is passed to
<code>_sa.create_engine</code> ; note that the ODBC driver must be the Microsoft
driver in order to use this flag:</p>
<pre class="rst-literal-block">
engine = create_engine(
    "mssql+pyodbc://scott:tiger@mssql2017:1433/test?driver=ODBC+Driver+13+for+SQL+Server",
    fast_executemany=True)
</pre>
<div class="rst-admonition warning">
<p class="rst-first rst-admonition-title">Warning</p>
<p class="rst-last">The pyodbc fast_executemany mode <strong>buffers all rows in memory</strong> and is
not compatible with very large batches of data.    A future version of SQLAlchemy
may support this flag as a per-execution option instead.</p>
</div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.3.</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><a class="rst-reference external" href="https://github.com/mkleehammer/pyodbc/wiki/Features-beyond-the-DB-API#fast_executemany" target="_top">fast executemany</a>
- on github</p>
</div>
</div>
<div class="rst-section" id="rst-setinputsizes-support">
<span id="rst-mssql-pyodbc-setinputsizes"></span><h2 class="heading">Setinputsizes Support</h2>
<p>The pyodbc <tt class="rst-docutils literal">cursor.setinputsizes()</tt> method can be used if necessary.  To
enable this hook, pass <tt class="rst-docutils literal">use_setinputsizes=True</tt> to <code>_sa.create_engine</code>:</p>
<pre class="rst-literal-block">
engine = create_engine("mssql+pyodbc://...", use_setinputsizes=True)
</pre>
<p>The behavior of the hook can then be customized, as may be necessary
particularly if fast_executemany is in use, via the
<code>.DialectEvents.do_setinputsizes</code> hook. See that method for usage
examples.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.4.1: </span><span>The pyodbc dialects will not use setinputsizes
unless <tt class="rst-docutils literal">use_setinputsizes=True</tt> is passed.</span></div>
</div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id14567">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.mssql.pyodbc.MSDialect_pyodbc.html" class="internal-link" title="sqlalchemy.dialects.mssql.pyodbc.MSDialect_pyodbc">​MSDialect_pyodbc</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.mssql.pyodbc.MSExecutionContext_pyodbc.html" class="internal-link" title="sqlalchemy.dialects.mssql.pyodbc.MSExecutionContext_pyodbc">​MSExecution​Context_pyodbc</a></code></td>
    <td><span class="undocumented">No class docstring; 0/2 instance variable, 1/2 method documented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.mssql.pyodbc._BINARY_pyodbc.html" class="internal-link" title="sqlalchemy.dialects.mssql.pyodbc._BINARY_pyodbc">_​BINARY_pyodbc</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.mssql.pyodbc._ms_binary_pyodbc.html" class="internal-link" title="sqlalchemy.dialects.mssql.pyodbc._ms_binary_pyodbc">​_ms​_binary​_pyodbc</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.mssql.pyodbc._ms_numeric_pyodbc.html" class="internal-link" title="sqlalchemy.dialects.mssql.pyodbc._ms_numeric_pyodbc">​_ms​_numeric​_pyodbc</a></code></td>
    <td>Turns Decimals with adjusted() &lt; 0 or &gt; 7 into strings.</td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.mssql.pyodbc._MSFloat_pyodbc.html" class="internal-link" title="sqlalchemy.dialects.mssql.pyodbc._MSFloat_pyodbc">_​MSFloat_pyodbc</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.mssql.pyodbc._MSNumeric_pyodbc.html" class="internal-link" title="sqlalchemy.dialects.mssql.pyodbc._MSNumeric_pyodbc">_​MSNumeric_pyodbc</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.mssql.pyodbc._ODBCDateTime.html" class="internal-link" title="sqlalchemy.dialects.mssql.pyodbc._ODBCDateTime">_​ODBCDate​Time</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.mssql.pyodbc._ODBCDateTimeBindProcessor.html" class="internal-link" title="sqlalchemy.dialects.mssql.pyodbc._ODBCDateTimeBindProcessor">_​ODBCDate​Time​Bind​Processor</a></code></td>
    <td>Add bind processors to handle datetimeoffset behaviors</td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.mssql.pyodbc._ODBCDATETIMEOFFSET.html" class="internal-link" title="sqlalchemy.dialects.mssql.pyodbc._ODBCDATETIMEOFFSET">​_ODBCDATETIMEOFFSET</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.dialects.mssql.pyodbc._VARBINARY_pyodbc.html" class="internal-link" title="sqlalchemy.dialects.mssql.pyodbc._VARBINARY_pyodbc">_​VARBINARY_pyodbc</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 04:41:59.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>