<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>werkzeug.wsgi</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            werkzeug <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="index.html" class="internal-link">werkzeug</a></code><wbr></wbr>.<code><a href="werkzeug.wsgi.html" class="internal-link" title="werkzeug.wsgi">wsgi</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="undocumented">Undocumented</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id21882">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="werkzeug.wsgi.ClosingIterator.html" class="internal-link" title="werkzeug.wsgi.ClosingIterator">​Closing​Iterator</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="werkzeug.wsgi.FileWrapper.html" class="internal-link" title="werkzeug.wsgi.FileWrapper">​File​Wrapper</a></code></td>
    <td>This class can be used to convert a <code><a href="#file" class="internal-link" title="werkzeug.wsgi.FileWrapper.file">file</a></code>-like object into an iterable.  It yields <code><a href="#buffer_size" class="internal-link" title="werkzeug.wsgi.FileWrapper.buffer_size">buffer_size</a></code> blocks until the file is fully read.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="werkzeug.wsgi.LimitedStream.html" class="internal-link" title="werkzeug.wsgi.LimitedStream">​Limited​Stream</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#extract_path_info" class="internal-link" title="werkzeug.wsgi.extract_path_info">extract​_path​_info</a></code></td>
    <td>Extracts the path info from the given URL (or WSGI environment) and path. The path info returned is a string. The URLs might also be IRIs.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#get_content_length" class="internal-link" title="werkzeug.wsgi.get_content_length">get​_content​_length</a></code></td>
    <td>Returns the content length from the WSGI environment as integer. If it's not available or chunked transfer encoding is used, <tt class="rst-docutils literal">None</tt> is returned.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#get_current_url" class="internal-link" title="werkzeug.wsgi.get_current_url">get​_current​_url</a></code></td>
    <td>Recreate the URL for a request from the parts in a WSGI environment.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#get_host" class="internal-link" title="werkzeug.wsgi.get_host">get​_host</a></code></td>
    <td>Return the host for the given WSGI environment.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#get_input_stream" class="internal-link" title="werkzeug.wsgi.get_input_stream">get​_input​_stream</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#get_path_info" class="internal-link" title="werkzeug.wsgi.get_path_info">get​_path​_info</a></code></td>
    <td>Return the <tt class="rst-docutils literal">PATH_INFO</tt> from the WSGI environment and decode it unless <tt class="rst-docutils literal">charset</tt> is <tt class="rst-docutils literal">None</tt>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#get_query_string" class="internal-link" title="werkzeug.wsgi.get_query_string">get​_query​_string</a></code></td>
    <td>Returns the <tt class="rst-docutils literal">QUERY_STRING</tt> from the WSGI environment. This also takes care of the WSGI decoding dance. The string returned will be restricted to ASCII characters.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#get_script_name" class="internal-link" title="werkzeug.wsgi.get_script_name">get​_script​_name</a></code></td>
    <td>Return the <tt class="rst-docutils literal">SCRIPT_NAME</tt> from the WSGI environment and decode it unless <code>charset</code> is set to <tt class="rst-docutils literal">None</tt>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#make_chunk_iter" class="internal-link" title="werkzeug.wsgi.make_chunk_iter">make​_chunk​_iter</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#make_line_iter" class="internal-link" title="werkzeug.wsgi.make_line_iter">make​_line​_iter</a></code></td>
    <td>Safely iterates line-based over an input stream.  If the input stream is not a <code><a href="werkzeug.wsgi.LimitedStream.html" class="internal-link" title="werkzeug.wsgi.LimitedStream">LimitedStream</a></code> the <code><a href="werkzeug.wsgi.LimitedStream.html#limit" class="internal-link" title="werkzeug.wsgi.LimitedStream.limit">limit</a></code> parameter is mandatory.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#peek_path_info" class="internal-link" title="werkzeug.wsgi.peek_path_info">peek​_path​_info</a></code></td>
    <td>Returns the next segment on the <code>PATH_INFO</code> or <code>None</code> if there is none.  Works like <code><a href="#pop_path_info" class="internal-link" title="werkzeug.wsgi.pop_path_info">pop_path_info</a></code> without modifying the environment:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#pop_path_info" class="internal-link" title="werkzeug.wsgi.pop_path_info">pop​_path​_info</a></code></td>
    <td>Removes and returns the next segment of <code>PATH_INFO</code>, pushing it onto <code>SCRIPT_NAME</code>.  Returns <code>None</code> if there is nothing left on <code>PATH_INFO</code>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#responder" class="internal-link" title="werkzeug.wsgi.responder">responder</a></code></td>
    <td>Marks a function as responder.  Decorate a function with it and it will automatically call the return value as WSGI application.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#wrap_file" class="internal-link" title="werkzeug.wsgi.wrap_file">wrap​_file</a></code></td>
    <td>Wraps a file.  This uses the WSGI server's file wrapper if available or otherwise the generic <code><a href="werkzeug.wsgi.FileWrapper.html" class="internal-link" title="werkzeug.wsgi.FileWrapper">FileWrapper</a></code>.</td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="werkzeug.wsgi._RangeWrapper.html" class="internal-link" title="werkzeug.wsgi._RangeWrapper">_​Range​Wrapper</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_get_server" class="internal-link" title="werkzeug.wsgi._get_server">​_get​_server</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_make_chunk_iter" class="internal-link" title="werkzeug.wsgi._make_chunk_iter">​_make​_chunk​_iter</a></code></td>
    <td>Helper for the line and chunk iter functions.</td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basefunction">
  
  
  <a name="werkzeug.wsgi.extract_path_info">
    
  </a>
  <a name="extract_path_info">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">extract_path_info</span>(environ_or_baseurl, path_or_url, charset=<span class="rst-variable-quote">'</span><span class="rst-variable-string">utf-8</span><span class="rst-variable-quote">'</span>, errors=<span class="rst-variable-quote">'</span><span class="rst-variable-string">werkzeug.url_quote</span><span class="rst-variable-quote">'</span>, collapse_http_schemes=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Extracts the path info from the given URL (or WSGI environment) and
path. The path info returned is a string. The URLs might also be IRIs.</p>
<p>If the path info could not be determined, <code>None</code> is returned.</p>
<p>Some examples:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>extract_path_info(<span class="py-string">'http://example.com/app'</span>, <span class="py-string">'/app/hello'</span>)
<span class="py-output">'/hello'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>extract_path_info(<span class="py-string">'http://example.com/app'</span>,
<span class="py-more">... </span>                  <span class="py-string">'https://example.com/app/hello'</span>)
<span class="py-output">'/hello'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>extract_path_info(<span class="py-string">'http://example.com/app'</span>,
<span class="py-more">... </span>                  <span class="py-string">'https://example.com/app/hello'</span>,
<span class="py-more">... </span>                  collapse_http_schemes=<span class="py-builtin">False</span>) <span class="py-keyword">is</span> <span class="py-builtin">None</span>
<span class="py-output">True</span>
</pre><p>Instead of providing a base URL you can also pass a WSGI environment.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 0.15: </span><span>The <tt class="rst-docutils literal">errors</tt> parameter defaults to leaving invalid bytes
quoted instead of replacing them.</span></div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.6.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">environ​_or​_baseurl:</span><code>t.Union[<wbr></wbr>str, <wbr></wbr>WSGIEnvironment]</code></td><td class="fieldArgDesc">a WSGI environment dict, a base URL or
base IRI.  This is the root of the
application.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">path​_or​_url:</span><code>t.Union[<wbr></wbr>str, <wbr></wbr><a href="werkzeug.urls._URLTuple.html" class="internal-link" title="werkzeug.urls._URLTuple">_URLTuple</a>]</code></td><td class="fieldArgDesc">an absolute path from the server root, a
relative path (in which case it's the path info)
or a full URL.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">charset:</span><code>str</code></td><td class="fieldArgDesc">the charset for byte data in URLs</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">errors:</span><code>str</code></td><td class="fieldArgDesc">the error handling on decode</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">collapse​_http​_schemes:</span><code>bool</code></td><td class="fieldArgDesc">if set to <code>False</code> the algorithm does
not assume that http and https on the
same server point to the same
resource.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>t.Optional[<wbr></wbr>str]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.get_content_length">
    
  </a>
  <a name="get_content_length">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_content_length</span>(environ):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the content length from the WSGI environment as
integer. If it's not available or chunked transfer encoding is used,
<tt class="rst-docutils literal">None</tt> is returned.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.9.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">environ:</span><code>WSGIEnvironment</code></td><td class="fieldArgDesc">the WSGI environ to fetch the content length from.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>t.Optional[<wbr></wbr>int]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.get_current_url">
    
  </a>
  <a name="get_current_url">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_current_url</span>(environ, root_only=False, strip_querystring=False, host_only=False, trusted_hosts=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Recreate the URL for a request from the parts in a WSGI
environment.</p>
<p>The URL is an IRI, not a URI, so it may contain Unicode characters.
Use <code>~werkzeug.urls.iri_to_uri</code> to convert it to ASCII.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">environ:</span><code>WSGIEnvironment</code></td><td class="fieldArgDesc">The WSGI environment to get the URL parts from.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">root​_only:</span><code>bool</code></td><td class="fieldArgDesc">Only build the root path, don't include the
remaining path or query string.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">strip​_querystring:</span><code>bool</code></td><td class="fieldArgDesc">Don't include the query string.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">host​_only:</span><code>bool</code></td><td class="fieldArgDesc">Only build the scheme and host.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">trusted​_hosts:</span><code>t.Optional[<wbr></wbr>t.Iterable[<wbr></wbr>str]]</code></td><td class="fieldArgDesc">A list of trusted host names to validate the
host against.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.get_host">
    
  </a>
  <a name="get_host">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_host</span>(environ, trusted_hosts=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the host for the given WSGI environment.</p>
<p>The <tt class="rst-docutils literal">Host</tt> header is preferred, then <tt class="rst-docutils literal">SERVER_NAME</tt> if it's not
set. The returned host will only contain the port if it is different
than the standard port for the protocol.</p>
<p>Optionally, verify that the host is trusted using
<code><a href="werkzeug.sansio.utils.html#host_is_trusted" class="internal-link" title="werkzeug.sansio.utils.host_is_trusted">host_is_trusted</a></code> and raise a
<code>~werkzeug.exceptions.SecurityError</code> if it is not.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">environ:</span><code>WSGIEnvironment</code></td><td class="fieldArgDesc">A WSGI environment dict.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">trusted​_hosts:</span><code>t.Optional[<wbr></wbr>t.Iterable[<wbr></wbr>str]]</code></td><td class="fieldArgDesc">A list of trusted host names.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>str</code></td><td class="fieldArgDesc">Host, with port if necessary.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code>~werkzeug.exceptions.SecurityError</code></td><td>If the host is not
trusted.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.get_input_stream">
    
  </a>
  <a name="get_input_stream">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_input_stream</span>(environ, safe_fallback=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the input stream from the WSGI environment and wraps it
in the most sensible way possible. The stream returned is not the
raw WSGI stream in most cases but one that is safe to read from
without taking into account the content length.</p>
<p>If content length is not set, the stream will be empty for safety reasons.
If the WSGI server supports chunked or infinite streams, it should set
the <tt class="rst-docutils literal">wsgi.input_terminated</tt> value in the WSGI environ to indicate that.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.9.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">environ:</span><code>WSGIEnvironment</code></td><td class="fieldArgDesc">the WSGI environ to fetch the stream from.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">safe​_fallback:</span><code>bool</code></td><td class="fieldArgDesc">use an empty stream as a safe fallback when the
content length is not set. Disabling this allows infinite streams,
which can be a denial-of-service risk.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>t.IO[<wbr></wbr>bytes]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.get_path_info">
    
  </a>
  <a name="get_path_info">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_path_info</span>(environ, charset=<span class="rst-variable-quote">'</span><span class="rst-variable-string">utf-8</span><span class="rst-variable-quote">'</span>, errors=<span class="rst-variable-quote">'</span><span class="rst-variable-string">replace</span><span class="rst-variable-quote">'</span>):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the <tt class="rst-docutils literal">PATH_INFO</tt> from the WSGI environment and decode it
unless <tt class="rst-docutils literal">charset</tt> is <tt class="rst-docutils literal">None</tt>.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.9.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">environ:</span><code>WSGIEnvironment</code></td><td class="fieldArgDesc">WSGI environment to get the path from.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">charset:</span><code>str</code></td><td class="fieldArgDesc">The charset for the path info, or <tt class="rst-docutils literal">None</tt> if no
decoding should be performed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">errors:</span><code>str</code></td><td class="fieldArgDesc">The decoding error handling.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.get_query_string">
    
  </a>
  <a name="get_query_string">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_query_string</span>(environ):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the <tt class="rst-docutils literal">QUERY_STRING</tt> from the WSGI environment. This also
takes care of the WSGI decoding dance. The string returned will be
restricted to ASCII characters.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.9.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">environ:</span><code>WSGIEnvironment</code></td><td class="fieldArgDesc">WSGI environment to get the query string from.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.get_script_name">
    
  </a>
  <a name="get_script_name">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_script_name</span>(environ, charset=<span class="rst-variable-quote">'</span><span class="rst-variable-string">utf-8</span><span class="rst-variable-quote">'</span>, errors=<span class="rst-variable-quote">'</span><span class="rst-variable-string">replace</span><span class="rst-variable-quote">'</span>):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the <tt class="rst-docutils literal">SCRIPT_NAME</tt> from the WSGI environment and decode
it unless <code>charset</code> is set to <tt class="rst-docutils literal">None</tt>.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.9.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">environ:</span><code>WSGIEnvironment</code></td><td class="fieldArgDesc">WSGI environment to get the path from.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">charset:</span><code>str</code></td><td class="fieldArgDesc">The charset for the path, or <tt class="rst-docutils literal">None</tt> if no decoding
should be performed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">errors:</span><code>str</code></td><td class="fieldArgDesc">The decoding error handling.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.make_chunk_iter">
    
  </a>
  <a name="make_chunk_iter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">make_chunk_iter</span>(stream, separator, limit=None, buffer_size=10*1024, cap_at_buffer=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Works like <code><a href="#make_line_iter" class="internal-link" title="werkzeug.wsgi.make_line_iter">make_line_iter</a></code> but accepts a separator
which divides chunks.  If you want newline based processing
you should use <code><a href="#make_line_iter" class="internal-link" title="werkzeug.wsgi.make_line_iter">make_line_iter</a></code> instead as it
supports arbitrary newline markers.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.8.</span></div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.9: </span><span>added support for iterators as input stream.</span></div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.11.10: </span><span>added support for the <code>cap_at_buffer</code> parameter.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">stream:</span><code>t.Union[<wbr></wbr>t.Iterable[<wbr></wbr>bytes], <wbr></wbr>t.IO[<wbr></wbr>bytes]]</code></td><td class="fieldArgDesc">the stream or iterate to iterate over.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">separator:</span><code>bytes</code></td><td class="fieldArgDesc">the separator that divides chunks.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">limit:</span><code>t.Optional[<wbr></wbr>int]</code></td><td class="fieldArgDesc">the limit in bytes for the stream.  (Usually
content length.  Not necessary if the <code>stream</code>
is otherwise already limited).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">buffer​_size:</span><code>int</code></td><td class="fieldArgDesc">The optional buffer size.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cap​_at​_buffer:</span><code>bool</code></td><td class="fieldArgDesc">if this is set chunks are split if they are longer
than the buffer size.  Internally this is implemented
that the buffer size might be exhausted by a factor
of two however.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>t.Iterator[<wbr></wbr>bytes]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.make_line_iter">
    
  </a>
  <a name="make_line_iter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">make_line_iter</span>(stream, limit=None, buffer_size=10*1024, cap_at_buffer=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Safely iterates line-based over an input stream.  If the input stream
is not a <code><a href="werkzeug.wsgi.LimitedStream.html" class="internal-link" title="werkzeug.wsgi.LimitedStream">LimitedStream</a></code> the <code><a href="werkzeug.wsgi.LimitedStream.html#limit" class="internal-link" title="werkzeug.wsgi.LimitedStream.limit">limit</a></code> parameter is mandatory.</p>
<p>This uses the stream's <code>~file.read</code> method internally as opposite
to the <code>~file.readline</code> method that is unsafe and can only be used
in violation of the WSGI specification.  The same problem applies to the
<code>__iter__</code> function of the input stream which calls <code>~file.readline</code>
without arguments.</p>
<p>If you need line-by-line processing it's strongly recommended to iterate
over the input stream using this helper function.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 0.8: </span><span>This function now ensures that the limit was reached.</span></div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.9: </span><span>added support for iterators as input stream.</span></div>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.11.10: </span><span>added support for the <code>cap_at_buffer</code> parameter.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">stream:</span><code>t.Union[<wbr></wbr>t.Iterable[<wbr></wbr>bytes], <wbr></wbr>t.IO[<wbr></wbr>bytes]]</code></td><td class="fieldArgDesc">the stream or iterate to iterate over.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">limit:</span><code>t.Optional[<wbr></wbr>int]</code></td><td class="fieldArgDesc">the limit in bytes for the stream.  (Usually
content length.  Not necessary if the <code>stream</code>
is a <code><a href="werkzeug.wsgi.LimitedStream.html" class="internal-link" title="werkzeug.wsgi.LimitedStream">LimitedStream</a></code>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">buffer​_size:</span><code>int</code></td><td class="fieldArgDesc">The optional buffer size.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cap​_at​_buffer:</span><code>bool</code></td><td class="fieldArgDesc">if this is set chunks are split if they are longer
than the buffer size.  Internally this is implemented
that the buffer size might be exhausted by a factor
of two however.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>t.Iterator[<wbr></wbr>bytes]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.peek_path_info">
    
  </a>
  <a name="peek_path_info">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">peek_path_info</span>(environ, charset=<span class="rst-variable-quote">'</span><span class="rst-variable-string">utf-8</span><span class="rst-variable-quote">'</span>, errors=<span class="rst-variable-quote">'</span><span class="rst-variable-string">replace</span><span class="rst-variable-quote">'</span>):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the next segment on the <code>PATH_INFO</code> or <code>None</code> if there
is none.  Works like <code><a href="#pop_path_info" class="internal-link" title="werkzeug.wsgi.pop_path_info">pop_path_info</a></code> without modifying the
environment:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>env = {<span class="py-string">'SCRIPT_NAME'</span>: <span class="py-string">'/foo'</span>, <span class="py-string">'PATH_INFO'</span>: <span class="py-string">'/a/b'</span>}
<span class="py-prompt">&gt;&gt;&gt; </span>peek_path_info(env)
<span class="py-output">'a'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>peek_path_info(env)
<span class="py-output">'a'</span>
</pre><p>If the <code>charset</code> is set to <code>None</code> bytes are returned.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.5.</span></div>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 0.9: </span><span>The path is now decoded and a charset and encoding
parameter can be provided.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">environ:</span><code>WSGIEnvironment</code></td><td class="fieldArgDesc">the WSGI environment that is checked.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">charset:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">errors:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>t.Optional[<wbr></wbr>str]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.pop_path_info">
    
  </a>
  <a name="pop_path_info">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">pop_path_info</span>(environ, charset=<span class="rst-variable-quote">'</span><span class="rst-variable-string">utf-8</span><span class="rst-variable-quote">'</span>, errors=<span class="rst-variable-quote">'</span><span class="rst-variable-string">replace</span><span class="rst-variable-quote">'</span>):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Removes and returns the next segment of <code>PATH_INFO</code>, pushing it onto
<code>SCRIPT_NAME</code>.  Returns <code>None</code> if there is nothing left on <code>PATH_INFO</code>.</p>
<p>If the <code>charset</code> is set to <code>None</code> bytes are returned.</p>
<p>If there are empty segments (<tt class="rst-docutils literal"><span class="pre">'/foo//bar</span></tt>) these are ignored but
properly pushed to the <code>SCRIPT_NAME</code>:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>env = {<span class="py-string">'SCRIPT_NAME'</span>: <span class="py-string">'/foo'</span>, <span class="py-string">'PATH_INFO'</span>: <span class="py-string">'/a/b'</span>}
<span class="py-prompt">&gt;&gt;&gt; </span>pop_path_info(env)
<span class="py-output">'a'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>env[<span class="py-string">'SCRIPT_NAME'</span>]
<span class="py-output">'/foo/a'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>pop_path_info(env)
<span class="py-output">'b'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>env[<span class="py-string">'SCRIPT_NAME'</span>]
<span class="py-output">'/foo/a/b'</span>
</pre><div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.5.</span></div>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 0.9: </span><span>The path is now decoded and a charset and encoding
parameter can be provided.</span></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">environ:</span><code>WSGIEnvironment</code></td><td class="fieldArgDesc">the WSGI environment that is modified.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">charset:</span><code>str</code></td><td class="fieldArgDesc">The <tt class="rst-docutils literal">encoding</tt> parameter passed to
<code>bytes.decode</code>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">errors:</span><code>str</code></td><td class="fieldArgDesc">The <tt class="rst-docutils literal">errors</tt> paramater passed to
<code>bytes.decode</code>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>t.Optional[<wbr></wbr>str]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.responder">
    
  </a>
  <a name="responder">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">responder</span>(f):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Marks a function as responder.  Decorate a function with it and it
will automatically call the return value as WSGI application.</p>
<p>Example:</p>
<pre class="rst-literal-block">
@responder
def application(environ, start_response):
    return Response('Hello World!')
</pre>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f:</span><code>t.Callable[<wbr></wbr><span class="rst-variable-ellipsis">...</span>, <wbr></wbr>WSGIApplication]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>WSGIApplication</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="werkzeug.wsgi.wrap_file">
    
  </a>
  <a name="wrap_file">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">wrap_file</span>(environ, file, buffer_size=8192):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Wraps a file.  This uses the WSGI server's file wrapper if available
or otherwise the generic <code><a href="werkzeug.wsgi.FileWrapper.html" class="internal-link" title="werkzeug.wsgi.FileWrapper">FileWrapper</a></code>.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 0.5.</span></div>
<p>If the file wrapper from the WSGI server is used it's important to not
iterate over it from inside the application but to pass it through
unchanged.  If you want to pass out a file wrapper inside a response
object you have to set <code><a href="werkzeug.wrappers.response.Response.html#direct_passthrough" class="internal-link" title="werkzeug.wrappers.response.Response.direct_passthrough">Response.direct_passthrough</a></code> to <code>True</code>.</p>
<p>More information about file wrappers are available in <a class="rst-reference external" href="http://www.python.org/dev/peps/pep-0333" target="_top">PEP 333</a>.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">environ:</span><code>WSGIEnvironment</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">file:</span><code>t.IO[<wbr></wbr>bytes]</code></td><td class="fieldArgDesc">a <code><a href="werkzeug.wsgi.FileWrapper.html#file" class="internal-link" title="werkzeug.wsgi.FileWrapper.file">file</a></code>-like object with a <code>~file.read</code> method.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">buffer​_size:</span><code>int</code></td><td class="fieldArgDesc">number of bytes for one iteration.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>t.Iterable[<wbr></wbr>bytes]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="werkzeug.wsgi._get_server">
    
  </a>
  <a name="_get_server">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_get_server</span>(environ):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">environ:</span><code>WSGIEnvironment</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>t.Optional[<wbr></wbr>t.Tuple[<wbr></wbr>str, <wbr></wbr>t.Optional[<wbr></wbr>int]]]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="werkzeug.wsgi._make_chunk_iter">
    
  </a>
  <a name="_make_chunk_iter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_make_chunk_iter</span>(stream, limit, buffer_size):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Helper for the line and chunk iter functions.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">stream:</span><code>t.Union[<wbr></wbr>t.Iterable[<wbr></wbr>bytes], <wbr></wbr>t.IO[<wbr></wbr>bytes]]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">limit:</span><code>t.Optional[<wbr></wbr>int]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">buffer​_size:</span><code>int</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>t.Iterator[<wbr></wbr>bytes]</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for werkzeug,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 04:47:03.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>