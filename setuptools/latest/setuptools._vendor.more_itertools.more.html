<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>setuptools._vendor.more_itertools.more</title>
    <meta name="generator" content="pydoctor 22.2.0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    <div id="banner" class="container">    
    <div>
        <a href="https://pydocbrowser.github.io/">Home</a>
        &gt; setuptools-60.9.3 
        <!-- This is an important placeholder and will be 
            replaced by project name and version on building docs -->
        
        <!-- (<a href=""&gt;show all versions</a&gt;) -->
    </div>
</div>

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            setuptools <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="index.html" class="internal-link">setuptools</a></code><wbr></wbr>.<code><a href="setuptools._vendor.html" class="internal-link" title="setuptools._vendor">_vendor</a></code><wbr></wbr>.<code><a href="setuptools._vendor.more_itertools.html" class="internal-link" title="setuptools._vendor.more_itertools">more_itertools</a></code><wbr></wbr>.<code><a href="setuptools._vendor.more_itertools.more.html" class="internal-link" title="setuptools._vendor.more_itertools.more">more</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        <a href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py" class="sourceLink">(source)</a>
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="undocumented">Undocumented</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id16106">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.AbortThread.html" class="internal-link" title="setuptools._vendor.more_itertools.more.AbortThread">​Abort​Thread</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.bucket.html" class="internal-link" title="setuptools._vendor.more_itertools.more.bucket">bucket</a></code></td>
    <td>Wrap <em>iterable</em> and return an object that buckets it iterable into child iterables based on a <em>key</em> function.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.callback_iter.html" class="internal-link" title="setuptools._vendor.more_itertools.more.callback_iter">callback​_iter</a></code></td>
    <td>Convert a function that uses callbacks to an iterator.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.countable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.countable">countable</a></code></td>
    <td>Wrap <em>iterable</em> and keep a count of how many items have been consumed.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.islice_extended.html" class="internal-link" title="setuptools._vendor.more_itertools.more.islice_extended">islice​_extended</a></code></td>
    <td>An extension of <code><a href="https://docs.python.org/3/library/itertools.html#itertools.islice" class="intersphinx-link">itertools.islice</a></code> that supports negative values for <em>stop</em>, <em>start</em>, and <em>step</em>.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.numeric_range.html" class="internal-link" title="setuptools._vendor.more_itertools.more.numeric_range">numeric​_range</a></code></td>
    <td>An extension of the built-in <tt class="rst-docutils literal">range()</tt> function whose arguments can be any orderable numeric type.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.peekable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.peekable">peekable</a></code></td>
    <td>Wrap an iterator to allow lookahead and prepending elements.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.run_length.html" class="internal-link" title="setuptools._vendor.more_itertools.more.run_length">run​_length</a></code></td>
    <td><code><a href="#encode" class="internal-link" title="setuptools._vendor.more_itertools.more.run_length.encode">run_length.encode</a></code> compresses an iterable with run-length encoding. It yields groups of repeated items with the count of how many times they were repeated:</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.seekable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.seekable">seekable</a></code></td>
    <td>Wrap an iterator to allow for seeking backward and forward. This progressively caches the items in the source iterable so they can be re-visited.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.SequenceView.html" class="internal-link" title="setuptools._vendor.more_itertools.more.SequenceView">​Sequence​View</a></code></td>
    <td>Return a read-only view of the sequence object <em>target</em>.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.time_limited.html" class="internal-link" title="setuptools._vendor.more_itertools.more.time_limited">time​_limited</a></code></td>
    <td>Yield items from <em>iterable</em> until <em>limit_seconds</em> have passed. If the time limit expires before all items have been yielded, the <tt class="rst-docutils literal">timed_out</tt> parameter will be set to <tt class="rst-docutils literal">True</tt>.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="setuptools._vendor.more_itertools.more.UnequalIterablesError.html" class="internal-link" title="setuptools._vendor.more_itertools.more.UnequalIterablesError">​Unequal​Iterables​Error</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#adjacent" class="internal-link" title="setuptools._vendor.more_itertools.more.adjacent">adjacent</a></code></td>
    <td>Return an iterable over <code>(bool, item)</code> tuples where the <code>item</code> is drawn from <em>iterable</em> and the <code><a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a></code> indicates whether that item satisfies the <em>predicate</em> or is adjacent to an item that does.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#all_unique" class="internal-link" title="setuptools._vendor.more_itertools.more.all_unique">all​_unique</a></code></td>
    <td>Returns <tt class="rst-docutils literal">True</tt> if all the elements of <em>iterable</em> are unique (no two elements are equal).</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#always_iterable" class="internal-link" title="setuptools._vendor.more_itertools.more.always_iterable">always​_iterable</a></code></td>
    <td>If <em>obj</em> is iterable, return an iterator over its items:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#always_reversible" class="internal-link" title="setuptools._vendor.more_itertools.more.always_reversible">always​_reversible</a></code></td>
    <td>An extension of <code><a href="https://docs.python.org/3/library/functions.html#reversed" class="intersphinx-link">reversed</a></code> that supports all iterables, not just those which implement the <tt class="rst-docutils literal">Reversible</tt> or <tt class="rst-docutils literal">Sequence</tt> protocols.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#chunked" class="internal-link" title="setuptools._vendor.more_itertools.more.chunked">chunked</a></code></td>
    <td>Break <em>iterable</em> into lists of length <em>n</em>:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#circular_shifts" class="internal-link" title="setuptools._vendor.more_itertools.more.circular_shifts">circular​_shifts</a></code></td>
    <td>Return a list of circular shifts of <em>iterable</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#collapse" class="internal-link" title="setuptools._vendor.more_itertools.more.collapse">collapse</a></code></td>
    <td>Flatten an iterable with multiple levels of nesting (e.g., a list of lists of tuples) into non-iterable types.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#collate" class="internal-link" title="setuptools._vendor.more_itertools.more.collate">collate</a></code></td>
    <td>Return a sorted merge of the items from each of several already-sorted <em>iterables</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#combination_index" class="internal-link" title="setuptools._vendor.more_itertools.more.combination_index">combination​_index</a></code></td>
    <td>Equivalent to <tt class="rst-docutils literal">list(combinations(iterable, <span class="pre">r)).index(element)</span></tt></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#consecutive_groups" class="internal-link" title="setuptools._vendor.more_itertools.more.consecutive_groups">consecutive​_groups</a></code></td>
    <td>Yield groups of consecutive items using <code><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" class="intersphinx-link">itertools.groupby</a></code>. The <em>ordering</em> function determines whether two items are adjacent by returning their position.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#consumer" class="internal-link" title="setuptools._vendor.more_itertools.more.consumer">consumer</a></code></td>
    <td>Decorator that automatically advances a PEP-342-style "reverse iterator" to its first yield point so you don't have to call <tt class="rst-docutils literal">next()</tt> on it manually.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#count_cycle" class="internal-link" title="setuptools._vendor.more_itertools.more.count_cycle">count​_cycle</a></code></td>
    <td>Cycle through the items from <em>iterable</em> up to <em>n</em> times, yielding the number of completed cycles along with each item. If <em>n</em> is omitted the process repeats indefinitely.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#difference" class="internal-link" title="setuptools._vendor.more_itertools.more.difference">difference</a></code></td>
    <td>This function is the inverse of <code><a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" class="intersphinx-link">itertools.accumulate</a></code>. By default it will compute the first difference of <em>iterable</em> using <code><a href="https://docs.python.org/3/library/operator.html#operator.sub" class="intersphinx-link">operator.sub</a></code>:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#distinct_combinations" class="internal-link" title="setuptools._vendor.more_itertools.more.distinct_combinations">distinct​_combinations</a></code></td>
    <td>Yield the distinct combinations of <em>r</em> items taken from <em>iterable</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#distinct_permutations" class="internal-link" title="setuptools._vendor.more_itertools.more.distinct_permutations">distinct​_permutations</a></code></td>
    <td>Yield successive distinct permutations of the elements in <em>iterable</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#distribute" class="internal-link" title="setuptools._vendor.more_itertools.more.distribute">distribute</a></code></td>
    <td>Distribute the items from <em>iterable</em> among <em>n</em> smaller iterables.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#divide" class="internal-link" title="setuptools._vendor.more_itertools.more.divide">divide</a></code></td>
    <td>Divide the elements from <em>iterable</em> into <em>n</em> parts, maintaining order.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#exactly_n" class="internal-link" title="setuptools._vendor.more_itertools.more.exactly_n">exactly​_n</a></code></td>
    <td>Return <tt class="rst-docutils literal">True</tt> if exactly <tt class="rst-docutils literal">n</tt> items in the iterable are <tt class="rst-docutils literal">True</tt> according to the <em>predicate</em> function.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#filter_except" class="internal-link" title="setuptools._vendor.more_itertools.more.filter_except">filter​_except</a></code></td>
    <td>Yield the items from <em>iterable</em> for which the <em>validator</em> function does not raise one of the specified <em>exceptions</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#first" class="internal-link" title="setuptools._vendor.more_itertools.more.first">first</a></code></td>
    <td>Return the first item of <em>iterable</em>, or <em>default</em> if <em>iterable</em> is empty.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#groupby_transform" class="internal-link" title="setuptools._vendor.more_itertools.more.groupby_transform">groupby​_transform</a></code></td>
    <td>An extension of <code><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" class="intersphinx-link">itertools.groupby</a></code> that can apply transformations to the grouped data.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#ichunked" class="internal-link" title="setuptools._vendor.more_itertools.more.ichunked">ichunked</a></code></td>
    <td>Break <em>iterable</em> into sub-iterables with <em>n</em> elements each. <code><a href="#ichunked" class="internal-link" title="setuptools._vendor.more_itertools.more.ichunked">ichunked</a></code> is like <code><a href="#chunked" class="internal-link" title="setuptools._vendor.more_itertools.more.chunked">chunked</a></code>, but it yields iterables instead of lists.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#ilen" class="internal-link" title="setuptools._vendor.more_itertools.more.ilen">ilen</a></code></td>
    <td>Return the number of items in <em>iterable</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#interleave" class="internal-link" title="setuptools._vendor.more_itertools.more.interleave">interleave</a></code></td>
    <td>Return a new iterable yielding from each iterable in turn, until the shortest is exhausted.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#interleave_longest" class="internal-link" title="setuptools._vendor.more_itertools.more.interleave_longest">interleave​_longest</a></code></td>
    <td>Return a new iterable yielding from each iterable in turn, skipping any that are exhausted.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#intersperse" class="internal-link" title="setuptools._vendor.more_itertools.more.intersperse">intersperse</a></code></td>
    <td>Intersperse filler element <em>e</em> among the items in <em>iterable</em>, leaving <em>n</em> items between each filler element.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#is_sorted" class="internal-link" title="setuptools._vendor.more_itertools.more.is_sorted">is​_sorted</a></code></td>
    <td>Returns <tt class="rst-docutils literal">True</tt> if the items of iterable are in sorted order, and <tt class="rst-docutils literal">False</tt> otherwise. <em>key</em> and <em>reverse</em> have the same meaning that they do in the built-in <code><a href="https://docs.python.org/3/library/functions.html#sorted" class="intersphinx-link">sorted</a></code> function.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#iterate" class="internal-link" title="setuptools._vendor.more_itertools.more.iterate">iterate</a></code></td>
    <td>Return <tt class="rst-docutils literal">start</tt>, <tt class="rst-docutils literal">func(start)</tt>, <tt class="rst-docutils literal">func(func(start))</tt>, ...</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#last" class="internal-link" title="setuptools._vendor.more_itertools.more.last">last</a></code></td>
    <td>Return the last item of <em>iterable</em>, or <em>default</em> if <em>iterable</em> is empty.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#locate" class="internal-link" title="setuptools._vendor.more_itertools.more.locate">locate</a></code></td>
    <td>Yield the index of each item in <em>iterable</em> for which <em>pred</em> returns <tt class="rst-docutils literal">True</tt>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#lstrip" class="internal-link" title="setuptools._vendor.more_itertools.more.lstrip">lstrip</a></code></td>
    <td>Yield the items from <em>iterable</em>, but strip any from the beginning for which <em>pred</em> returns <tt class="rst-docutils literal">True</tt>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#make_decorator" class="internal-link" title="setuptools._vendor.more_itertools.more.make_decorator">make​_decorator</a></code></td>
    <td>Return a decorator version of <em>wrapping_func</em>, which is a function that modifies an iterable. <em>result_index</em> is the position in that function's signature where the iterable goes.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#map_except" class="internal-link" title="setuptools._vendor.more_itertools.more.map_except">map​_except</a></code></td>
    <td>Transform each item from <em>iterable</em> with <em>function</em> and yield the result, unless <em>function</em> raises one of the specified <em>exceptions</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#map_reduce" class="internal-link" title="setuptools._vendor.more_itertools.more.map_reduce">map​_reduce</a></code></td>
    <td>Return a dictionary that maps the items in <em>iterable</em> to categories defined by <em>keyfunc</em>, transforms them with <em>valuefunc</em>, and then summarizes them by category with <em>reducefunc</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#mark_ends" class="internal-link" title="setuptools._vendor.more_itertools.more.mark_ends">mark​_ends</a></code></td>
    <td>Yield 3-tuples of the form <tt class="rst-docutils literal">(is_first, is_last, item)</tt>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#nth_or_last" class="internal-link" title="setuptools._vendor.more_itertools.more.nth_or_last">nth​_or​_last</a></code></td>
    <td>Return the nth or the last item of <em>iterable</em>, or <em>default</em> if <em>iterable</em> is empty.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#nth_permutation" class="internal-link" title="setuptools._vendor.more_itertools.more.nth_permutation">nth​_permutation</a></code></td>
    <td>Equivalent to <tt class="rst-docutils literal">list(permutations(iterable, <span class="pre">r))[index]`</span></tt></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#nth_product" class="internal-link" title="setuptools._vendor.more_itertools.more.nth_product">nth​_product</a></code></td>
    <td>Equivalent to <tt class="rst-docutils literal"><span class="pre">list(product(*args))[index]</span></tt>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#one" class="internal-link" title="setuptools._vendor.more_itertools.more.one">one</a></code></td>
    <td>Return the first item from <em>iterable</em>, which is expected to contain only that item. Raise an exception if <em>iterable</em> is empty or has more than one item.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#only" class="internal-link" title="setuptools._vendor.more_itertools.more.only">only</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#padded" class="internal-link" title="setuptools._vendor.more_itertools.more.padded">padded</a></code></td>
    <td>Yield the elements from <em>iterable</em>, followed by <em>fillvalue</em>, such that at least <em>n</em> items are emitted.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#partitions" class="internal-link" title="setuptools._vendor.more_itertools.more.partitions">partitions</a></code></td>
    <td>Yield all possible order-preserving partitions of <em>iterable</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#permutation_index" class="internal-link" title="setuptools._vendor.more_itertools.more.permutation_index">permutation​_index</a></code></td>
    <td>Equivalent to <tt class="rst-docutils literal">list(permutations(iterable, <span class="pre">r)).index(element)`</span></tt></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#product_index" class="internal-link" title="setuptools._vendor.more_itertools.more.product_index">product​_index</a></code></td>
    <td>Equivalent to <tt class="rst-docutils literal"><span class="pre">list(product(*args)).index(element)</span></tt></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#repeat_last" class="internal-link" title="setuptools._vendor.more_itertools.more.repeat_last">repeat​_last</a></code></td>
    <td>After the <em>iterable</em> is exhausted, keep yielding its last element.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#replace" class="internal-link" title="setuptools._vendor.more_itertools.more.replace">replace</a></code></td>
    <td>Yield the items from <em>iterable</em>, replacing the items for which <em>pred</em> returns <tt class="rst-docutils literal">True</tt> with the items from the iterable <em>substitutes</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#rlocate" class="internal-link" title="setuptools._vendor.more_itertools.more.rlocate">rlocate</a></code></td>
    <td>Yield the index of each item in <em>iterable</em> for which <em>pred</em> returns <tt class="rst-docutils literal">True</tt>, starting from the right and moving left.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#rstrip" class="internal-link" title="setuptools._vendor.more_itertools.more.rstrip">rstrip</a></code></td>
    <td>Yield the items from <em>iterable</em>, but strip any from the end for which <em>pred</em> returns <tt class="rst-docutils literal">True</tt>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#sample" class="internal-link" title="setuptools._vendor.more_itertools.more.sample">sample</a></code></td>
    <td>Return a <em>k</em>-length list of elements chosen (without replacement) from the <em>iterable</em>. Like <code><a href="https://docs.python.org/3/library/random.html#random.sample" class="intersphinx-link">random.sample</a></code>, but works on iterables of unknown length.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#set_partitions" class="internal-link" title="setuptools._vendor.more_itertools.more.set_partitions">set​_partitions</a></code></td>
    <td>Yield the set partitions of <em>iterable</em> into <em>k</em> parts. Set partitions are not order-preserving.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#side_effect" class="internal-link" title="setuptools._vendor.more_itertools.more.side_effect">side​_effect</a></code></td>
    <td>Invoke <em>func</em> on each item in <em>iterable</em> (or on each <em>chunk_size</em> group of items) before yielding the item.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#sliced" class="internal-link" title="setuptools._vendor.more_itertools.more.sliced">sliced</a></code></td>
    <td>Yield slices of length <em>n</em> from the sequence <em>seq</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#sort_together" class="internal-link" title="setuptools._vendor.more_itertools.more.sort_together">sort​_together</a></code></td>
    <td>Return the input iterables sorted together, with <em>key_list</em> as the priority for sorting. All iterables are trimmed to the length of the shortest one.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#split_after" class="internal-link" title="setuptools._vendor.more_itertools.more.split_after">split​_after</a></code></td>
    <td>Yield lists of items from <em>iterable</em>, where each list ends with an item where callable <em>pred</em> returns <tt class="rst-docutils literal">True</tt>:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#split_at" class="internal-link" title="setuptools._vendor.more_itertools.more.split_at">split​_at</a></code></td>
    <td>Yield lists of items from <em>iterable</em>, where each list is delimited by an item where callable <em>pred</em> returns <tt class="rst-docutils literal">True</tt>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#split_before" class="internal-link" title="setuptools._vendor.more_itertools.more.split_before">split​_before</a></code></td>
    <td>Yield lists of items from <em>iterable</em>, where each list ends just before an item for which callable <em>pred</em> returns <tt class="rst-docutils literal">True</tt>:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#split_into" class="internal-link" title="setuptools._vendor.more_itertools.more.split_into">split​_into</a></code></td>
    <td>Yield a list of sequential items from <em>iterable</em> of length 'n' for each integer 'n' in <em>sizes</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#split_when" class="internal-link" title="setuptools._vendor.more_itertools.more.split_when">split​_when</a></code></td>
    <td>Split <em>iterable</em> into pieces based on the output of <em>pred</em>. <em>pred</em> should be a function that takes successive pairs of items and returns <tt class="rst-docutils literal">True</tt> if the iterable should be split in between them.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#spy" class="internal-link" title="setuptools._vendor.more_itertools.more.spy">spy</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#stagger" class="internal-link" title="setuptools._vendor.more_itertools.more.stagger">stagger</a></code></td>
    <td>Yield tuples whose elements are offset from <em>iterable</em>. The amount by which the <code>i</code>-th item in each tuple is offset is given by the <code>i</code>-th item in <em>offsets</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#strip" class="internal-link" title="setuptools._vendor.more_itertools.more.strip">strip</a></code></td>
    <td>Yield the items from <em>iterable</em>, but strip any from the beginning and end for which <em>pred</em> returns <tt class="rst-docutils literal">True</tt>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#substrings" class="internal-link" title="setuptools._vendor.more_itertools.more.substrings">substrings</a></code></td>
    <td>Yield all of the substrings of <em>iterable</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#substrings_indexes" class="internal-link" title="setuptools._vendor.more_itertools.more.substrings_indexes">substrings​_indexes</a></code></td>
    <td>Yield all substrings and their positions in <em>seq</em></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#unique_to_each" class="internal-link" title="setuptools._vendor.more_itertools.more.unique_to_each">unique​_to​_each</a></code></td>
    <td>Return the elements from each of the input iterables that aren't in the other input iterables.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#unzip" class="internal-link" title="setuptools._vendor.more_itertools.more.unzip">unzip</a></code></td>
    <td>The inverse of <code><a href="https://docs.python.org/3/library/functions.html#zip" class="intersphinx-link">zip</a></code>, this function disaggregates the elements of the zipped <em>iterable</em>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#value_chain" class="internal-link" title="setuptools._vendor.more_itertools.more.value_chain">value​_chain</a></code></td>
    <td>Yield all arguments passed to the function in the same order in which they were passed. If an argument itself is iterable then iterate over its values.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#windowed" class="internal-link" title="setuptools._vendor.more_itertools.more.windowed">windowed</a></code></td>
    <td>Return a sliding window of width <em>n</em> over the given iterable.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#windowed_complete" class="internal-link" title="setuptools._vendor.more_itertools.more.windowed_complete">windowed​_complete</a></code></td>
    <td>Yield <tt class="rst-docutils literal">(beginning, middle, end)</tt> tuples, where:</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#with_iter" class="internal-link" title="setuptools._vendor.more_itertools.more.with_iter">with​_iter</a></code></td>
    <td>Wrap an iterable in a <tt class="rst-docutils literal">with</tt> statement, so it closes once exhausted.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#zip_equal" class="internal-link" title="setuptools._vendor.more_itertools.more.zip_equal">zip​_equal</a></code></td>
    <td><tt class="rst-docutils literal">zip</tt> the input <em>iterables</em> together, but raise <tt class="rst-docutils literal">UnequalIterablesError</tt> if they aren't all the same length.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#zip_offset" class="internal-link" title="setuptools._vendor.more_itertools.more.zip_offset">zip​_offset</a></code></td>
    <td><tt class="rst-docutils literal">zip</tt> the input <em>iterables</em> together, but offset the <code>i</code>-th iterable by the <code>i</code>-th item in <em>offsets</em>.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_islice_helper" class="internal-link" title="setuptools._vendor.more_itertools.more._islice_helper">​_islice​_helper</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_sample_unweighted" class="internal-link" title="setuptools._vendor.more_itertools.more._sample_unweighted">​_sample​_unweighted</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_sample_weighted" class="internal-link" title="setuptools._vendor.more_itertools.more._sample_weighted">​_sample​_weighted</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_zip_equal_generator" class="internal-link" title="setuptools._vendor.more_itertools.more._zip_equal_generator">​_zip​_equal​_generator</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#_marker" class="internal-link" title="setuptools._vendor.more_itertools.more._marker">​_marker</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.adjacent">
    
  </a>
  <a name="adjacent">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">adjacent</span>(predicate, iterable, distance=1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1804">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return an iterable over <code>(bool, item)</code> tuples where the <code>item</code> is
drawn from <em>iterable</em> and the <code><a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a></code> indicates whether
that item satisfies the <em>predicate</em> or is adjacent to an item that does.</p>
<p>For example, to find whether items are adjacent to a <tt class="rst-docutils literal">3</tt>:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; list(adjacent(lambda x: x == 3, range(6)))
[(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]
</pre>
<p>Set <em>distance</em> to change what counts as adjacent. For example, to find
whether items are two places away from a <tt class="rst-docutils literal">3</tt>:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(adjacent(<span class="py-keyword">lambda</span> x: x == 3, <span class="py-builtin">range</span>(6), distance=2))
<span class="py-output">[(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]</span>
</pre></blockquote>
<p>This is useful for contextualizing the results of a search function.
For example, a code comparison tool might want to identify lines that
have changed, but also surrounding lines to give the viewer of the diff
context.</p>
<p>The predicate function will only be called once for each item in the
iterable.</p>
<p>See also <code><a href="#groupby_transform" class="internal-link" title="setuptools._vendor.more_itertools.more.groupby_transform">groupby_transform</a></code>, which can be used with this function
to group ranges of items with the same <code><a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a></code> value.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.all_unique">
    
  </a>
  <a name="all_unique">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">all_unique</span>(iterable, key=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3563">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns <tt class="rst-docutils literal">True</tt> if all the elements of <em>iterable</em> are unique (no two
elements are equal).</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>all_unique(<span class="py-string">'ABCB'</span>)
<span class="py-output">False</span>
</pre></blockquote>
<p>If a <em>key</em> function is specified, it will be used to make comparisons.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>all_unique(<span class="py-string">'ABCb'</span>)
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>all_unique(<span class="py-string">'ABCb'</span>, <span class="py-builtin">str</span>.lower)
<span class="py-output">False</span>
</pre></blockquote>
<p>The function returns as soon as the first non-unique element is
encountered. Iterables with a mix of hashable and unhashable items can
be used, but the function will be slower for unhashable items.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.always_iterable">
    
  </a>
  <a name="always_iterable">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">always_iterable</span>(obj, base_type=(<wbr></wbr><a href="https://docs.python.org/3/library/stdtypes.html#str" class="intersphinx-link">str</a>, <wbr></wbr><a href="https://docs.python.org/3/library/stdtypes.html#bytes" class="intersphinx-link">bytes</a>)):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1751">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>If <em>obj</em> is iterable, return an iterator over its items:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; obj = (1, 2, 3)
&gt;&gt;&gt; list(always_iterable(obj))
[1, 2, 3]
</pre>
<p>If <em>obj</em> is not iterable, return a one-item iterable containing <em>obj</em>:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; obj = 1
&gt;&gt;&gt; list(always_iterable(obj))
[1]
</pre>
<p>If <em>obj</em> is <tt class="rst-docutils literal">None</tt>, return an empty iterable:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>obj = <span class="py-builtin">None</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(always_iterable(<span class="py-builtin">None</span>))
<span class="py-output">[]</span>
</pre></blockquote>
<p>By default, binary and text strings are not considered iterable:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; obj = 'foo'
&gt;&gt;&gt; list(always_iterable(obj))
['foo']
</pre>
<p>If <em>base_type</em> is set, objects for which <tt class="rst-docutils literal">isinstance(obj, base_type)</tt>
returns <tt class="rst-docutils literal">True</tt> won't be considered iterable.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>obj = {<span class="py-string">'a'</span>: 1}
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(always_iterable(obj))  <span class="py-comment"># Iterate over the dict's keys</span>
<span class="py-output">['a']</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(always_iterable(obj, base_type=<span class="py-builtin">dict</span>))  <span class="py-comment"># Treat dicts as a unit</span>
<span class="py-output">[{'a': 1}]</span>
</pre></blockquote>
<p>Set <em>base_type</em> to <tt class="rst-docutils literal">None</tt> to avoid any special handling and treat objects
Python considers iterable as iterable:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>obj = <span class="py-string">'foo'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(always_iterable(obj, base_type=<span class="py-builtin">None</span>))
<span class="py-output">['f', 'o', 'o']</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.always_reversible">
    
  </a>
  <a name="always_reversible">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">always_reversible</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2409">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>An extension of <code><a href="https://docs.python.org/3/library/functions.html#reversed" class="intersphinx-link">reversed</a></code> that supports all iterables, not
just those which implement the <tt class="rst-docutils literal">Reversible</tt> or <tt class="rst-docutils literal">Sequence</tt> protocols.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">print</span>(*always_reversible(x <span class="py-keyword">for</span> x <span class="py-keyword">in</span> <span class="py-builtin">range</span>(3)))
<span class="py-output">2 1 0</span>
</pre></blockquote>
<p>If the iterable is already reversible, this function returns the
result of <code><a href="https://docs.python.org/3/library/functions.html#reversed" class="intersphinx-link">reversed()</a></code>. If the iterable is not reversible,
this function will cache the remaining items in the iterable and
yield them in reverse order, which may require significant storage.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.chunked">
    
  </a>
  <a name="chunked">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">chunked</span>(iterable, n, strict=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L126">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Break <em>iterable</em> into lists of length <em>n</em>:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(chunked([1, 2, 3, 4, 5, 6], 3))
<span class="py-output">[[1, 2, 3], [4, 5, 6]]</span>
</pre></blockquote>
<p>By the default, the last yielded list will have fewer than <em>n</em> elements
if the length of <em>iterable</em> is not divisible by <em>n</em>:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))
<span class="py-output">[[1, 2, 3], [4, 5, 6], [7, 8]]</span>
</pre></blockquote>
<p>To use a fill-in value instead, see the <code><a href="setuptools._vendor.more_itertools.recipes.html#grouper" class="internal-link" title="setuptools._vendor.more_itertools.recipes.grouper">grouper</a></code> recipe.</p>
<p>If the length of <em>iterable</em> is not divisible by <em>n</em> and <em>strict</em> is
<tt class="rst-docutils literal">True</tt>, then <tt class="rst-docutils literal">ValueError</tt> will be raised before the last
list is yielded.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.circular_shifts">
    
  </a>
  <a name="circular_shifts">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">circular_shifts</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2749">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a list of circular shifts of <em>iterable</em>.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>circular_shifts(<span class="py-builtin">range</span>(4))
<span class="py-output">[(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.collapse">
    
  </a>
  <a name="collapse">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">collapse</span>(iterable, base_type=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, levels=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1019">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Flatten an iterable with multiple levels of nesting (e.g., a list of
lists of tuples) into non-iterable types.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [(1, 2), ([3, 4], [[5], [6]])]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collapse(iterable))
<span class="py-output">[1, 2, 3, 4, 5, 6]</span>
</pre></blockquote>
<p>Binary and text strings are not considered iterable and
will not be collapsed.</p>
<p>To avoid collapsing other types, specify <em>base_type</em>:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [<span class="py-string">'ab'</span>, (<span class="py-string">'cd'</span>, <span class="py-string">'ef'</span>), [<span class="py-string">'gh'</span>, <span class="py-string">'ij'</span>]]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collapse(iterable, base_type=<span class="py-builtin">tuple</span>))
<span class="py-output">['ab', ('cd', 'ef'), 'gh', 'ij']</span>
</pre></blockquote>
<p>Specify <em>levels</em> to stop flattening after a certain level:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [(<span class="py-string">'a'</span>, [<span class="py-string">'b'</span>]), (<span class="py-string">'c'</span>, [<span class="py-string">'d'</span>])]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collapse(iterable))  <span class="py-comment"># Fully flattened</span>
<span class="py-output">['a', 'b', 'c', 'd']</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collapse(iterable, levels=1))  <span class="py-comment"># Only one level flattened</span>
<span class="py-output">['a', ['b'], 'c', ['d']]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.collate">
    
  </a>
  <a name="collate">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">collate</span>(*iterables, **kwargs):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L398">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a sorted merge of the items from each of several already-sorted
<em>iterables</em>.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collate(<span class="py-string">'ACDZ'</span>, <span class="py-string">'AZ'</span>, <span class="py-string">'JKL'</span>))
<span class="py-output">['A', 'A', 'C', 'D', 'J', 'K', 'L', 'Z', 'Z']</span>
</pre></blockquote>
<p>Works lazily, keeping only the next value from each iterable in memory. Use
<code><a href="#collate" class="internal-link" title="setuptools._vendor.more_itertools.more.collate">collate</a></code> to, for example, perform a n-way mergesort of items that
don't fit in memory.</p>
<p>If a <em>key</em> function is specified, the iterables will be sorted according
to its result:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>key = <span class="py-keyword">lambda</span> s: <span class="py-builtin">int</span>(s)  <span class="py-comment"># Sort by numeric value, not by string</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collate([<span class="py-string">'1'</span>, <span class="py-string">'10'</span>], [<span class="py-string">'2'</span>, <span class="py-string">'11'</span>], key=key))
<span class="py-output">['1', '2', '10', '11']</span>
</pre></blockquote>
<p>If the <em>iterables</em> are sorted in descending order, set <em>reverse</em> to
<tt class="rst-docutils literal">True</tt>:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(collate([5, 3, 1], [4, 2, 0], reverse=<span class="py-builtin">True</span>))
<span class="py-output">[5, 4, 3, 2, 1, 0]</span>
</pre></blockquote>
<p>If the elements of the passed-in iterables are out of order, you might get
unexpected results.</p>
<p>On Python 3.5+, this function is an alias for <code><a href="https://docs.python.org/3/library/heapq.html#heapq.merge" class="intersphinx-link">heapq.merge</a></code>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.combination_index">
    
  </a>
  <a name="combination_index">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">combination_index</span>(element, iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3728">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Equivalent to <tt class="rst-docutils literal">list(combinations(iterable, <span class="pre">r)).index(element)</span></tt></p>
<p>The subsequences of <em>iterable</em> that are of length <em>r</em> can be ordered
lexicographically. <code><a href="#combination_index" class="internal-link" title="setuptools._vendor.more_itertools.more.combination_index">combination_index</a></code> computes the index of the
first <em>element</em>, without computing the previous combinations.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>combination_index(<span class="py-string">'adf'</span>, <span class="py-string">'abcdefg'</span>)
<span class="py-output">10</span>
</pre></blockquote>
<p><tt class="rst-docutils literal">ValueError</tt> will be raised if the given <em>element</em> isn't one of the
combinations of <em>iterable</em>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.consecutive_groups">
    
  </a>
  <a name="consecutive_groups">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">consecutive_groups</span>(iterable, ordering=(lambda x: x)):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2427">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield groups of consecutive items using <code><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" class="intersphinx-link">itertools.groupby</a></code>.
The <em>ordering</em> function determines whether two items are adjacent by
returning their position.</p>
<p>By default, the ordering function is the identity function. This is
suitable for finding runs of numbers:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> group <span class="py-keyword">in</span> consecutive_groups(iterable):
<span class="py-more">... </span>    <span class="py-builtin">print</span>(<span class="py-builtin">list</span>(group))
<span class="py-output">[1]</span>
<span class="py-output">[10, 11, 12]</span>
<span class="py-output">[20]</span>
<span class="py-output">[30, 31, 32, 33]</span>
<span class="py-output">[40]</span>
</pre></blockquote>
<p>For finding runs of adjacent letters, try using the <code><a href="setuptools._vendor.more_itertools.more.numeric_range.html#index" class="internal-link" title="setuptools._vendor.more_itertools.more.numeric_range.index">index</a></code> method
of a string of letters:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> string <span class="py-keyword">import</span> ascii_lowercase
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-string">'abcdfgilmnop'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>ordering = ascii_lowercase.index
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> group <span class="py-keyword">in</span> consecutive_groups(iterable, ordering):
<span class="py-more">... </span>    <span class="py-builtin">print</span>(<span class="py-builtin">list</span>(group))
<span class="py-output">['a', 'b', 'c', 'd']</span>
<span class="py-output">['f', 'g']</span>
<span class="py-output">['i']</span>
<span class="py-output">['l', 'm', 'n', 'o', 'p']</span>
</pre></blockquote>
<p>Each group of consecutive items is an iterator that shares it source with
<em>iterable</em>. When an an output group is advanced, the previous group is
no longer available unless its elements are copied (e.g., into a <tt class="rst-docutils literal">list</tt>).</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 2, 11, 12, 21, 22]
<span class="py-prompt">&gt;&gt;&gt; </span>saved_groups = []
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> group <span class="py-keyword">in</span> consecutive_groups(iterable):
<span class="py-more">... </span>    saved_groups.append(<span class="py-builtin">list</span>(group))  <span class="py-comment"># Copy group elements</span>
<span class="py-prompt">&gt;&gt;&gt; </span>saved_groups
<span class="py-output">[[1, 2], [11, 12], [21, 22]]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.consumer">
    
  </a>
  <a name="consumer">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">consumer</span>(func):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L436">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Decorator that automatically advances a PEP-342-style "reverse iterator"
to its first yield point so you don't have to call <tt class="rst-docutils literal">next()</tt> on it
manually.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>@consumer
<span class="py-more">... </span><span class="py-keyword">def</span> <span class="py-defname">tally</span>():
<span class="py-more">... </span>    i = 0
<span class="py-more">... </span>    <span class="py-keyword">while</span> <span class="py-builtin">True</span>:
<span class="py-more">... </span>        <span class="py-builtin">print</span>(<span class="py-string">'Thing number %s is %s.'</span> % (i, (<span class="py-keyword">yield</span>)))
<span class="py-more">... </span>        i += 1
<span class="py-more">...</span>
<span class="py-prompt">&gt;&gt;&gt; </span>t = tally()
<span class="py-prompt">&gt;&gt;&gt; </span>t.send(<span class="py-string">'red'</span>)
<span class="py-output">Thing number 0 is red.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>t.send(<span class="py-string">'fish'</span>)
<span class="py-output">Thing number 1 is fish.</span>
</pre></blockquote>
<p>Without the decorator, you would have to call <tt class="rst-docutils literal">next(t)</tt> before
<tt class="rst-docutils literal">t.send()</tt> could be used.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.count_cycle">
    
  </a>
  <a name="count_cycle">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">count_cycle</span>(iterable, n=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2105">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Cycle through the items from <em>iterable</em> up to <em>n</em> times, yielding
the number of completed cycles along with each item. If <em>n</em> is omitted the
process repeats indefinitely.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(count_cycle(<span class="py-string">'AB'</span>, 3))
<span class="py-output">[(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.difference">
    
  </a>
  <a name="difference">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">difference</span>(iterable, func=<a href="https://docs.python.org/3/library/operator.html#operator.sub" class="intersphinx-link">sub</a>, *, initial=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2475">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>This function is the inverse of <code><a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" class="intersphinx-link">itertools.accumulate</a></code>. By default
it will compute the first difference of <em>iterable</em> using
<code><a href="https://docs.python.org/3/library/operator.html#operator.sub" class="intersphinx-link">operator.sub</a></code>:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> itertools <span class="py-keyword">import</span> accumulate
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = accumulate([0, 1, 2, 3, 4])  <span class="py-comment"># produces 0, 1, 3, 6, 10</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(difference(iterable))
<span class="py-output">[0, 1, 2, 3, 4]</span>
</pre></blockquote>
<p><em>func</em> defaults to <code><a href="https://docs.python.org/3/library/operator.html#operator.sub" class="intersphinx-link">operator.sub</a></code>, but other functions can be
specified. They will be applied as follows:</p>
<pre class="rst-literal-block">
A, B, C, D, ... --&gt; A, func(B, A), func(C, B), func(D, C), ...
</pre>
<p>For example, to do progressive division:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 2, 6, 24, 120]
<span class="py-prompt">&gt;&gt;&gt; </span>func = <span class="py-keyword">lambda</span> x, y: x // y
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(difference(iterable, func))
<span class="py-output">[1, 2, 3, 4, 5]</span>
</pre></blockquote>
<p>If the <em>initial</em> keyword is set, the first element will be skipped when
computing successive differences.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>it = [10, 11, 13, 16]  <span class="py-comment"># from accumulate([1, 2, 3], initial=10)</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(difference(it, initial=10))
<span class="py-output">[1, 2, 3]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.distinct_combinations">
    
  </a>
  <a name="distinct_combinations">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">distinct_combinations</span>(iterable, r):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3194">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the distinct combinations of <em>r</em> items taken from <em>iterable</em>.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(distinct_combinations([0, 0, 1], 2))
<span class="py-output">[(0, 0), (0, 1)]</span>
</pre></blockquote>
<p>Equivalent to <tt class="rst-docutils literal">set(combinations(iterable))</tt>, except duplicates are not
generated and thrown away. For larger input sequences this is much more
efficient.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.distinct_permutations">
    
  </a>
  <a name="distinct_permutations">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">distinct_permutations</span>(iterable, r=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L580">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield successive distinct permutations of the elements in <em>iterable</em>.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(distinct_permutations([1, 0, 1]))
<span class="py-output">[(0, 1, 1), (1, 0, 1), (1, 1, 0)]</span>
</pre></blockquote>
<p>Equivalent to <tt class="rst-docutils literal">set(permutations(iterable))</tt>, except duplicates are not
generated and thrown away. For larger input sequences this is much more
efficient.</p>
<p>Duplicate permutations arise when there are duplicated elements in the
input iterable. The number of items returned is
<code>n! / (x_1! * x_2! * ... * x_n!)</code>, where <code>n</code> is the total number of
items input, and each <code>x_i</code> is the count of a distinct item in the input
sequence.</p>
<p>If <em>r</em> is given, only the <em>r</em>-length permutations are yielded.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(distinct_permutations([1, 0, 1], r=2))
<span class="py-output">[(0, 1), (1, 0), (1, 1)]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(distinct_permutations(<span class="py-builtin">range</span>(3), r=2))
<span class="py-output">[(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.distribute">
    
  </a>
  <a name="distribute">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">distribute</span>(n, iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1418">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Distribute the items from <em>iterable</em> among <em>n</em> smaller iterables.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(group_1)
<span class="py-output">[1, 3, 5]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(group_2)
<span class="py-output">[2, 4, 6]</span>
</pre></blockquote>
<p>If the length of <em>iterable</em> is not evenly divisible by <em>n</em>, then the
length of the returned iterables will not be identical:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>children = distribute(3, [1, 2, 3, 4, 5, 6, 7])
<span class="py-prompt">&gt;&gt;&gt; </span>[<span class="py-builtin">list</span>(c) <span class="py-keyword">for</span> c <span class="py-keyword">in</span> children]
<span class="py-output">[[1, 4, 7], [2, 5], [3, 6]]</span>
</pre></blockquote>
<p>If the length of <em>iterable</em> is smaller than <em>n</em>, then the last returned
iterables will be empty:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>children = distribute(5, [1, 2, 3])
<span class="py-prompt">&gt;&gt;&gt; </span>[<span class="py-builtin">list</span>(c) <span class="py-keyword">for</span> c <span class="py-keyword">in</span> children]
<span class="py-output">[[1], [2], [3], [], []]</span>
</pre></blockquote>
<p>This function uses <code><a href="https://docs.python.org/3/library/itertools.html#itertools.tee" class="intersphinx-link">itertools.tee</a></code> and may require significant
storage. If you need the order items in the smaller iterables to match the
original iterable, see <code><a href="#divide" class="internal-link" title="setuptools._vendor.more_itertools.more.divide">divide</a></code>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.divide">
    
  </a>
  <a name="divide">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">divide</span>(n, iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1700">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Divide the elements from <em>iterable</em> into <em>n</em> parts, maintaining
order.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(group_1)
<span class="py-output">[1, 2, 3]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(group_2)
<span class="py-output">[4, 5, 6]</span>
</pre></blockquote>
<p>If the length of <em>iterable</em> is not evenly divisible by <em>n</em>, then the
length of the returned iterables will not be identical:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>children = divide(3, [1, 2, 3, 4, 5, 6, 7])
<span class="py-prompt">&gt;&gt;&gt; </span>[<span class="py-builtin">list</span>(c) <span class="py-keyword">for</span> c <span class="py-keyword">in</span> children]
<span class="py-output">[[1, 2, 3], [4, 5], [6, 7]]</span>
</pre></blockquote>
<p>If the length of the iterable is smaller than n, then the last returned
iterables will be empty:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>children = divide(5, [1, 2, 3])
<span class="py-prompt">&gt;&gt;&gt; </span>[<span class="py-builtin">list</span>(c) <span class="py-keyword">for</span> c <span class="py-keyword">in</span> children]
<span class="py-output">[[1], [2], [3], [], []]</span>
</pre></blockquote>
<p>This function will exhaust the iterable before returning and may require
significant storage. If order is not important, see <code><a href="#distribute" class="internal-link" title="setuptools._vendor.more_itertools.more.distribute">distribute</a></code>,
which does not first pull the iterable into memory.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.exactly_n">
    
  </a>
  <a name="exactly_n">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">exactly_n</span>(iterable, n, predicate=<a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2731">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return <tt class="rst-docutils literal">True</tt> if exactly <tt class="rst-docutils literal">n</tt> items in the iterable are <tt class="rst-docutils literal">True</tt>
according to the <em>predicate</em> function.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>exactly_n([<span class="py-builtin">True</span>, <span class="py-builtin">True</span>, <span class="py-builtin">False</span>], 2)
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>exactly_n([<span class="py-builtin">True</span>, <span class="py-builtin">True</span>, <span class="py-builtin">False</span>], 1)
<span class="py-output">False</span>
<span class="py-prompt">&gt;&gt;&gt; </span>exactly_n([0, 1, 2, 3, 4, 5], 3, <span class="py-keyword">lambda</span> x: x &lt; 3)
<span class="py-output">True</span>
</pre></blockquote>
<p>The iterable will be advanced until <tt class="rst-docutils literal">n + 1</tt> truthy items are encountered,
so avoid calling it on infinite iterables.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.filter_except">
    
  </a>
  <a name="filter_except">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">filter_except</span>(validator, iterable, *exceptions):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3234">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the items from <em>iterable</em> for which the <em>validator</em> function does
not raise one of the specified <em>exceptions</em>.</p>
<p><em>validator</em> is called for each item in <em>iterable</em>.
It should be a function that accepts one argument and raises an exception
if that item is not valid.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [<span class="py-string">'1'</span>, <span class="py-string">'2'</span>, <span class="py-string">'three'</span>, <span class="py-string">'4'</span>, <span class="py-builtin">None</span>]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(filter_except(<span class="py-builtin">int</span>, iterable, <span class="py-builtin">ValueError</span>, <span class="py-builtin">TypeError</span>))
<span class="py-output">['1', '2', '4']</span>
</pre><p>If an exception other than one given by <em>exceptions</em> is raised by
<em>validator</em>, it is raised like normal.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.first">
    
  </a>
  <a name="first">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">first</span>(iterable, default=<a href="#_marker" class="internal-link" title="setuptools._vendor.more_itertools.more._marker">_marker</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L159">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the first item of <em>iterable</em>, or <em>default</em> if <em>iterable</em> is
empty.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>first([0, 1, 2, 3])
<span class="py-output">0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>first([], <span class="py-string">'some default'</span>)
<span class="py-output">'some default'</span>
</pre></blockquote>
<p>If <em>default</em> is not provided and there are no items in the iterable,
raise <tt class="rst-docutils literal">ValueError</tt>.</p>
<p><code><a href="#first" class="internal-link" title="setuptools._vendor.more_itertools.more.first">first</a></code> is useful when you have a generator of expensive-to-retrieve
values and want any arbitrary one. It is marginally shorter than
<tt class="rst-docutils literal">next(iter(iterable), default)</tt>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.groupby_transform">
    
  </a>
  <a name="groupby_transform">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">groupby_transform</span>(iterable, keyfunc=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, valuefunc=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, reducefunc=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1843">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>An extension of <code><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" class="intersphinx-link">itertools.groupby</a></code> that can apply transformations
to the grouped data.</p>
<ul class="rst-simple">
<li><em>keyfunc</em> is a function computing a key value for each item in <em>iterable</em></li>
<li><em>valuefunc</em> is a function that transforms the individual items from
<em>iterable</em> after grouping</li>
<li><em>reducefunc</em> is a function that transforms each group of items</li>
</ul>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-string">'aAAbBBcCC'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>keyfunc = <span class="py-keyword">lambda</span> k: k.upper()
<span class="py-prompt">&gt;&gt;&gt; </span>valuefunc = <span class="py-keyword">lambda</span> v: v.lower()
<span class="py-prompt">&gt;&gt;&gt; </span>reducefunc = <span class="py-keyword">lambda</span> g: <span class="py-string">''</span>.join(g)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(groupby_transform(iterable, keyfunc, valuefunc, reducefunc))
<span class="py-output">[('A', 'aaa'), ('B', 'bbb'), ('C', 'ccc')]</span>
</pre><p>Each optional argument defaults to an identity function if not specified.</p>
<p><code><a href="#groupby_transform" class="internal-link" title="setuptools._vendor.more_itertools.more.groupby_transform">groupby_transform</a></code> is useful when grouping elements of an iterable
using a separate iterable as the key. To do this, <code><a href="https://docs.python.org/3/library/functions.html#zip" class="intersphinx-link">zip</a></code> the iterables
and pass a <em>keyfunc</em> that extracts the first element and a <em>valuefunc</em>
that extracts the second element:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]
&gt;&gt;&gt; values = 'abcdefghi'
&gt;&gt;&gt; iterable = zip(keys, values)
&gt;&gt;&gt; grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1))
&gt;&gt;&gt; [(k, ''.join(g)) for k, g in grouper]
[(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')]
</pre>
<p>Note that the order of items in the iterable is significant.
Only adjacent items are grouped together, so if you don't want any
duplicate groups, you should sort the iterable by the key function.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.ichunked">
    
  </a>
  <a name="ichunked">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">ichunked</span>(iterable, n):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3157">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Break <em>iterable</em> into sub-iterables with <em>n</em> elements each.
<code><a href="#ichunked" class="internal-link" title="setuptools._vendor.more_itertools.more.ichunked">ichunked</a></code> is like <code><a href="#chunked" class="internal-link" title="setuptools._vendor.more_itertools.more.chunked">chunked</a></code>, but it yields iterables
instead of lists.</p>
<p>If the sub-iterables are read in order, the elements of <em>iterable</em>
won't be stored in memory.
If they are read out of order, <code><a href="https://docs.python.org/3/library/itertools.html#itertools.tee" class="intersphinx-link">itertools.tee</a></code> is used to cache
elements as necessary.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> itertools <span class="py-keyword">import</span> count
<span class="py-prompt">&gt;&gt;&gt; </span>all_chunks = ichunked(count(), 4)
<span class="py-prompt">&gt;&gt;&gt; </span>c_1, c_2, c_3 = <span class="py-builtin">next</span>(all_chunks), <span class="py-builtin">next</span>(all_chunks), <span class="py-builtin">next</span>(all_chunks)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(c_2)  <span class="py-comment"># c_1's elements have been cached; c_3's haven't been</span>
<span class="py-output">[4, 5, 6, 7]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(c_1)
<span class="py-output">[0, 1, 2, 3]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(c_3)
<span class="py-output">[8, 9, 10, 11]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.ilen">
    
  </a>
  <a name="ilen">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">ilen</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L468">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the number of items in <em>iterable</em>.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>ilen(x <span class="py-keyword">for</span> x <span class="py-keyword">in</span> <span class="py-builtin">range</span>(1000000) <span class="py-keyword">if</span> x % 3 == 0)
<span class="py-output">333334</span>
</pre></blockquote>
<p>This consumes the iterable, so handle with care.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.interleave">
    
  </a>
  <a name="interleave">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">interleave</span>(*iterables):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L989">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a new iterable yielding from each iterable in turn,
until the shortest is exhausted.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(interleave([1, 2, 3], [4, 5], [6, 7, 8]))
<span class="py-output">[1, 4, 6, 2, 5, 7]</span>
</pre></blockquote>
<p>For a version that doesn't terminate after the shortest iterable is
exhausted, see <code><a href="#interleave_longest" class="internal-link" title="setuptools._vendor.more_itertools.more.interleave_longest">interleave_longest</a></code>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.interleave_longest">
    
  </a>
  <a name="interleave_longest">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">interleave_longest</span>(*iterables):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1003">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a new iterable yielding from each iterable in turn,
skipping any that are exhausted.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))
<span class="py-output">[1, 4, 6, 2, 5, 7, 3, 8]</span>
</pre></blockquote>
<p>This function produces the same output as <code><a href="setuptools._vendor.more_itertools.recipes.html#roundrobin" class="internal-link" title="setuptools._vendor.more_itertools.recipes.roundrobin">roundrobin</a></code>, but may
perform better for some inputs (in particular when the number of iterables
is large).</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.intersperse">
    
  </a>
  <a name="intersperse">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">intersperse</span>(e, iterable, n=1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L680">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Intersperse filler element <em>e</em> among the items in <em>iterable</em>, leaving
<em>n</em> items between each filler element.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(intersperse(<span class="py-string">'!'</span>, [1, 2, 3, 4, 5]))
<span class="py-output">[1, '!', 2, '!', 3, '!', 4, '!', 5]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(intersperse(<span class="py-builtin">None</span>, [1, 2, 3, 4, 5], n=2))
<span class="py-output">[1, 2, None, 3, 4, None, 5]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.is_sorted">
    
  </a>
  <a name="is_sorted">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_sorted</span>(iterable, key=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, reverse=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3376">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns <tt class="rst-docutils literal">True</tt> if the items of iterable are in sorted order, and
<tt class="rst-docutils literal">False</tt> otherwise. <em>key</em> and <em>reverse</em> have the same meaning that they do
in the built-in <code><a href="https://docs.python.org/3/library/functions.html#sorted" class="intersphinx-link">sorted</a></code> function.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>is_sorted([<span class="py-string">'1'</span>, <span class="py-string">'2'</span>, <span class="py-string">'3'</span>, <span class="py-string">'4'</span>, <span class="py-string">'5'</span>], key=<span class="py-builtin">int</span>)
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>is_sorted([5, 4, 3, 1, 2], reverse=<span class="py-builtin">True</span>)
<span class="py-output">False</span>
</pre><p>The function returns <tt class="rst-docutils literal">False</tt> after encountering the first out-of-order
item. If there are no out-of-order items, the iterable is exhausted.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.iterate">
    
  </a>
  <a name="iterate">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">iterate</span>(func, start):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L485">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return <tt class="rst-docutils literal">start</tt>, <tt class="rst-docutils literal">func(start)</tt>, <tt class="rst-docutils literal">func(func(start))</tt>, ...</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> itertools <span class="py-keyword">import</span> islice
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(islice(iterate(<span class="py-keyword">lambda</span> x: 2*x, 1), 10))
<span class="py-output">[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.last">
    
  </a>
  <a name="last">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">last</span>(iterable, default=<a href="#_marker" class="internal-link" title="setuptools._vendor.more_itertools.more._marker">_marker</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L187">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the last item of <em>iterable</em>, or <em>default</em> if <em>iterable</em> is
empty.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>last([0, 1, 2, 3])
<span class="py-output">3</span>
<span class="py-prompt">&gt;&gt;&gt; </span>last([], <span class="py-string">'some default'</span>)
<span class="py-output">'some default'</span>
</pre></blockquote>
<p>If <em>default</em> is not provided and there are no items in the iterable,
raise <tt class="rst-docutils literal">ValueError</tt>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.locate">
    
  </a>
  <a name="locate">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">locate</span>(iterable, pred=<a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a>, window_size=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2158">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the index of each item in <em>iterable</em> for which <em>pred</em> returns
<tt class="rst-docutils literal">True</tt>.</p>
<p><em>pred</em> defaults to <code><a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a></code>, which will select truthy items:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(locate([0, 1, 1, 0, 1, 0, 0]))
<span class="py-output">[1, 2, 4]</span>
</pre></blockquote>
<p>Set <em>pred</em> to a custom function to, e.g., find the indexes for a particular
item.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(locate([<span class="py-string">'a'</span>, <span class="py-string">'b'</span>, <span class="py-string">'c'</span>, <span class="py-string">'b'</span>], <span class="py-keyword">lambda</span> x: x == <span class="py-string">'b'</span>))
<span class="py-output">[1, 3]</span>
</pre></blockquote>
<p>If <em>window_size</em> is given, then the <em>pred</em> function will be called with
that many items. This enables searching for sub-sequences:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> *args: args == (1, 2, 3)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(locate(iterable, pred=pred, window_size=3))
<span class="py-output">[1, 5, 9]</span>
</pre></blockquote>
<p>Use with <code><a href="setuptools._vendor.more_itertools.more.seekable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.seekable">seekable</a></code> to find indexes and then retrieve the associated
items:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> itertools <span class="py-keyword">import</span> count
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> more_itertools <span class="py-keyword">import</span> seekable
<span class="py-prompt">&gt;&gt;&gt; </span>source = (3 * n + 1 <span class="py-keyword">if</span> (n % 2) <span class="py-keyword">else</span> n // 2 <span class="py-keyword">for</span> n <span class="py-keyword">in</span> count())
<span class="py-prompt">&gt;&gt;&gt; </span>it = seekable(source)
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x &gt; 100
<span class="py-prompt">&gt;&gt;&gt; </span>indexes = locate(it, pred=pred)
<span class="py-prompt">&gt;&gt;&gt; </span>i = <span class="py-builtin">next</span>(indexes)
<span class="py-prompt">&gt;&gt;&gt; </span>it.seek(i)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">next</span>(it)
<span class="py-output">106</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.lstrip">
    
  </a>
  <a name="lstrip">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">lstrip</span>(iterable, pred):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2206">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the items from <em>iterable</em>, but strip any from the beginning
for which <em>pred</em> returns <tt class="rst-docutils literal">True</tt>.</p>
<p>For example, to remove a set of items from the start of an iterable:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = (<span class="py-builtin">None</span>, <span class="py-builtin">False</span>, <span class="py-builtin">None</span>, 1, 2, <span class="py-builtin">None</span>, 3, <span class="py-builtin">False</span>, <span class="py-builtin">None</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x <span class="py-keyword">in</span> {<span class="py-builtin">None</span>, <span class="py-builtin">False</span>, <span class="py-string">''</span>}
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(lstrip(iterable, pred))
<span class="py-output">[1, 2, None, 3, False, None]</span>
</pre></blockquote>
<p>This function is analogous to to <code><a href="https://docs.python.org/3/library/stdtypes.html#str.lstrip" class="intersphinx-link">str.lstrip</a></code>, and is essentially
an wrapper for <code><a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile" class="intersphinx-link">itertools.dropwhile</a></code>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.make_decorator">
    
  </a>
  <a name="make_decorator">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">make_decorator</span>(wrapping_func, result_index=0):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2759">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a decorator version of <em>wrapping_func</em>, which is a function that
modifies an iterable. <em>result_index</em> is the position in that function's
signature where the iterable goes.</p>
<p>This lets you use itertools on the "production end," i.e. at function
definition. This can augment what the function returns without changing the
function's code.</p>
<p>For example, to produce a decorator version of <code><a href="#chunked" class="internal-link" title="setuptools._vendor.more_itertools.more.chunked">chunked</a></code>:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> more_itertools <span class="py-keyword">import</span> chunked
<span class="py-prompt">&gt;&gt;&gt; </span>chunker = make_decorator(chunked, result_index=0)
<span class="py-prompt">&gt;&gt;&gt; </span>@chunker(3)
<span class="py-more">... </span><span class="py-keyword">def</span> <span class="py-defname">iter_range</span>(n):
<span class="py-more">... </span>    <span class="py-keyword">return</span> <span class="py-builtin">iter</span>(<span class="py-builtin">range</span>(n))
<span class="py-more">...</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(iter_range(9))
<span class="py-output">[[0, 1, 2], [3, 4, 5], [6, 7, 8]]</span>
</pre></blockquote>
<p>To only allow truthy items to be returned:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>truth_serum = make_decorator(<span class="py-builtin">filter</span>, result_index=1)
<span class="py-prompt">&gt;&gt;&gt; </span>@truth_serum(<span class="py-builtin">bool</span>)
<span class="py-more">... </span><span class="py-keyword">def</span> <span class="py-defname">boolean_test</span>():
<span class="py-more">... </span>    <span class="py-keyword">return</span> [0, 1, <span class="py-string">''</span>, <span class="py-string">' '</span>, <span class="py-builtin">False</span>, <span class="py-builtin">True</span>]
<span class="py-more">...</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(boolean_test())
<span class="py-output">[1, ' ', True]</span>
</pre></blockquote>
<p>The <code><a href="setuptools._vendor.more_itertools.more.peekable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.peekable">peekable</a></code> and <code><a href="setuptools._vendor.more_itertools.more.seekable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.seekable">seekable</a></code> wrappers make for practical
decorators:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> more_itertools <span class="py-keyword">import</span> peekable
<span class="py-prompt">&gt;&gt;&gt; </span>peekable_function = make_decorator(peekable)
<span class="py-prompt">&gt;&gt;&gt; </span>@peekable_function()
<span class="py-more">... </span><span class="py-keyword">def</span> <span class="py-defname">str_range</span>(*args):
<span class="py-more">... </span>    <span class="py-keyword">return</span> (<span class="py-builtin">str</span>(x) <span class="py-keyword">for</span> x <span class="py-keyword">in</span> <span class="py-builtin">range</span>(*args))
<span class="py-more">...</span>
<span class="py-prompt">&gt;&gt;&gt; </span>it = str_range(1, 20, 2)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">next</span>(it), <span class="py-builtin">next</span>(it), <span class="py-builtin">next</span>(it)
<span class="py-output">('1', '3', '5')</span>
<span class="py-prompt">&gt;&gt;&gt; </span>it.peek()
<span class="py-output">'7'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">next</span>(it)
<span class="py-output">'7'</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.map_except">
    
  </a>
  <a name="map_except">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">map_except</span>(function, iterable, *exceptions):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3258">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Transform each item from <em>iterable</em> with <em>function</em> and yield the
result, unless <em>function</em> raises one of the specified <em>exceptions</em>.</p>
<p><em>function</em> is called to transform each item in <em>iterable</em>.
It should be a accept one argument.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [<span class="py-string">'1'</span>, <span class="py-string">'2'</span>, <span class="py-string">'three'</span>, <span class="py-string">'4'</span>, <span class="py-builtin">None</span>]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(map_except(<span class="py-builtin">int</span>, iterable, <span class="py-builtin">ValueError</span>, <span class="py-builtin">TypeError</span>))
<span class="py-output">[1, 2, 4]</span>
</pre><p>If an exception other than one given by <em>exceptions</em> is raised by
<em>function</em>, it is raised like normal.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.map_reduce">
    
  </a>
  <a name="map_reduce">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">map_reduce</span>(iterable, keyfunc, valuefunc=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, reducefunc=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2824">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a dictionary that maps the items in <em>iterable</em> to categories
defined by <em>keyfunc</em>, transforms them with <em>valuefunc</em>, and
then summarizes them by category with <em>reducefunc</em>.</p>
<p><em>valuefunc</em> defaults to the identity function if it is unspecified.
If <em>reducefunc</em> is unspecified, no summarization takes place:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>keyfunc = <span class="py-keyword">lambda</span> x: x.upper()
<span class="py-prompt">&gt;&gt;&gt; </span>result = map_reduce(<span class="py-string">'abbccc'</span>, keyfunc)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(result.items())
<span class="py-output">[('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]</span>
</pre></blockquote>
<p>Specifying <em>valuefunc</em> transforms the categorized items:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>keyfunc = <span class="py-keyword">lambda</span> x: x.upper()
<span class="py-prompt">&gt;&gt;&gt; </span>valuefunc = <span class="py-keyword">lambda</span> x: 1
<span class="py-prompt">&gt;&gt;&gt; </span>result = map_reduce(<span class="py-string">'abbccc'</span>, keyfunc, valuefunc)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(result.items())
<span class="py-output">[('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]</span>
</pre></blockquote>
<p>Specifying <em>reducefunc</em> summarizes the categorized items:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>keyfunc = <span class="py-keyword">lambda</span> x: x.upper()
<span class="py-prompt">&gt;&gt;&gt; </span>valuefunc = <span class="py-keyword">lambda</span> x: 1
<span class="py-prompt">&gt;&gt;&gt; </span>reducefunc = <span class="py-builtin">sum</span>
<span class="py-prompt">&gt;&gt;&gt; </span>result = map_reduce(<span class="py-string">'abbccc'</span>, keyfunc, valuefunc, reducefunc)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(result.items())
<span class="py-output">[('A', 1), ('B', 2), ('C', 3)]</span>
</pre></blockquote>
<p>You may want to filter the input iterable before applying the map/reduce
procedure:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>all_items = <span class="py-builtin">range</span>(30)
<span class="py-prompt">&gt;&gt;&gt; </span>items = [x <span class="py-keyword">for</span> x <span class="py-keyword">in</span> all_items <span class="py-keyword">if</span> 10 &lt;= x &lt;= 20]  <span class="py-comment"># Filter</span>
<span class="py-prompt">&gt;&gt;&gt; </span>keyfunc = <span class="py-keyword">lambda</span> x: x % 2  <span class="py-comment"># Evens map to 0; odds to 1</span>
<span class="py-prompt">&gt;&gt;&gt; </span>categories = map_reduce(items, keyfunc=keyfunc)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(categories.items())
<span class="py-output">[(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]</span>
<span class="py-prompt">&gt;&gt;&gt; </span>summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=<span class="py-builtin">sum</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">sorted</span>(summaries.items())
<span class="py-output">[(0, 90), (1, 75)]</span>
</pre></blockquote>
<p>Note that all items in the iterable are gathered into a list before the
summarization step, which may require significant storage.</p>
<p>The returned object is a <code><a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" class="intersphinx-link">collections.defaultdict</a></code> with the
<tt class="rst-docutils literal">default_factory</tt> set to <tt class="rst-docutils literal">None</tt>, such that it behaves like a normal
dictionary.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.mark_ends">
    
  </a>
  <a name="mark_ends">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">mark_ends</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2121">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield 3-tuples of the form <tt class="rst-docutils literal">(is_first, is_last, item)</tt>.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(mark_ends(<span class="py-string">'ABC'</span>))
<span class="py-output">[(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]</span>
</pre><p>Use this when looping over an iterable to take special action on its first
and/or last items:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [<span class="py-string">'Header'</span>, 100, 200, <span class="py-string">'Footer'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>total = 0
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> is_first, is_last, item <span class="py-keyword">in</span> mark_ends(iterable):
<span class="py-more">... </span>    <span class="py-keyword">if</span> is_first:
<span class="py-more">... </span>        <span class="py-keyword">continue</span>  <span class="py-comment"># Skip the header</span>
<span class="py-more">... </span>    <span class="py-keyword">if</span> is_last:
<span class="py-more">... </span>        <span class="py-keyword">continue</span>  <span class="py-comment"># Skip the footer</span>
<span class="py-more">... </span>    total += item
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">print</span>(total)
<span class="py-output">300</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.nth_or_last">
    
  </a>
  <a name="nth_or_last">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">nth_or_last</span>(iterable, n, default=<a href="#_marker" class="internal-link" title="setuptools._vendor.more_itertools.more._marker">_marker</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L216">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the nth or the last item of <em>iterable</em>,
or <em>default</em> if <em>iterable</em> is empty.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>nth_or_last([0, 1, 2, 3], 2)
<span class="py-output">2</span>
<span class="py-prompt">&gt;&gt;&gt; </span>nth_or_last([0, 1], 2)
<span class="py-output">1</span>
<span class="py-prompt">&gt;&gt;&gt; </span>nth_or_last([], 0, <span class="py-string">'some default'</span>)
<span class="py-output">'some default'</span>
</pre></blockquote>
<p>If <em>default</em> is not provided and there are no items in the iterable,
raise <tt class="rst-docutils literal">ValueError</tt>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.nth_permutation">
    
  </a>
  <a name="nth_permutation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">nth_permutation</span>(iterable, r, index):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3629">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Equivalent to <tt class="rst-docutils literal">list(permutations(iterable, <span class="pre">r))[index]`</span></tt></p>
<p>The subsequences of <em>iterable</em> that are of length <em>r</em> where order is
important can be ordered lexicographically. <code><a href="#nth_permutation" class="internal-link" title="setuptools._vendor.more_itertools.more.nth_permutation">nth_permutation</a></code>
computes the subsequence at sort position <em>index</em> directly, without
computing the previous subsequences.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>nth_permutation(<span class="py-string">'ghijk'</span>, 2, 5)
<span class="py-output">('h', 'i')</span>
</pre></blockquote>
<p><tt class="rst-docutils literal">ValueError</tt> will be raised If <em>r</em> is negative or greater than the length
of <em>iterable</em>.
<tt class="rst-docutils literal">IndexError</tt> will be raised if the given <em>index</em> is invalid.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.nth_product">
    
  </a>
  <a name="nth_product">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">nth_product</span>(index, *args):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3598">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Equivalent to <tt class="rst-docutils literal"><span class="pre">list(product(*args))[index]</span></tt>.</p>
<p>The products of <em>args</em> can be ordered lexicographically.
<code><a href="#nth_product" class="internal-link" title="setuptools._vendor.more_itertools.more.nth_product">nth_product</a></code> computes the product at sort position <em>index</em> without
computing the previous products.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>nth_product(8, <span class="py-builtin">range</span>(2), <span class="py-builtin">range</span>(2), <span class="py-builtin">range</span>(2), <span class="py-builtin">range</span>(2))
<span class="py-output">(1, 0, 0, 0)</span>
</pre></blockquote>
<p><tt class="rst-docutils literal">IndexError</tt> will be raised if the given <em>index</em> is invalid.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.one">
    
  </a>
  <a name="one">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">one</span>(iterable, too_short=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, too_long=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L513">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the first item from <em>iterable</em>, which is expected to contain only
that item. Raise an exception if <em>iterable</em> is empty or has more than one
item.</p>
<p><code><a href="#one" class="internal-link" title="setuptools._vendor.more_itertools.more.one">one</a></code> is useful for ensuring that an iterable contains only one item.
For example, it can be used to retrieve the result of a database query
that is expected to return a single row.</p>
<p>If <em>iterable</em> is empty, <tt class="rst-docutils literal">ValueError</tt> will be raised. You may specify a
different exception with the <em>too_short</em> keyword:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>it = []
<span class="py-prompt">&gt;&gt;&gt; </span>one(it)  <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">ValueError: too many items in iterable (expected 1)'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>too_short = <span class="py-builtin">IndexError</span>(<span class="py-string">'too few items'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>one(it, too_short=too_short)  <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">IndexError: too few items</span>
</pre></blockquote>
<p>Similarly, if <em>iterable</em> contains more than one item, <tt class="rst-docutils literal">ValueError</tt> will
be raised. You may specify a different exception with the <em>too_long</em>
keyword:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>it = [<span class="py-string">'too'</span>, <span class="py-string">'many'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>one(it)  <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">ValueError: Expected exactly one item in iterable, but got 'too',</span>
<span class="py-except">'many', and perhaps more.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>too_long = <span class="py-builtin">RuntimeError</span>
<span class="py-prompt">&gt;&gt;&gt; </span>one(it, too_long=too_long)  <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">RuntimeError</span>
</pre></blockquote>
<p>Note that <code><a href="#one" class="internal-link" title="setuptools._vendor.more_itertools.more.one">one</a></code> attempts to advance <em>iterable</em> twice to ensure there
is only one item. See <code><a href="#spy" class="internal-link" title="setuptools._vendor.more_itertools.more.spy">spy</a></code> or <code><a href="setuptools._vendor.more_itertools.more.peekable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.peekable">peekable</a></code> to check iterable
contents less destructively.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.only">
    
  </a>
  <a name="only">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">only</span>(iterable, default=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, too_long=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3116">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>If <em>iterable</em> has only one item, return it.
If it has zero items, return <em>default</em>.
If it has more than one item, raise the exception given by <em>too_long</em>,
which is <tt class="rst-docutils literal">ValueError</tt> by default.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>only([], default=<span class="py-string">'missing'</span>)
<span class="py-output">'missing'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>only([1])
<span class="py-output">1</span>
<span class="py-prompt">&gt;&gt;&gt; </span>only([1, 2])  <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">ValueError: Expected exactly one item in iterable, but got 1, 2,</span>
<span class="py-except"> and perhaps more.'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>only([1, 2], too_long=<span class="py-builtin">TypeError</span>)  <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">TypeError</span>
</pre><p>Note that <code><a href="#only" class="internal-link" title="setuptools._vendor.more_itertools.more.only">only</a></code> attempts to advance <em>iterable</em> twice to ensure there
is only one item.  See <code><a href="#spy" class="internal-link" title="setuptools._vendor.more_itertools.more.spy">spy</a></code> or <code><a href="setuptools._vendor.more_itertools.more.peekable.html" class="internal-link" title="setuptools._vendor.more_itertools.more.peekable">peekable</a></code> to check
iterable contents less destructively.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.padded">
    
  </a>
  <a name="padded">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">padded</span>(iterable, fillvalue=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, n=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, next_multiple=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1367">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the elements from <em>iterable</em>, followed by <em>fillvalue</em>, such that
at least <em>n</em> items are emitted.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(padded([1, 2, 3], <span class="py-string">'?'</span>, 5))
<span class="py-output">[1, 2, 3, '?', '?']</span>
</pre></blockquote>
<p>If <em>next_multiple</em> is <tt class="rst-docutils literal">True</tt>, <em>fillvalue</em> will be emitted until the
number of items emitted is a multiple of <em>n</em>:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; list(padded([1, 2, 3, 4], n=3, next_multiple=True))
[1, 2, 3, 4, None, None]
</pre>
<p>If <em>n</em> is <tt class="rst-docutils literal">None</tt>, <em>fillvalue</em> will be emitted indefinitely.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.partitions">
    
  </a>
  <a name="partitions">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">partitions</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2995">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield all possible order-preserving partitions of <em>iterable</em>.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-string">'abc'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> part <span class="py-keyword">in</span> partitions(iterable):
<span class="py-more">... </span>    <span class="py-builtin">print</span>([<span class="py-string">''</span>.join(p) <span class="py-keyword">for</span> p <span class="py-keyword">in</span> part])
<span class="py-output">['abc']</span>
<span class="py-output">['a', 'bc']</span>
<span class="py-output">['ab', 'c']</span>
<span class="py-output">['a', 'b', 'c']</span>
</pre><p>This is unrelated to <code><a href="setuptools._vendor.more_itertools.recipes.html#partition" class="internal-link" title="setuptools._vendor.more_itertools.recipes.partition">partition</a></code>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.permutation_index">
    
  </a>
  <a name="permutation_index">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">permutation_index</span>(element, iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3771">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Equivalent to <tt class="rst-docutils literal">list(permutations(iterable, <span class="pre">r)).index(element)`</span></tt></p>
<p>The subsequences of <em>iterable</em> that are of length <em>r</em> where order is
important can be ordered lexicographically. <code><a href="#permutation_index" class="internal-link" title="setuptools._vendor.more_itertools.more.permutation_index">permutation_index</a></code>
computes the index of the first <em>element</em> directly, without computing
the previous permutations.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>permutation_index([1, 3, 2], <span class="py-builtin">range</span>(5))
<span class="py-output">19</span>
</pre></blockquote>
<p><tt class="rst-docutils literal">ValueError</tt> will be raised if the given <em>element</em> isn't one of the
permutations of <em>iterable</em>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.product_index">
    
  </a>
  <a name="product_index">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">product_index</span>(element, *args):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3703">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Equivalent to <tt class="rst-docutils literal"><span class="pre">list(product(*args)).index(element)</span></tt></p>
<p>The products of <em>args</em> can be ordered lexicographically.
<code><a href="#product_index" class="internal-link" title="setuptools._vendor.more_itertools.more.product_index">product_index</a></code> computes the first index of <em>element</em> without
computing the previous products.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>product_index([8, 2], <span class="py-builtin">range</span>(10), <span class="py-builtin">range</span>(5))
<span class="py-output">42</span>
</pre></blockquote>
<p><tt class="rst-docutils literal">ValueError</tt> will be raised if the given <em>element</em> isn't in the product
of <em>args</em>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.repeat_last">
    
  </a>
  <a name="repeat_last">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">repeat_last</span>(iterable, default=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1399">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>After the <em>iterable</em> is exhausted, keep yielding its last element.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(islice(repeat_last(<span class="py-builtin">range</span>(3)), 5))
<span class="py-output">[0, 1, 2, 2, 2]</span>
</pre></blockquote>
<p>If the iterable is empty, yield <em>default</em> forever:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; list(islice(repeat_last(range(0), 42), 5))
[42, 42, 42, 42, 42]
</pre>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.replace">
    
  </a>
  <a name="replace">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">replace</span>(iterable, pred, substitutes, count=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, window_size=1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2934">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the items from <em>iterable</em>, replacing the items for which <em>pred</em>
returns <tt class="rst-docutils literal">True</tt> with the items from the iterable <em>substitutes</em>.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 1, 0, 1, 1, 0, 1, 1]
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x == 0
<span class="py-prompt">&gt;&gt;&gt; </span>substitutes = (2, 3)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(replace(iterable, pred, substitutes))
<span class="py-output">[1, 1, 2, 3, 1, 1, 2, 3, 1, 1]</span>
</pre></blockquote>
<p>If <em>count</em> is given, the number of replacements will be limited:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x == 0
<span class="py-prompt">&gt;&gt;&gt; </span>substitutes = [<span class="py-builtin">None</span>]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(replace(iterable, pred, substitutes, count=2))
<span class="py-output">[1, 1, None, 1, 1, None, 1, 1, 0]</span>
</pre></blockquote>
<p>Use <em>window_size</em> to control the number of items passed as arguments to
<em>pred</em>. This allows for locating and replacing subsequences.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [0, 1, 2, 5, 0, 1, 2, 5]
<span class="py-prompt">&gt;&gt;&gt; </span>window_size = 3
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> *args: args == (0, 1, 2)  <span class="py-comment"># 3 items passed to pred</span>
<span class="py-prompt">&gt;&gt;&gt; </span>substitutes = [3, 4] <span class="py-comment"># Splice in these items</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(replace(iterable, pred, substitutes, window_size=window_size))
<span class="py-output">[3, 4, 5, 3, 4, 5]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.rlocate">
    
  </a>
  <a name="rlocate">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rlocate</span>(iterable, pred=<a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a>, window_size=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2891">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the index of each item in <em>iterable</em> for which <em>pred</em> returns
<tt class="rst-docutils literal">True</tt>, starting from the right and moving left.</p>
<p><em>pred</em> defaults to <code><a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a></code>, which will select truthy items:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(rlocate([0, 1, 1, 0, 1, 0, 0]))  <span class="py-comment"># Truthy at 1, 2, and 4</span>
<span class="py-output">[4, 2, 1]</span>
</pre></blockquote>
<p>Set <em>pred</em> to a custom function to, e.g., find the indexes for a particular
item:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-builtin">iter</span>(<span class="py-string">'abcb'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x == <span class="py-string">'b'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(rlocate(iterable, pred))
<span class="py-output">[3, 1]</span>
</pre></blockquote>
<p>If <em>window_size</em> is given, then the <em>pred</em> function will be called with
that many items. This enables searching for sub-sequences:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> *args: args == (1, 2, 3)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(rlocate(iterable, pred=pred, window_size=3))
<span class="py-output">[9, 5, 1]</span>
</pre></blockquote>
<p>Beware, this function won't return anything for infinite iterables.
If <em>iterable</em> is reversible, <tt class="rst-docutils literal">rlocate</tt> will reverse it and search from
the right. Otherwise, it will search from the left and return the results
in reverse order.</p>
<p>See <code><a href="#locate" class="internal-link" title="setuptools._vendor.more_itertools.more.locate">locate</a></code> to for other example applications.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.rstrip">
    
  </a>
  <a name="rstrip">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rstrip</span>(iterable, pred):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2224">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the items from <em>iterable</em>, but strip any from the end
for which <em>pred</em> returns <tt class="rst-docutils literal">True</tt>.</p>
<p>For example, to remove a set of items from the end of an iterable:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = (<span class="py-builtin">None</span>, <span class="py-builtin">False</span>, <span class="py-builtin">None</span>, 1, 2, <span class="py-builtin">None</span>, 3, <span class="py-builtin">False</span>, <span class="py-builtin">None</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x <span class="py-keyword">in</span> {<span class="py-builtin">None</span>, <span class="py-builtin">False</span>, <span class="py-string">''</span>}
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(rstrip(iterable, pred))
<span class="py-output">[None, False, None, 1, 2, None, 3]</span>
</pre></blockquote>
<p>This function is analogous to <code><a href="https://docs.python.org/3/library/stdtypes.html#str.rstrip" class="intersphinx-link">str.rstrip</a></code>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.sample">
    
  </a>
  <a name="sample">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">sample</span>(iterable, k, weights=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3340">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a <em>k</em>-length list of elements chosen (without replacement)
from the <em>iterable</em>. Like <code><a href="https://docs.python.org/3/library/random.html#random.sample" class="intersphinx-link">random.sample</a></code>, but works on iterables
of unknown length.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-builtin">range</span>(100)
<span class="py-prompt">&gt;&gt;&gt; </span>sample(iterable, 5)  <span class="py-comment"># doctest: +SKIP</span>
<span class="py-output">[81, 60, 96, 16, 4]</span>
</pre><p>An iterable with <em>weights</em> may also be given:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-builtin">range</span>(100)
<span class="py-prompt">&gt;&gt;&gt; </span>weights = (i * i + 1 <span class="py-keyword">for</span> i <span class="py-keyword">in</span> <span class="py-builtin">range</span>(100))
<span class="py-prompt">&gt;&gt;&gt; </span>sampled = sample(iterable, 5, weights=weights)  <span class="py-comment"># doctest: +SKIP</span>
<span class="py-output">[79, 67, 74, 66, 78]</span>
</pre><p>The algorithm can also be used to generate weighted random permutations.
The relative weight of each item determines the probability that it
appears late in the permutation.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>data = <span class="py-string">"abcdefgh"</span>
<span class="py-prompt">&gt;&gt;&gt; </span>weights = <span class="py-builtin">range</span>(1, <span class="py-builtin">len</span>(data) + 1)
<span class="py-prompt">&gt;&gt;&gt; </span>sample(data, k=<span class="py-builtin">len</span>(data), weights=weights)  <span class="py-comment"># doctest: +SKIP</span>
<span class="py-output">['c', 'a', 'b', 'e', 'g', 'd', 'h', 'f']</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.set_partitions">
    
  </a>
  <a name="set_partitions">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">set_partitions</span>(iterable, k=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3015">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the set partitions of <em>iterable</em> into <em>k</em> parts. Set partitions are
not order-preserving.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-string">'abc'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> part <span class="py-keyword">in</span> set_partitions(iterable, 2):
<span class="py-more">... </span>    <span class="py-builtin">print</span>([<span class="py-string">''</span>.join(p) <span class="py-keyword">for</span> p <span class="py-keyword">in</span> part])
<span class="py-output">['a', 'bc']</span>
<span class="py-output">['ab', 'c']</span>
<span class="py-output">['b', 'ac']</span>
</pre><p>If <em>k</em> is not given, every set partition is generated.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-string">'abc'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> part <span class="py-keyword">in</span> set_partitions(iterable):
<span class="py-more">... </span>    <span class="py-builtin">print</span>([<span class="py-string">''</span>.join(p) <span class="py-keyword">for</span> p <span class="py-keyword">in</span> part])
<span class="py-output">['abc']</span>
<span class="py-output">['a', 'bc']</span>
<span class="py-output">['ab', 'c']</span>
<span class="py-output">['b', 'ac']</span>
<span class="py-output">['a', 'b', 'c']</span>
</pre></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.side_effect">
    
  </a>
  <a name="side_effect">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">side_effect</span>(func, iterable, chunk_size=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, before=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, after=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1067">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Invoke <em>func</em> on each item in <em>iterable</em> (or on each <em>chunk_size</em> group
of items) before yielding the item.</p>
<p><code>func</code> must be a function that takes a single argument. Its return value
will be discarded.</p>
<p><em>before</em> and <em>after</em> are optional functions that take no arguments. They
will be executed before iteration starts and after it ends, respectively.</p>
<p><code><a href="#side_effect" class="internal-link" title="setuptools._vendor.more_itertools.more.side_effect">side_effect</a></code> can be used for logging, updating progress bars, or anything
that is not functionally "pure."</p>
<p>Emitting a status message:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> more_itertools <span class="py-keyword">import</span> consume
<span class="py-prompt">&gt;&gt;&gt; </span>func = <span class="py-keyword">lambda</span> item: <span class="py-builtin">print</span>(<span class="py-string">'Received {}'</span>.format(item))
<span class="py-prompt">&gt;&gt;&gt; </span>consume(side_effect(func, <span class="py-builtin">range</span>(2)))
<span class="py-output">Received 0</span>
<span class="py-output">Received 1</span>
</pre></blockquote>
<p>Operating on chunks of items:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>pair_sums = []
<span class="py-prompt">&gt;&gt;&gt; </span>func = <span class="py-keyword">lambda</span> chunk: pair_sums.append(<span class="py-builtin">sum</span>(chunk))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(side_effect(func, [0, 1, 2, 3, 4, 5], 2))
<span class="py-output">[0, 1, 2, 3, 4, 5]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(pair_sums)
<span class="py-output">[1, 5, 9]</span>
</pre></blockquote>
<p>Writing to a file-like object:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> io <span class="py-keyword">import</span> StringIO
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> more_itertools <span class="py-keyword">import</span> consume
<span class="py-prompt">&gt;&gt;&gt; </span>f = StringIO()
<span class="py-prompt">&gt;&gt;&gt; </span>func = <span class="py-keyword">lambda</span> x: <span class="py-builtin">print</span>(x, file=f)
<span class="py-prompt">&gt;&gt;&gt; </span>before = <span class="py-keyword">lambda</span>: <span class="py-builtin">print</span>(u<span class="py-string">'HEADER'</span>, file=f)
<span class="py-prompt">&gt;&gt;&gt; </span>after = f.close
<span class="py-prompt">&gt;&gt;&gt; </span>it = [u<span class="py-string">'a'</span>, u<span class="py-string">'b'</span>, u<span class="py-string">'c'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>consume(side_effect(func, it, before=before, after=after))
<span class="py-prompt">&gt;&gt;&gt; </span>f.closed
<span class="py-output">True</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.sliced">
    
  </a>
  <a name="sliced">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">sliced</span>(seq, n, strict=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1128">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield slices of length <em>n</em> from the sequence <em>seq</em>.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(sliced((1, 2, 3, 4, 5, 6), 3))
<span class="py-output">[(1, 2, 3), (4, 5, 6)]</span>
</pre><p>By the default, the last yielded slice will have fewer than <em>n</em> elements
if the length of <em>seq</em> is not divisible by <em>n</em>:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))
<span class="py-output">[(1, 2, 3), (4, 5, 6), (7, 8)]</span>
</pre><p>If the length of <em>seq</em> is not divisible by <em>n</em> and <em>strict</em> is
<tt class="rst-docutils literal">True</tt>, then <tt class="rst-docutils literal">ValueError</tt> will be raised before the last
slice is yielded.</p>
<p>This function will only work for iterables that support slicing.
For non-sliceable iterables, see <code><a href="#chunked" class="internal-link" title="setuptools._vendor.more_itertools.more.chunked">chunked</a></code>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.sort_together">
    
  </a>
  <a name="sort_together">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">sort_together</span>(iterables, key_list=(<wbr></wbr>0), key=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, reverse=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1585">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the input iterables sorted together, with <em>key_list</em> as the
priority for sorting. All iterables are trimmed to the length of the
shortest one.</p>
<p>This can be used like the sorting function in a spreadsheet. If each
iterable represents a column of data, the key list determines which
columns are used for sorting.</p>
<p>By default, all iterables are sorted using the <tt class="rst-docutils literal">0</tt>-th iterable:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]
&gt;&gt;&gt; sort_together(iterables)
[(1, 2, 3, 4), ('d', 'c', 'b', 'a')]
</pre>
<p>Set a different key list to sort according to another iterable.
Specifying multiple keys dictates how ties are broken:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]
&gt;&gt;&gt; sort_together(iterables, key_list=(1, 2))
[(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]
</pre>
<p>To sort by a function of the elements of the iterable, pass a <em>key</em>
function. Its arguments are the elements of the iterables corresponding to
the key list:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; names = ('a', 'b', 'c')
&gt;&gt;&gt; lengths = (1, 2, 3)
&gt;&gt;&gt; widths = (5, 2, 1)
&gt;&gt;&gt; def area(length, width):
...     return length * width
&gt;&gt;&gt; sort_together([names, lengths, widths], key_list=(1, 2), key=area)
[('c', 'b', 'a'), (3, 2, 1), (1, 2, 5)]
</pre>
<p>Set <em>reverse</em> to <tt class="rst-docutils literal">True</tt> to sort in descending order.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>sort_together([(1, 2, 3), (<span class="py-string">'c'</span>, <span class="py-string">'b'</span>, <span class="py-string">'a'</span>)], reverse=<span class="py-builtin">True</span>)
<span class="py-output">[(3, 2, 1), ('a', 'b', 'c')]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.split_after">
    
  </a>
  <a name="split_after">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">split_after</span>(iterable, pred, maxsplit=-1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1241">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield lists of items from <em>iterable</em>, where each list ends with an
item where callable <em>pred</em> returns <tt class="rst-docutils literal">True</tt>:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_after(<span class="py-string">'one1two2'</span>, <span class="py-keyword">lambda</span> s: s.isdigit()))
<span class="py-output">[['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_after(<span class="py-builtin">range</span>(10), <span class="py-keyword">lambda</span> n: n % 3 == 0))
<span class="py-output">[[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]</span>
</pre></blockquote>
<p>At most <em>maxsplit</em> splits are done. If <em>maxsplit</em> is not specified or -1,
then there is no limit on the number of splits:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_after(<span class="py-builtin">range</span>(10), <span class="py-keyword">lambda</span> n: n % 3 == 0, maxsplit=2))
<span class="py-output">[[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.split_at">
    
  </a>
  <a name="split_at">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">split_at</span>(iterable, pred, maxsplit=-1, keep_separator=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1162">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield lists of items from <em>iterable</em>, where each list is delimited by
an item where callable <em>pred</em> returns <tt class="rst-docutils literal">True</tt>.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_at(<span class="py-string">'abcdcba'</span>, <span class="py-keyword">lambda</span> x: x == <span class="py-string">'b'</span>))
<span class="py-output">[['a'], ['c', 'd', 'c'], ['a']]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_at(<span class="py-builtin">range</span>(10), <span class="py-keyword">lambda</span> n: n % 2 == 1))
<span class="py-output">[[0], [2], [4], [6], [8], []]</span>
</pre></blockquote>
<p>At most <em>maxsplit</em> splits are done. If <em>maxsplit</em> is not specified or -1,
then there is no limit on the number of splits:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_at(<span class="py-builtin">range</span>(10), <span class="py-keyword">lambda</span> n: n % 2 == 1, maxsplit=2))
<span class="py-output">[[0], [2], [4, 5, 6, 7, 8, 9]]</span>
</pre></blockquote>
<p>By default, the delimiting items are not included in the output.
The include them, set <em>keep_separator</em> to <tt class="rst-docutils literal">True</tt>.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_at(<span class="py-string">'abcdcba'</span>, <span class="py-keyword">lambda</span> x: x == <span class="py-string">'b'</span>, keep_separator=<span class="py-builtin">True</span>))
<span class="py-output">[['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a']]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.split_before">
    
  </a>
  <a name="split_before">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">split_before</span>(iterable, pred, maxsplit=-1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1206">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield lists of items from <em>iterable</em>, where each list ends just before
an item for which callable <em>pred</em> returns <tt class="rst-docutils literal">True</tt>:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_before(<span class="py-string">'OneTwo'</span>, <span class="py-keyword">lambda</span> s: s.isupper()))
<span class="py-output">[['O', 'n', 'e'], ['T', 'w', 'o']]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_before(<span class="py-builtin">range</span>(10), <span class="py-keyword">lambda</span> n: n % 3 == 0))
<span class="py-output">[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]</span>
</pre></blockquote>
<p>At most <em>maxsplit</em> splits are done. If <em>maxsplit</em> is not specified or -1,
then there is no limit on the number of splits:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_before(<span class="py-builtin">range</span>(10), <span class="py-keyword">lambda</span> n: n % 3 == 0, maxsplit=2))
<span class="py-output">[[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.split_into">
    
  </a>
  <a name="split_into">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">split_into</span>(iterable, sizes):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1322">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield a list of sequential items from <em>iterable</em> of length 'n' for each
integer 'n' in <em>sizes</em>.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_into([1,2,3,4,5,6], [1,2,3]))
<span class="py-output">[[1], [2, 3], [4, 5, 6]]</span>
</pre></blockquote>
<p>If the sum of <em>sizes</em> is smaller than the length of <em>iterable</em>, then the
remaining items of <em>iterable</em> will not be returned.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_into([1,2,3,4,5,6], [2,3]))
<span class="py-output">[[1, 2], [3, 4, 5]]</span>
</pre></blockquote>
<p>If the sum of <em>sizes</em> is larger than the length of <em>iterable</em>, fewer items
will be returned in the iteration that overruns <em>iterable</em> and further
lists will be empty:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_into([1,2,3,4], [1,2,3,4]))
<span class="py-output">[[1], [2, 3], [4], []]</span>
</pre></blockquote>
<p>When a <tt class="rst-docutils literal">None</tt> object is encountered in <em>sizes</em>, the returned list will
contain items up to the end of <em>iterable</em> the same way that itertools.slice
does:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,<span class="py-builtin">None</span>]))
<span class="py-output">[[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]</span>
</pre></blockquote>
<p><code><a href="#split_into" class="internal-link" title="setuptools._vendor.more_itertools.more.split_into">split_into</a></code> can be useful for grouping a series of items where the
sizes of the groups are not uniform. An example would be where in a row
from a table, multiple columns represent elements of the same feature
(e.g. a point represented by x,y,z) but, the format is not the same for
all columns.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.split_when">
    
  </a>
  <a name="split_when">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">split_when</span>(iterable, pred, maxsplit=-1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1277">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Split <em>iterable</em> into pieces based on the output of <em>pred</em>.
<em>pred</em> should be a function that takes successive pairs of items and
returns <tt class="rst-docutils literal">True</tt> if the iterable should be split in between them.</p>
<p>For example, to find runs of increasing numbers, split the iterable when
element <tt class="rst-docutils literal">i</tt> is larger than element <tt class="rst-docutils literal">i + 1</tt>:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], <span class="py-keyword">lambda</span> x, y: x &gt; y))
<span class="py-output">[[1, 2, 3, 3], [2, 5], [2, 4], [2]]</span>
</pre></blockquote>
<p>At most <em>maxsplit</em> splits are done. If <em>maxsplit</em> is not specified or -1,
then there is no limit on the number of splits:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],
<span class="py-more">... </span>                <span class="py-keyword">lambda</span> x, y: x &gt; y, maxsplit=2))
<span class="py-output">[[1, 2, 3, 3], [2, 5], [2, 4, 2]]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.spy">
    
  </a>
  <a name="spy">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">spy</span>(iterable, n=1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L946">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a 2-tuple with a list containing the first <em>n</em> elements of
<em>iterable</em>, and an iterator with the same items as <em>iterable</em>.
This allows you to "look ahead" at the items in the iterable without
advancing it.</p>
<p>There is one item in the list by default:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-string">'abcdefg'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>head, iterable = spy(iterable)
<span class="py-prompt">&gt;&gt;&gt; </span>head
<span class="py-output">['a']</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(iterable)
<span class="py-output">['a', 'b', 'c', 'd', 'e', 'f', 'g']</span>
</pre></blockquote>
<p>You may use unpacking to retrieve items instead of lists:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>(head,), iterable = spy(<span class="py-string">'abcdefg'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>head
<span class="py-output">'a'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>(first, second), iterable = spy(<span class="py-string">'abcdefg'</span>, 2)
<span class="py-prompt">&gt;&gt;&gt; </span>first
<span class="py-output">'a'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>second
<span class="py-output">'b'</span>
</pre></blockquote>
<p>The number of items requested can be larger than the number of items in
the iterable:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 2, 3, 4, 5]
<span class="py-prompt">&gt;&gt;&gt; </span>head, iterable = spy(iterable, 10)
<span class="py-prompt">&gt;&gt;&gt; </span>head
<span class="py-output">[1, 2, 3, 4, 5]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(iterable)
<span class="py-output">[1, 2, 3, 4, 5]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.stagger">
    
  </a>
  <a name="stagger">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">stagger</span>(iterable, offsets=(<wbr></wbr>-1, <wbr></wbr>0, <wbr></wbr>1), longest=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>, fillvalue=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1453">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield tuples whose elements are offset from <em>iterable</em>.
The amount by which the <code>i</code>-th item in each tuple is offset is given by
the <code>i</code>-th item in <em>offsets</em>.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(stagger([0, 1, 2, 3]))
<span class="py-output">[(None, 0, 1), (0, 1, 2), (1, 2, 3)]</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(stagger(<span class="py-builtin">range</span>(8), offsets=(0, 2, 4)))
<span class="py-output">[(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]</span>
</pre></blockquote>
<p>By default, the sequence will end when the final element of a tuple is the
last item in the iterable. To continue until the first element of a tuple
is the last item in the iterable, set <em>longest</em> to <tt class="rst-docutils literal">True</tt>:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; list(stagger([0, 1, 2, 3], longest=True))
[(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]
</pre>
<p>By default, <tt class="rst-docutils literal">None</tt> will be used to replace offsets beyond the end of the
sequence. Specify <em>fillvalue</em> to use some other value.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.strip">
    
  </a>
  <a name="strip">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">strip</span>(iterable, pred):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2250">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield the items from <em>iterable</em>, but strip any from the
beginning and end for which <em>pred</em> returns <tt class="rst-docutils literal">True</tt>.</p>
<p>For example, to remove a set of items from both ends of an iterable:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = (<span class="py-builtin">None</span>, <span class="py-builtin">False</span>, <span class="py-builtin">None</span>, 1, 2, <span class="py-builtin">None</span>, 3, <span class="py-builtin">False</span>, <span class="py-builtin">None</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>pred = <span class="py-keyword">lambda</span> x: x <span class="py-keyword">in</span> {<span class="py-builtin">None</span>, <span class="py-builtin">False</span>, <span class="py-string">''</span>}
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(strip(iterable, pred))
<span class="py-output">[1, 2, None, 3]</span>
</pre></blockquote>
<p>This function is analogous to <code><a href="https://docs.python.org/3/library/stdtypes.html#str.strip" class="intersphinx-link">str.strip</a></code>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.substrings">
    
  </a>
  <a name="substrings">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">substrings</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L790">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield all of the substrings of <em>iterable</em>.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>[<span class="py-string">''</span>.join(s) <span class="py-keyword">for</span> s <span class="py-keyword">in</span> substrings(<span class="py-string">'more'</span>)]
<span class="py-output">['m', 'o', 'r', 'e', 'mo', 'or', 're', 'mor', 'ore', 'more']</span>
</pre></blockquote>
<p>Note that non-string iterables can also be subdivided.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(substrings([0, 1, 2]))
<span class="py-output">[(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.substrings_indexes">
    
  </a>
  <a name="substrings_indexes">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">substrings_indexes</span>(seq, reverse=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L816">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield all substrings and their positions in <em>seq</em></p>
<p>The items yielded will be a tuple of the form <tt class="rst-docutils literal">(substr, i, j)</tt>, where
<tt class="rst-docutils literal">substr == seq[i:j]</tt>.</p>
<p>This function only works for iterables that support slicing, such as
<tt class="rst-docutils literal">str</tt> objects.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> item <span class="py-keyword">in</span> substrings_indexes(<span class="py-string">'more'</span>):
<span class="py-more">... </span>   <span class="py-builtin">print</span>(item)
<span class="py-output">('m', 0, 1)</span>
<span class="py-output">('o', 1, 2)</span>
<span class="py-output">('r', 2, 3)</span>
<span class="py-output">('e', 3, 4)</span>
<span class="py-output">('mo', 0, 2)</span>
<span class="py-output">('or', 1, 3)</span>
<span class="py-output">('re', 2, 4)</span>
<span class="py-output">('mor', 0, 3)</span>
<span class="py-output">('ore', 1, 4)</span>
<span class="py-output">('more', 0, 4)</span>
</pre><p>Set <em>reverse</em> to <tt class="rst-docutils literal">True</tt> to yield the same items in the opposite order.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.unique_to_each">
    
  </a>
  <a name="unique_to_each">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">unique_to_each</span>(*iterables):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L706">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return the elements from each of the input iterables that aren't in the
other input iterables.</p>
<p>For example, suppose you have a set of packages, each with a set of
dependencies:</p>
<pre class="rst-literal-block">
{'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}
</pre>
<p>If you remove one package, which dependencies can also be removed?</p>
<p>If <tt class="rst-docutils literal">pkg_1</tt> is removed, then <tt class="rst-docutils literal">A</tt> is no longer necessary - it is not
associated with <tt class="rst-docutils literal">pkg_2</tt> or <tt class="rst-docutils literal">pkg_3</tt>. Similarly, <tt class="rst-docutils literal">C</tt> is only needed for
<tt class="rst-docutils literal">pkg_2</tt>, and <tt class="rst-docutils literal">D</tt> is only needed for <tt class="rst-docutils literal">pkg_3</tt>:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'})
[['A'], ['C'], ['D']]
</pre>
<p>If there are duplicates in one input iterable that aren't in the others
they will be duplicated in the output. Input order is preserved:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; unique_to_each("mississippi", "missouri")
[['p', 'p'], ['o', 'u', 'r']]
</pre>
<p>It is assumed that the elements of each iterable are hashable.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.unzip">
    
  </a>
  <a name="unzip">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">unzip</span>(iterable):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1651">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>The inverse of <code><a href="https://docs.python.org/3/library/functions.html#zip" class="intersphinx-link">zip</a></code>, this function disaggregates the elements
of the zipped <em>iterable</em>.</p>
<p>The <tt class="rst-docutils literal">i</tt>-th iterable contains the <tt class="rst-docutils literal">i</tt>-th element from each element
of the zipped iterable. The first element is used to to determine the
length of the remaining elements.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [(<span class="py-string">'a'</span>, 1), (<span class="py-string">'b'</span>, 2), (<span class="py-string">'c'</span>, 3), (<span class="py-string">'d'</span>, 4)]
<span class="py-prompt">&gt;&gt;&gt; </span>letters, numbers = unzip(iterable)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(letters)
<span class="py-output">['a', 'b', 'c', 'd']</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(numbers)
<span class="py-output">[1, 2, 3, 4]</span>
</pre></blockquote>
<p>This is similar to using <tt class="rst-docutils literal"><span class="pre">zip(*iterable)</span></tt>, but it avoids reading
<em>iterable</em> into memory. Note, however, that this function uses
<code><a href="https://docs.python.org/3/library/itertools.html#itertools.tee" class="intersphinx-link">itertools.tee</a></code> and thus may require significant storage.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.value_chain">
    
  </a>
  <a name="value_chain">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">value_chain</span>(*args):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3675">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield all arguments passed to the function in the same order in which
they were passed. If an argument itself is iterable then iterate over its
values.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(value_chain(1, 2, 3, [4, 5, 6]))
<span class="py-output">[1, 2, 3, 4, 5, 6]</span>
</pre></blockquote>
<p>Binary and text strings are not considered iterable and are emitted
as-is:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(value_chain(<span class="py-string">'12'</span>, <span class="py-string">'34'</span>, [<span class="py-string">'56'</span>, <span class="py-string">'78'</span>]))
<span class="py-output">['12', '34', '56', '78']</span>
</pre></blockquote>
<p>Multiple levels of nesting are not flattened.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.windowed">
    
  </a>
  <a name="windowed">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">windowed</span>(seq, n, fillvalue=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, step=1):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L739">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a sliding window of width <em>n</em> over the given iterable.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>all_windows = windowed([1, 2, 3, 4, 5], 3)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(all_windows)
<span class="py-output">[(1, 2, 3), (2, 3, 4), (3, 4, 5)]</span>
</pre></blockquote>
<p>When the window is larger than the iterable, <em>fillvalue</em> is used in place
of missing values:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(windowed([1, 2, 3], 4))
<span class="py-output">[(1, 2, 3, None)]</span>
</pre></blockquote>
<p>Each window will advance in increments of <em>step</em>:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue=<span class="py-string">'!'</span>, step=2))
<span class="py-output">[(1, 2, 3), (3, 4, 5), (5, 6, '!')]</span>
</pre></blockquote>
<p>To slide into the iterable's items, use <code><a href="https://docs.python.org/3/library/itertools.html#itertools.chain" class="intersphinx-link">chain</a></code> to add filler items
to the left:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = [1, 2, 3, 4]
<span class="py-prompt">&gt;&gt;&gt; </span>n = 3
<span class="py-prompt">&gt;&gt;&gt; </span>padding = [<span class="py-builtin">None</span>] * (n - 1)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(windowed(chain(padding, iterable), 3))
<span class="py-output">[(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.windowed_complete">
    
  </a>
  <a name="windowed_complete">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">windowed_complete</span>(iterable, n):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3523">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Yield <tt class="rst-docutils literal">(beginning, middle, end)</tt> tuples, where:</p>
<ul class="rst-simple">
<li>Each <tt class="rst-docutils literal">middle</tt> has <em>n</em> items from <em>iterable</em></li>
<li>Each <tt class="rst-docutils literal">beginning</tt> has the items before the ones in <tt class="rst-docutils literal">middle</tt></li>
<li>Each <tt class="rst-docutils literal">end</tt> has the items after the ones in <tt class="rst-docutils literal">middle</tt></li>
</ul>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>iterable = <span class="py-builtin">range</span>(7)
<span class="py-prompt">&gt;&gt;&gt; </span>n = 3
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> beginning, middle, end <span class="py-keyword">in</span> windowed_complete(iterable, n):
<span class="py-more">... </span>    <span class="py-builtin">print</span>(beginning, middle, end)
<span class="py-output">() (0, 1, 2) (3, 4, 5, 6)</span>
<span class="py-output">(0,) (1, 2, 3) (4, 5, 6)</span>
<span class="py-output">(0, 1) (2, 3, 4) (5, 6)</span>
<span class="py-output">(0, 1, 2) (3, 4, 5) (6,)</span>
<span class="py-output">(0, 1, 2, 3) (4, 5, 6) ()</span>
</pre><p>Note that <em>n</em> must be at least 0 and most equal to the length of
<em>iterable</em>.</p>
<p>This function will exhaust the iterable and may require significant
storage.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.with_iter">
    
  </a>
  <a name="with_iter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">with_iter</span>(context_manager):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L498">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Wrap an iterable in a <tt class="rst-docutils literal">with</tt> statement, so it closes once exhausted.</p>
<p>For example, this will close the file when the iterator is exhausted:</p>
<pre class="rst-literal-block">
upper_lines = (line.upper() for line in with_iter(open('foo')))
</pre>
<p>Any context manager which returns an iterable is a candidate for
<tt class="rst-docutils literal">with_iter</tt>.</p>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.zip_equal">
    
  </a>
  <a name="zip_equal">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">zip_equal</span>(*iterables):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1500">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p><tt class="rst-docutils literal">zip</tt> the input <em>iterables</em> together, but raise
<tt class="rst-docutils literal">UnequalIterablesError</tt> if they aren't all the same length.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>it_1 = <span class="py-builtin">range</span>(3)
<span class="py-prompt">&gt;&gt;&gt; </span>it_2 = <span class="py-builtin">iter</span>(<span class="py-string">'abc'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(zip_equal(it_1, it_2))
<span class="py-output">[(0, 'a'), (1, 'b'), (2, 'c')]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>it_1 = <span class="py-builtin">range</span>(3)
<span class="py-prompt">&gt;&gt;&gt; </span>it_2 = <span class="py-builtin">iter</span>(<span class="py-string">'abcd'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(zip_equal(it_1, it_2)) <span class="py-comment"># doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="py-except">Traceback (most recent call last):</span>
<span class="py-except">...</span>
<span class="py-except">more_itertools.more.UnequalIterablesError: Iterables have different</span>
<span class="py-except">lengths</span>
</pre></blockquote>
</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="setuptools._vendor.more_itertools.more.zip_offset">
    
  </a>
  <a name="zip_offset">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">zip_offset</span>(*iterables, offsets, longest=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>, fillvalue=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1546">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p><tt class="rst-docutils literal">zip</tt> the input <em>iterables</em> together, but offset the <code>i</code>-th iterable
by the <code>i</code>-th item in <em>offsets</em>.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(zip_offset(<span class="py-string">'0123'</span>, <span class="py-string">'abcdef'</span>, offsets=(0, 1)))
<span class="py-output">[('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]</span>
</pre></blockquote>
<p>This can be used as a lightweight alternative to SciPy or pandas to analyze
data sets in which some series have a lead or lag relationship.</p>
<p>By default, the sequence will end when the shortest iterable is exhausted.
To continue until the longest iterable is exhausted, set <em>longest</em> to
<tt class="rst-docutils literal">True</tt>.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">list</span>(zip_offset(<span class="py-string">'0123'</span>, <span class="py-string">'abcdef'</span>, offsets=(0, 1), longest=<span class="py-builtin">True</span>))
<span class="py-output">[('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]</span>
</pre></blockquote>
<p>By default, <tt class="rst-docutils literal">None</tt> will be used to replace offsets beyond the end of the
sequence. Specify <em>fillvalue</em> to use some other value.</p>
</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="setuptools._vendor.more_itertools.more._islice_helper">
    
  </a>
  <a name="_islice_helper">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_islice_helper</span>(it, s):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L2313">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="setuptools._vendor.more_itertools.more._sample_unweighted">
    
  </a>
  <a name="_sample_unweighted">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_sample_unweighted</span>(iterable, k):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3279">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="setuptools._vendor.more_itertools.more._sample_weighted">
    
  </a>
  <a name="_sample_weighted">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_sample_weighted</span>(iterable, k, weights):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L3305">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="setuptools._vendor.more_itertools.more._zip_equal_generator">
    
  </a>
  <a name="_zip_equal_generator">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_zip_equal_generator</span>(iterables):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L1492">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basevariable private">
  
  
  <a name="setuptools._vendor.more_itertools.more._marker">
    
  </a>
  <a name="_marker">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_marker</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/setuptools-60.9.3//setuptools/_vendor/more_itertools/more.py#L123">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for setuptools,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.0 at 2022-02-23 08:20:16.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>